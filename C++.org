#+SETUPFILE: ~/.emacs.d/themes/org-html-themes/setup/theme-readtheorg.setup
#+OPTIONS: \n:t
#+OPTIONS: ^:nil
#+OPTIONS: tex:t
#+STARTUP: latexpreview
#+OPTIONS: tex:dvipng
#+HTML_MATHJAX: align: left indent: 5em tagside: left font: Neo-Euler
#+attr_html: :width 300px
#+attr_latex: :width 300px
#+ATTR_ORG: :width 300

#+TITLE: C++ - 特性太多太复杂的语言

*上选java下选c，中不取c++*

* 基础学习
** 快速入门

访问程序返回值
- linux: echo $?
- win  : echo %ERRORLEVEL%

标准输入/输出
| istream -> cin  | 标准输入         |
| ostream -> cout | 标准输出         |
| ostream -> cerr | 标准错误         |
| ostream -> clog | 程序执行一般信息 |

cout, cin等输入、输出流对象返回值(调用方法)为输入、输出流本身，所以可以 cout << .... << .... <<

endl - 换行，默认 *同时刷新缓冲区*

定义一个类 == 定义了一种类型，类型名与类名相同

类方法 - 成员函数 - 由类定义的函火女禾禾

同一类型的所有对象共享同一个定义方法

** 基本语言

语言特性:允许自定义数据类型、提供库，妈实用函数和数据类型

单个unsigned == unsigned int

字面值常量有默认类型: 0 - int, 3.1415 - double

转义字符 \000 -> 八进制  \xddd -> 十六进制

两个相邻的字符串可连接，如 std::cout << "Hello World" "I'm" << endl;

#+begin_src c++
using namespace std;
#include <iostream>

int main(int argc, char *argv[])
{
    int val1(1024);             // 直接初始化
    int val2 = 1024;            // 复制初始化

    cout << val1 << "  " << val2 << endl;
    return 0;
}
#+end_src

构造函数 - 如何进行初始化的成员函数, *在gcc中，构造函数会在对象实例化后被调用*
对象定义后立即可见，可用同一定义中前面已定义变量的值初始化后面的变量

最大公约数 - 辗转相除法

#+begin_src c++
extern double pi = 3.14;       // 仍被当作定义，只有extern用作函数外部，才可以有初始化式
#+end_src

*C语言对于单个文件，为什么函数可不用声明直接调用， 不在此文件中的变量不可直接使用?*
*对函数，C风格有统一的ABI，C可根据入参直接生成汇编代码，而变量不知类型，不知占用空间大小，所以使用前需声明，对于C++，因为重载特性，入参类型会作为函数名的一部分，所以不能直接调用*

const限定符，将对象转化为常量，必须赋初值
全局作用域下的const变量，其作用域在文件内，除非定义时加上extern关键字
const修饰后编译时会直接转化为常量，如：
#+begin_src c++
using namespace std;
#include <iostream>

// 5 15
int main(int argc, char *argv[])
{
    const int x = 5;
    int *y = (int *)&x;

    *y = 15;
    cout << x << "  " << *y << endl; //相当于 cout << 5 << "  " << *y << endl;

    return 0;
}
#+end_src

引用是别名，必须初始化而且同一类型
#+begin_src c++
using namespace std;
#include <iostream>

// 10 10
int main(int argc, char *argv[])
{
    int val = 1024;
    int &val2 = val;

    val = 10;
    cout << val << "  " << val2 << endl;

    return 0;
}
#+end_src

枚举类型的对象的初始化或赋值，只能通过其枚举成员或同一枚举类型的其他对象来进行

*C语言中指明全局变量和static变量的初始化式必须为常量表达式，但是C++可以使用函数初始化，编译器实现为.finit段，在main执行前会执行.finit段中的函数*

头文件 <> - 查找在预定义位置，不找源文件所在路径
头文件 "" - 源文件所在路径, 后找预定义位置

class和struct关键字定义类区别在于默认访问权限
struct -> public
class  -> private

** 标准库类型

using namespace::name; - 此后无需再加命令空间前缀

- string
对于字符串长度有限制，不可大于long，重载了 + char 和 char *
#+begin_src c++
using namespace::std;
#include <iostream>

int main(int argc, char *argv[])
{
    string s1;
    string s2(s1);
    string s3("value");
    string s4(5, 'c');

    cout << s1 << endl; // 空
    cout << s2 << endl; // 空
    cout << s3 << endl; // value
    cout << s4 << endl; // ccccc

    cout << s1.empty() << endl; // 1
    cout << s3.size()  << endl; // 5
    cout << s3[0]      << endl; // v
    cout << s3 + s4    << endl; // valueccccc
    cout << (s3 == s4) << endl; // 0
    return 0;
}
#+end_src

::i 代表全局变量，用于局部变量重名覆盖时引用全局变量
#+begin_src c++
using namespace::std;
#include <iostream>

class A
{
public:
    A();
    virtual ~A();

    typedef int size;
};


int main(int argc, char *argv[])
{
    A::size i = 0;

    cout << i << endl;
    return 0;
}
#+end_src
- vector
#+begin_src c++
#include <iostream>
#include <vector>
#include <string>
using namespace::std;

int main(int argc, char *argv[])
{
    vector<string> v1;
    vector<string> v2(v1);
    vector<string> v3(5, "name");
    int i;

    for (i = 0; i < 5; ++i) {
        cout << v3[i] << endl;
    }


    return 0;
}
#+end_src

- iterator
#+begin_src c++
#include <iostream>
#include <vector>
#include <string>
using namespace::std;

int main(int argc, char *argv[])
{
    vector<string>           v3(5, "name");

    for(vector<string>::iterator iter = v3.begin(); iter != v3.end();++iter)
        cout << *iter << "\n";
    return 0;
}
#+end_src

- bitset
值比实际位少时，高阶位为0，string与bitset对象为反向转化，string对象的最右边为bitset低阶位
#+begin_src c++
#include <iostream>
#include <vector>
using namespace::std;

int main(int argc, char *argv[])
{
    bitset<12> b1("01010");

    cout << b1 << "\n";         // 000000001010
    return 0;
}
#+end_src

** 数组与指针
#+begin_src c++
#include <iostream>
using namespace::std;

int main(int argc, char *argv[])
{
    char a[3] = "12";
    char b[3] = "123";          // error: initializer-string for char array is too long
    int  c[3] = "12";           // error: array initializer must be an initializer list

    return 0;
}
#+end_src

- 动态数组
使用new，会将申请内存初始化，如果为类类型，将用默认构造函数初始化
#+begin_src c++
#include <iostream>
using namespace::std;

class A
{
public:
    A() {};
    virtual ~A() {};
};


int main(int argc, char *argv[])
{
    A *x = new A[2];
    A y[2];
    delete []x;
    return 0;
}
#+end_src

** 表达式

常规的和C相关
强制转换static_cast、dynamic_cast、const_cast、reinterpret_cast
#+begin_src c++
#include <iostream>
using namespace::std;

int main(int argc, char *argv[])
{
    char a = 'a';
    int b = static_cast<char>(a);//正确，将char型数据转换成int型数据

    double *c = new double;
    void *d = static_cast<void*>(c);//正确，将double指针转换成void指针

    int e = 10;
    const int f = static_cast<const int>(e);//正确，将int型数据转换成const int型数据

    const int g = 20;
    int *h = static_cast<int*>(&g);//编译错误，static_cast不能转换掉g的const属性
    return 0;
}
#+end_src

** 语句

只有构造函数可用 函数名():变量(值)的方法初始化变量
#+begin_src c++
#include <iostream>

class A
{
public:
    int i;
    A():i(1) {};
    virtual ~A() {};
};


int main(int argc, char *argv[])
{
    A x;

    std::cout << x.i << std::endl;
    return 0;
}
#+end_src

** 函数
对于引用形参
- 类型要严格匹配
- const不可传入非const
- 右值/具有需要转换的类型的对象

应将不修改相应实参的形参定义为const，因为这可以扩大函数的使用。因为非const引用形参既不能用const对象初始化，也不能用字面值或右值的表达试实参初始化

如果为引用数组，编译器不会将数组实参转化为指针，而是传递数组的引用本身，则数组大小成为形参和实参的一部分，编译器会检查大小，也不可将引用形参当指针给其赋值，而是要真正当作数组

*对于成员函数，如果在类中定义，则符号为weak，并且在本地文件里如果不调用函数则不会生成符号，而如果在类中声明类外定义，则为全局符号，如果文件内没使用也会生成符号*

*通常来说，在头文件(*.h)里声明类定义，在(*.cpp)里定义成员函数的实现*

对于临时对象，析构会在函数退出时调用
#+begin_src c++
#include <iostream>

class A
{
public:
    A() { std::cout << "A ctor" << "\n";};
    virtual ~A() {std::cout << "A dtor" << "\n";};
};

class B
{
public:
    B() { std::cout << "B ctor" << "\n";};
    virtual ~B() {std::cout << "B dtor" << "\n";};
};


//A ctor
//B ctor
//B dtor
//A dtor
int main(int argc, char *argv[])
{
    A x;
    B y;
    return 0;
}
#+end_src

** 标准I/O库

IO对象不可复制或赋值
- 不可存于容器
- 形参/返回类型不能为流类

当输入流与输出流绑在一起时，任何读输入流的尝试都将首先刷新其输出流关联的缓冲区
