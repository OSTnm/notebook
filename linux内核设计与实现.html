<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-10-14 Wed 23:25 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>程序员的自我修养 - 基于x86 linux2.6</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="xuali2" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">程序员的自我修养 - 基于x86 linux2.6</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgec9ebfe">1. 第一章 linux内核简介</a></li>
<li><a href="#orgfb323a5">2. 第二章 从内核出发</a></li>
<li><a href="#orgf234043">3. 第三章 进程管理</a></li>
<li><a href="#org70d57c0">4. 第四章 进程调度</a></li>
<li><a href="#org492c967">5. 第五章 系统调用</a>
<ul>
<li><a href="#org1de932c">5.1. 新增系统调用</a>
<ul>
<li><a href="#orgdea6e0c">5.1.1. 环境</a></li>
<li><a href="#orge412014">5.1.2. sys_foo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd25d0b7">6. 第六章 内核数据结构</a>
<ul>
<li><a href="#org7da6b98">6.1. 链表</a></li>
<li><a href="#org1b2af30">6.2. 数据队列</a></li>
<li><a href="#org45a4ddd">6.3. 映射</a></li>
<li><a href="#org4399c09">6.4. 红黑树</a></li>
</ul>
</li>
<li><a href="#orgd0530be">7. 第七章 中断和中断处理</a></li>
</ul>
</div>
</div>


<div id="outline-container-orgec9ebfe" class="outline-2">
<h2 id="orgec9ebfe"><span class="section-number-2">1</span> 第一章 linux内核简介</h2>
<div class="outline-text-2" id="text-1">
<p>
内核是一个不可分割的静态可执行文件<br />
</p>

<ul class="org-ul">
<li>单内核 - 单独的大过程，功能实现基本是函数调用，linux<br /></li>
<li>微内核 - 分割为多个独立的过程，少数运行在特权模式，过程间用IPC通信，但实际应用中由于开销比较大，向单内核靠拢<br /></li>
</ul>

<p>
linux版本 主版本号.从版本号.修订版本号.稳定版本号，其中 <b>从版本号偶数为稳定版</b><br />
</p>

<p>
上下文:<br />
</p>
<ul class="org-ul">
<li>运行于用户态，执行用户进程<br /></li>
<li>运行于内核空间，处于进程上下文，代表某个特定的进程执行 (int 0x80)<br /></li>
<li>运行于内核空间，处于中断上下文，与任何进程无关，处理特定中断， <b>实际是用了被中断进程的内核栈</b><br /></li>
</ul>
</div>
</div>

<div id="outline-container-orgfb323a5" class="outline-2">
<h2 id="orgfb323a5"><span class="section-number-2">2</span> 第二章 从内核出发</h2>
<div class="outline-text-2" id="text-2">
<p>
<b>git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git</b><br />
e40152ee1e1c7a63f4777791863215e3faa37a86<br />
</p>

<p>
iso: <a href="http://mirrors.ustc.edu.cn/ubuntu-old-releases/releases/10.04.0/ubuntu-10.04-desktop-i386.iso">http://mirrors.ustc.edu.cn/ubuntu-old-releases/releases/10.04.0/ubuntu-10.04-desktop-i386.iso</a><br />
</p>

<div class="org-src-container">
<pre class="src src-txt">###### Ubuntu Main Repos
######

deb http://old-releases.ubuntu.com/ubuntu/ lucid main restricted
deb-src http://old-releases.ubuntu.com/ubuntu/ lucid main restricted
</pre>
</div>

<p>
由于linux-2.6内核相对于现在来说很老了，最新的gcc glibc编译老的2.6内核会有各种问题，所以用老的基于linux2.6的系统最为方便<br />
</p>

<ul class="org-ul">
<li>软件包推荐<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">openssh-server</td>
<td class="org-left">ssh server</td>
</tr>

<tr>
<td class="org-left">vion</td>
<td class="org-left">VNC server，自带</td>
</tr>

<tr>
<td class="org-left">ncurses-dev</td>
<td class="org-left">make menuconfig所需</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>内核配置<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">make config</td>
<td class="org-left">遍历所有配置项</td>
</tr>

<tr>
<td class="org-left"><b>make menuconfig</b></td>
<td class="org-left">图形界面工具</td>
</tr>

<tr>
<td class="org-left">make defconfig</td>
<td class="org-left">缺省配置</td>
</tr>

<tr>
<td class="org-left">make oldconfig</td>
<td class="org-left">验证和更新配置</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>拷贝本系统配置<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-bash">zcat /proc/config.gz &gt; .config  <span style="color: #75715E;"># </span><span style="color: #E6DB74;">&#22914;&#26524;&#31995;&#32479;&#24050;&#24320;&#21551;CONFIG_IKCONFIG_PROC</span>
make oldconfig
</pre>
</div>

<ul class="org-ul">
<li>内核编译<br /></li>
</ul>
<p>
.config配置好以后, 执行make<br />
</p>

<ul class="org-ul">
<li>内核安装<br /></li>
<li>生成的arch/i386/boot/bzImage拷到/boot下<br /></li>
<li>make modules_install<br /></li>
</ul>

<p>
内核开发的特点<br />
</p>
<ul class="org-ul">
<li>无libc库或无标准头文件<br /></li>
<li>经常使用编译器扩展特性<br /></li>
</ul>
<p>
内联函数<br />
内联汇编<br />
链接脚本<br />
关于时间戳，是64位的，但是经常也用到高32位，为了防止每次都额外做一次位运算，定义两个符号，指向同一个地址，一个是32位的，一个是64位<br />
likely和unlikely<br />
</p>
<ul class="org-ul">
<li>无内存保护<br /></li>
<li>浮点<br /></li>
</ul>
<p>
以前的cpu做浮点运算都有个协处理器，这样会使CPU陷入，所以尽量不要用浮点<br />
</p>
<ul class="org-ul">
<li>内核栈大小有限，32位机默认是8KB<br /></li>
<li><b>同步和并发</b> 开了内核抢占和非抢占时锁的行为和中断发生的时为不一样，要特别注意<br /></li>
<li>可移植性，尽量做到体系无关<br /></li>
</ul>
</div>
</div>

<div id="outline-container-orgf234043" class="outline-2">
<h2 id="orgf234043"><span class="section-number-2">3</span> 第三章 进程管理</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>进程列表存放在任务队列的双向循环链表中 - task list<br /></li>
<li>task_struct指针在thread_info中，thread_info在内核栈栈底，这样获取thread_info地址简单的方法就是esp &amp; (0xFFFFFFFF &lt;&lt; 13)，task_struct就是(esp &amp; (0xFFFFFFFF &lt;&lt; 13))-&gt;task<br /></li>
</ul>

<p>
<b>像POWERPC, task_struct指针直接存在r2，相对的说原因之一就是x86的寄存器不够用</b><br />
</p>

<ul class="org-ul">
<li>默认最大PID是32768<br /></li>
<li>进程状态<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">TASK_RUNNINNG</td>
<td class="org-left">运行</td>
</tr>

<tr>
<td class="org-left">TASK_INNTERRUPTIBLE</td>
<td class="org-left">可中断，正在睡眠</td>
</tr>

<tr>
<td class="org-left">TASK_UNINTERRUPTIBLE</td>
<td class="org-left">类似可中断，但对信号不做响应</td>
</tr>

<tr>
<td class="org-left">__TASK_TRACED</td>
<td class="org-left">被其他进程跟踪</td>
</tr>

<tr>
<td class="org-left">__TASK_STOPPED</td>
<td class="org-left">进程停止执行</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>task-&gt;state是进程状态<br /></li>
<li>所有进程都是PID为1的init进程的后代， <b>而init进程的相关数据是静态写在kernel代码里的</b>, parent是父进程，childern是子进程链表，sibling是兄弟进程链表，同时所有进程在双向链表tasks中<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">volatile</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">state</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">-1 unrunnable, 0 runnable, &gt;0 stopped </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">stack</span>;
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">usage</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">per process flags, defined below </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ptrace</span>;

    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">lock_depth</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">BKL lock depth </span><span style="color: #75715E;">*/</span>

<span style="color: #F92672;">#ifdef</span> CONFIG_SMP
<span style="color: #F92672;">#ifdef</span> __ARCH_WANT_UNLOCKED_CTXSW
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">oncpu</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#endif</span>

    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">prio</span>, <span style="color: #FD971F;">static_prio</span>, <span style="color: #FD971F;">normal_prio</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">rt_priority</span>;
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_class</span> *<span style="color: #FD971F;">sched_class</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> <span style="color: #FD971F;">se</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_rt_entity</span> <span style="color: #FD971F;">rt</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_PREEMPT_NOTIFIERS
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">list of struct preempt_notifier: </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_head</span> <span style="color: #FD971F;">preempt_notifiers</span>;
<span style="color: #F92672;">#endif</span>

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * fpu_counter contains the number of consecutive context switches</span>
<span style="color: #E6DB74;">     * that the FPU is used. If this is over a threshold, the lazy fpu</span>
<span style="color: #E6DB74;">     * saving becomes unlazy to save the trap. This is an unsigned char</span>
<span style="color: #E6DB74;">     * so that after 256 times the counter wraps and the behavior turns</span>
<span style="color: #E6DB74;">     * lazy again; this to deal with bursty apps that only use FPU for</span>
<span style="color: #E6DB74;">     * a short time</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">fpu_counter</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_BLK_DEV_IO_TRACE
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">btrace_seq</span>;
<span style="color: #F92672;">#endif</span>

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">policy</span>;
    <span style="color: #66D9EF;">cpumask_t</span> <span style="color: #FD971F;">cpus_allowed</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_TREE_PREEMPT_RCU
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">rcu_read_lock_nesting</span>;
    <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">rcu_read_unlock_special</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rcu_node</span> *<span style="color: #FD971F;">rcu_blocked_node</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">rcu_node_entry</span>;
<span style="color: #F92672;">#endif</span> <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">#ifdef CONFIG_TREE_PREEMPT_RCU </span><span style="color: #75715E;">*/</span>

<span style="color: #F92672;">#if</span> <span style="color: #F92672;">defined</span><span style="color: #66D9EF;">(</span>CONFIG_SCHEDSTATS<span style="color: #66D9EF;">)</span> || <span style="color: #F92672;">defined</span><span style="color: #66D9EF;">(</span>CONFIG_TASK_DELAY_ACCT<span style="color: #66D9EF;">)</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_info</span> <span style="color: #FD971F;">sched_info</span>;
<span style="color: #F92672;">#endif</span>

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">tasks</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">plist_node</span> <span style="color: #FD971F;">pushable_tasks</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mm_struct</span> *<span style="color: #FD971F;">mm</span>, *<span style="color: #FD971F;">active_mm</span>;
<span style="color: #F92672;">#if</span> <span style="color: #F92672;">defined</span><span style="color: #66D9EF;">(</span>SPLIT_RSS_COUNTING<span style="color: #66D9EF;">)</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_rss_stat</span>    <span style="color: #FD971F;">rss_stat</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">task state </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">exit_state</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">exit_code</span>, <span style="color: #FD971F;">exit_signal</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">pdeath_signal</span>;  <span style="color: #75715E;">/*  </span><span style="color: #E6DB74;">The signal sent when the parent dies  </span><span style="color: #75715E;">*/</span>
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">??? </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">personality</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">did_exec</span>:1;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">in_execve</span>:1;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Tell the LSMs that the process is doing an</span>
<span style="color: #E6DB74;">                 * execve </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">in_iowait</span>:1;


    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Revert to default priority/policy when forking </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">sched_reset_on_fork</span>:1;

    <span style="color: #66D9EF;">pid_t</span> <span style="color: #FD971F;">pid</span>;
    <span style="color: #66D9EF;">pid_t</span> <span style="color: #FD971F;">tgid</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_CC_STACKPROTECTOR
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Canary value for the -fstack-protector gcc feature </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">stack_canary</span>;
<span style="color: #F92672;">#endif</span>

    <span style="color: #75715E;">/* </span>
<span style="color: #E6DB74;">     * pointers to (original) parent process, youngest child, younger sibling,</span>
<span style="color: #E6DB74;">     * older sibling, respectively.  (p-&gt;father can be replaced with </span>
<span style="color: #E6DB74;">     * p-&gt;real_parent-&gt;pid)</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">real_parent</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">real parent process </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">parent</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">recipient of SIGCHLD, wait4() reports </span><span style="color: #75715E;">*/</span>
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * children/sibling forms the list of my natural children</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">children</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">list of my children </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">sibling</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">linkage in my parent's children list </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">group_leader</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">threadgroup leader </span><span style="color: #75715E;">*/</span>

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * ptraced is the list of tasks this task is using ptrace on.</span>
<span style="color: #E6DB74;">     * This includes both natural children and PTRACE_ATTACH targets.</span>
<span style="color: #E6DB74;">     * p-&gt;ptrace_entry is p's link on the p-&gt;parent-&gt;ptraced list.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">ptraced</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">ptrace_entry</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * This is the tracer handle for the ptrace BTS extension.</span>
<span style="color: #E6DB74;">     * This field actually belongs to the ptracer task.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">bts_context</span> *<span style="color: #FD971F;">bts</span>;

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">PID/PID hash table linkage. </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_link</span> <span style="color: #FD971F;">pids</span><span style="color: #66D9EF;">[</span>PIDTYPE_MAX<span style="color: #66D9EF;">]</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">thread_group</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">completion</span> *<span style="color: #FD971F;">vfork_done</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">for vfork() </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *set_child_tid;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">CLONE_CHILD_SETTID </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *clear_child_tid;        <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">CLONE_CHILD_CLEARTID </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">cputime_t</span> <span style="color: #FD971F;">utime</span>, <span style="color: #FD971F;">stime</span>, <span style="color: #FD971F;">utimescaled</span>, <span style="color: #FD971F;">stimescaled</span>;
    <span style="color: #66D9EF;">cputime_t</span> <span style="color: #FD971F;">gtime</span>;
<span style="color: #F92672;">#if</span><span style="color: #F92672; font-weight: bold;">n</span><span style="color: #F92672;">def</span> CONFIG_VIRT_CPU_ACCOUNTING
    <span style="color: #66D9EF;">cputime_t</span> <span style="color: #FD971F;">prev_utime</span>, <span style="color: #FD971F;">prev_stime</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">nvcsw</span>, <span style="color: #FD971F;">nivcsw</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">context switch counts </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">timespec</span> <span style="color: #FD971F;">start_time</span>;         <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">monotonic time </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">timespec</span> <span style="color: #FD971F;">real_start_time</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">boot based time </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">min_flt</span>, <span style="color: #FD971F;">maj_flt</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_cputime</span> <span style="color: #FD971F;">cputime_expires</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">cpu_timers</span><span style="color: #66D9EF;">[</span>3<span style="color: #66D9EF;">]</span>;

<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">process credentials </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cred</span> *<span style="color: #FD971F;">real_cred</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">objective and real subjective task</span>
<span style="color: #E6DB74;">                     * credentials (COW) </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cred</span> *<span style="color: #FD971F;">cred</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">effective (overridable) subjective task</span>
<span style="color: #E6DB74;">                     * credentials (COW) </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mutex</span> <span style="color: #FD971F;">cred_guard_mutex</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">guard against foreign influences on</span>
<span style="color: #E6DB74;">                     * credential calculations</span>
<span style="color: #E6DB74;">                     * (notably. ptrace) </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cred</span> *<span style="color: #FD971F;">replacement_session_keyring</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">for KEYCTL_SESSION_TO_PARENT </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">comm</span><span style="color: #66D9EF;">[</span>TASK_COMM_LEN<span style="color: #66D9EF;">]</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">executable name excluding path</span>
<span style="color: #E6DB74;">                     - access with [gs]et_task_comm (which lock</span>
<span style="color: #E6DB74;">                       it with task_lock())</span>
<span style="color: #E6DB74;">                     - initialized normally by setup_new_exec </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">file system info </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">link_count</span>, <span style="color: #FD971F;">total_link_count</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_SYSVIPC
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">ipc stuff </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sysv_sem</span> <span style="color: #FD971F;">sysvsem</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_DETECT_HUNG_TASK
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">hung task detection </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">last_switch_count</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">CPU-specific state of this task </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">thread_struct</span> <span style="color: #FD971F;">thread</span>;
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">filesystem information </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">fs_struct</span> *<span style="color: #FD971F;">fs</span>;
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">open file information </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">files_struct</span> *<span style="color: #FD971F;">files</span>;
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">namespaces </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">nsproxy</span> *<span style="color: #FD971F;">nsproxy</span>;
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">signal handlers </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">signal_struct</span> *<span style="color: #FD971F;">signal</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sighand_struct</span> *<span style="color: #FD971F;">sighand</span>;

    <span style="color: #66D9EF;">sigset_t</span> <span style="color: #FD971F;">blocked</span>, <span style="color: #FD971F;">real_blocked</span>;
    <span style="color: #66D9EF;">sigset_t</span> <span style="color: #FD971F;">saved_sigmask</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">restored if set_restore_sigmask() was used </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sigpending</span> <span style="color: #FD971F;">pending</span>;

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">sas_ss_sp</span>;
    <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">sas_ss_size</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*notifier<span style="color: #66D9EF;">)(</span><span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">priv</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">notifier_data</span>;
    <span style="color: #66D9EF;">sigset_t</span> *<span style="color: #FD971F;">notifier_mask</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">audit_context</span> *<span style="color: #FD971F;">audit_context</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_AUDITSYSCALL
    <span style="color: #66D9EF;">uid_t</span> <span style="color: #FD971F;">loginuid</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">sessionid</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #66D9EF;">seccomp_t</span> <span style="color: #FD971F;">seccomp</span>;

<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Thread group tracking </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">parent_exec_id</span>;
    <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">self_exec_id</span>;
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Protection of (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed,</span>
<span style="color: #E6DB74;"> * mempolicy </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">spinlock_t</span> <span style="color: #FD971F;">alloc_lock</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_GENERIC_HARDIRQS
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">IRQ handler threads </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">irqaction</span> *<span style="color: #FD971F;">irqaction</span>;
<span style="color: #F92672;">#endif</span>

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Protection of the PI data structures: </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">raw_spinlock_t</span> <span style="color: #FD971F;">pi_lock</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_RT_MUTEXES
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">PI waiters blocked on a rt_mutex held by this task </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">plist_head</span> <span style="color: #FD971F;">pi_waiters</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Deadlock detection and priority inheritance handling </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rt_mutex_waiter</span> *<span style="color: #FD971F;">pi_blocked_on</span>;
<span style="color: #F92672;">#endif</span>

<span style="color: #F92672;">#ifdef</span> CONFIG_DEBUG_MUTEXES
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">mutex deadlock detection </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mutex_waiter</span> *<span style="color: #FD971F;">blocked_on</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_TRACE_IRQFLAGS
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">irq_events</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">hardirq_enable_ip</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">hardirq_disable_ip</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">hardirq_enable_event</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">hardirq_disable_event</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">hardirqs_enabled</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">hardirq_context</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">softirq_disable_ip</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">softirq_enable_ip</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">softirq_disable_event</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">softirq_enable_event</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">softirqs_enabled</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">softirq_context</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_LOCKDEP
<span style="color: #F92672;"># define</span> <span style="color: #FD971F;">MAX_LOCK_DEPTH</span> 48UL
    <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">curr_chain_key</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">lockdep_depth</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">lockdep_recursion</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">held_lock</span> <span style="color: #FD971F;">held_locks</span><span style="color: #66D9EF;">[</span>MAX_LOCK_DEPTH<span style="color: #66D9EF;">]</span>;
    <span style="color: #66D9EF;">gfp_t</span> <span style="color: #FD971F;">lockdep_reclaim_gfp</span>;
<span style="color: #F92672;">#endif</span>

<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">journalling filesystem info </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">journal_info</span>;

<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">stacked block device info </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">bio_list</span> *<span style="color: #FD971F;">bio_list</span>;

<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">VM state </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">reclaim_state</span> *<span style="color: #FD971F;">reclaim_state</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">backing_dev_info</span> *<span style="color: #FD971F;">backing_dev_info</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">io_context</span> *<span style="color: #FD971F;">io_context</span>;

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">ptrace_message</span>;
    <span style="color: #66D9EF;">siginfo_t</span> *<span style="color: #FD971F;">last_siginfo</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">For ptrace use.  </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_io_accounting</span> <span style="color: #FD971F;">ioac</span>;
<span style="color: #F92672;">#if</span> <span style="color: #F92672;">defined</span><span style="color: #66D9EF;">(</span>CONFIG_TASK_XACCT<span style="color: #66D9EF;">)</span>
    <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">acct_rss_mem1</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">accumulated rss usage </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">acct_vm_mem1</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">accumulated virtual memory usage </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">cputime_t</span> <span style="color: #FD971F;">acct_timexpd</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">stime + utime since last update </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_CPUSETS
    <span style="color: #66D9EF;">nodemask_t</span> <span style="color: #FD971F;">mems_allowed</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Protected by alloc_lock </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cpuset_mem_spread_rotor</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_CGROUPS
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Control Group info protected by css_set_lock </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">css_set</span> *<span style="color: #FD971F;">cgroups</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">cg_list protected by css_set_lock and tsk-&gt;alloc_lock </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">cg_list</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_FUTEX
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">robust_list_head</span> <span style="color: #66D9EF;">__user</span> *<span style="color: #FD971F;">robust_list</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_COMPAT
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">compat_robust_list_head</span> <span style="color: #66D9EF;">__user</span> *<span style="color: #FD971F;">compat_robust_list</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">pi_state_list</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">futex_pi_state</span> *<span style="color: #FD971F;">pi_state_cache</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_PERF_EVENTS
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">perf_event_context</span> *<span style="color: #FD971F;">perf_event_ctxp</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mutex</span> <span style="color: #FD971F;">perf_event_mutex</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">perf_event_list</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_NUMA
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mempolicy</span> *<span style="color: #FD971F;">mempolicy</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Protected by alloc_lock </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">short</span> <span style="color: #FD971F;">il_next</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">fs_excl</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">holding fs exclusive resources </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rcu_head</span> <span style="color: #FD971F;">rcu</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * cache last used pipe for splice</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pipe_inode_info</span> *<span style="color: #FD971F;">splice_pipe</span>;
<span style="color: #F92672;">#ifdef</span>  CONFIG_TASK_DELAY_ACCT
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_delay_info</span> *<span style="color: #FD971F;">delays</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_FAULT_INJECTION
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">make_it_fail</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">prop_local_single</span> <span style="color: #FD971F;">dirties</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_LATENCYTOP
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">latency_record_count</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">latency_record</span> <span style="color: #FD971F;">latency_record</span><span style="color: #66D9EF;">[</span>LT_SAVECOUNT<span style="color: #66D9EF;">]</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * time slack values; these are used to round up poll() and</span>
<span style="color: #E6DB74;">     * select() etc timeout values. These are in nanoseconds.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">timer_slack_ns</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">default_timer_slack_ns</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    *<span style="color: #FD971F;">scm_work_list</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_FUNCTION_GRAPH_TRACER
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Index of current stored address in ret_stack </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">curr_ret_stack</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Stack of return addresses for return function tracing </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ftrace_ret_stack</span> *<span style="color: #FD971F;">ret_stack</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">time stamp for last schedule </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">ftrace_timestamp</span>;
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * Number of functions that haven't been traced</span>
<span style="color: #E6DB74;">     * because of depth overrun.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">trace_overrun</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Pause for the tracing </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">tracing_graph_pause</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_TRACING
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">state flags for use by tracers </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">trace</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">bitmask of trace recursion </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">trace_recursion</span>;
<span style="color: #F92672;">#endif</span> <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">CONFIG_TRACING </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_CGROUP_MEM_RES_CTLR <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">memcg uses this to do batch job </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">memcg_batch_info</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">do_batch</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">incremented when batch uncharge started </span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mem_cgroup</span> *<span style="color: #FD971F;">memcg</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">target memcg of uncharge </span><span style="color: #75715E;">*/</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">bytes</span>;        <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">uncharged usage </span><span style="color: #75715E;">*/</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">memsw_bytes</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">uncharged mem+swap usage </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">}</span> <span style="color: #FD971F;">memcg_batch</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">thread_info</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span>  *<span style="color: #FD971F;">task</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">main task structure </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">exec_domain</span>  *<span style="color: #FD971F;">exec_domain</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">execution domain </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">__u32</span>           <span style="color: #FD971F;">flags</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">low level flags </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">__u32</span>           <span style="color: #FD971F;">status</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">thread synchronous flags </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">__u32</span>           <span style="color: #FD971F;">cpu</span>;        <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">current CPU </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span>         <span style="color: #FD971F;">preempt_count</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">0 =&gt; preemptable,</span>
<span style="color: #E6DB74;">                           &lt;0 =&gt; BUG </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">mm_segment_t</span>        <span style="color: #FD971F;">addr_limit</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">restart_block</span>    <span style="color: #FD971F;">restart_block</span>;
    <span style="color: #66D9EF;">void</span> <span style="color: #FD971F;">__user</span>     *sysenter_return;
<span style="color: #F92672;">#ifdef</span> CONFIG_X86_32
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>           <span style="color: #FD971F;">previous_esp</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">ESP of the previous stack in</span>
<span style="color: #E6DB74;">                           case of nested (IRQ) stacks</span>
<span style="color: #E6DB74;">                        </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">__u8</span>            <span style="color: #FD971F;">supervisor_stack</span><span style="color: #66D9EF;">[</span>0<span style="color: #66D9EF;">]</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #66D9EF;">int</span>         <span style="color: #FD971F;">uaccess_err</span>;
<span style="color: #AE81FF;">}</span>;
</pre>
</div>
<ul class="org-ul">
<li>写时拷贝,页权限设为只读，真正要写的时候再拷贝新页<br /></li>

<li>用户态fork -&gt; 用户态clone -&gt; 内核态do_fork -&gt; copy_process:<br /></li>
</ul>
<p>
dup_task_struct<br />
检查进程资源限制<br />
子进程task_struct某些信息清0<br />
子进程state = UNINTERRUPTIBLE<br />
copy_flags<br />
alloc_pid申请子进程pid<br />
资源分配<br />
</p>
<ul class="org-ul">
<li>vfork为了那些马上exec的进程使用，不推荐<br /></li>
<li>linux进程与线程的区别只在与是否共享某些资源<br /></li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">CLONE 参数标志</th>
<th scope="col" class="org-left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">CLONE_FILES</td>
<td class="org-left">共享打开的文件</td>
</tr>

<tr>
<td class="org-left">CLONE_FS</td>
<td class="org-left">共享文件系统信息</td>
</tr>

<tr>
<td class="org-left">CLONE_IDLETASK</td>
<td class="org-left">PID设为0(dedicated for init process)</td>
</tr>

<tr>
<td class="org-left">CLONE_NEWNS</td>
<td class="org-left">子进程有新的命令空间</td>
</tr>

<tr>
<td class="org-left">CLONE_PARENT</td>
<td class="org-left">子进程与父进程拥有同一个父进程</td>
</tr>

<tr>
<td class="org-left">CLONE_PTRACE</td>
<td class="org-left">调试子进程，gdb会用这个</td>
</tr>

<tr>
<td class="org-left">CLONE_SETTID</td>
<td class="org-left">将TID回写至用户空间</td>
</tr>

<tr>
<td class="org-left">CLONE_SETTLS</td>
<td class="org-left">为子进程创建新的TLS</td>
</tr>

<tr>
<td class="org-left">CLONE_SIGHAND</td>
<td class="org-left">共享信号处理函数及被阻断的信号</td>
</tr>

<tr>
<td class="org-left">CLONE_SYSVEM</td>
<td class="org-left">共享SytemV SEM_UNDO语义</td>
</tr>

<tr>
<td class="org-left">CLONE_THREAD</td>
<td class="org-left">相同的线程组</td>
</tr>

<tr>
<td class="org-left">CLONE_VFORK</td>
<td class="org-left">vfork()使用</td>
</tr>

<tr>
<td class="org-left">CLONE_UNTRACED</td>
<td class="org-left">防止被trace,主要是防止跟踪</td>
</tr>

<tr>
<td class="org-left">CLONE_STOP</td>
<td class="org-left">以TASK_STOPPED状态开始进程</td>
</tr>

<tr>
<td class="org-left">CLONE_CHILD_CLEARTID</td>
<td class="org-left">清除子进程的TID</td>
</tr>

<tr>
<td class="org-left">CLONE_CHILD_SETTID</td>
<td class="org-left">设置子进程的TID</td>
</tr>

<tr>
<td class="org-left">CLONE_PARENT_SETTID</td>
<td class="org-left">设置父进程的TID</td>
</tr>

<tr>
<td class="org-left">CLONE_VM</td>
<td class="org-left"><b>共享地址空间</b></td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>内核线程，没用用户空间的线程， mm为NULL, 相关头文件为kthread.h<br /></li>
<li>exit -&gt; do_exit，永不返回<br /></li>
</ul>
<p>
task_struct标志PF_EXITING<br />
del_timer_sync<br />
exit_sem, exit_mm, exit_files, exit_fs<br />
设置exit_code<br />
exit_notify让其父进程为其子进程重新设置父进程，同时设状态为ZOMBIE<br />
schedule，父进程通过wait帮其清理内核栈, thread_info，task_struct<br />
</p>
<ul class="org-ul">
<li>wait<br /></li>
</ul>
<p>
为退出进程的子进程找新的父进程<br />
为被退出进程trace的进程找新的父进程<br />
</p>
</div>
</div>

<div id="outline-container-org70d57c0" class="outline-2">
<h2 id="org70d57c0"><span class="section-number-2">4</span> 第四章 进程调度</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>preemption 内核调度程序决定进程挂起与运行<br /></li>
<li>yielding   进程本身主动挂起<br /></li>
<li>进程调度在响应时间和吞吐量之间做平衡<br /></li>
<li>传统的绝对时间片会引发的固定的切换频率问题，linux使用了公平调度<br /></li>
</ul>
<p>
se 是调度器实体<br />
vruntime 虚拟实时，系统定时器周期性调用update_curr()更新<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">load_weight</span>  <span style="color: #FD971F;">load</span>;       <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">for load-balancing </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_node</span>      <span style="color: #FD971F;">run_node</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">group_node</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">on_rq</span>;

    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">exec_start</span>;
    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">sum_exec_runtime</span>;
    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">vruntime</span>;
    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">prev_sum_exec_runtime</span>;

    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">last_wakeup</span>;
    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">avg_overlap</span>;

    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">nr_migrations</span>;

    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">start_runtime</span>;
    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">avg_wakeup</span>;
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">...</span>
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">update_curr</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">curr</span> = cfs_rq-&gt;curr;
    <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">now</span> = <span style="color: #A6E22E; font-weight: bold;">rq_of</span><span style="color: #66D9EF;">(</span>cfs_rq<span style="color: #66D9EF;">)</span>-&gt;clock;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">delta_exec</span>;

    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #A6E22E; font-weight: bold;">unlikely</span><span style="color: #A6E22E;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span>curr<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>
        <span style="color: #F92672;">return</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * Get the amount of time the current task was running</span>
<span style="color: #E6DB74;">     * since the last time we changed load (this cannot</span>
<span style="color: #E6DB74;">     * overflow on 32 bits):</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    delta_exec = <span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span><span style="color: #66D9EF;">)(</span>now - curr-&gt;exec_start<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span>delta_exec<span style="color: #66D9EF;">)</span>
        <span style="color: #F92672;">return</span>;

    <span style="color: #A6E22E; font-weight: bold;">__update_curr</span><span style="color: #66D9EF;">(</span>cfs_rq, curr, delta_exec<span style="color: #66D9EF;">)</span>;
    curr-&gt;exec_start = now;

    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #A6E22E; font-weight: bold;">entity_is_task</span><span style="color: #A6E22E;">(</span>curr<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">curtask</span> = <span style="color: #A6E22E; font-weight: bold;">task_of</span><span style="color: #A6E22E;">(</span>curr<span style="color: #A6E22E;">)</span>;

        <span style="color: #A6E22E; font-weight: bold;">trace_sched_stat_runtime</span><span style="color: #A6E22E;">(</span>curtask, delta_exec, curr-&gt;vruntime<span style="color: #A6E22E;">)</span>;
        <span style="color: #A6E22E; font-weight: bold;">cpuacct_charge</span><span style="color: #A6E22E;">(</span>curtask, delta_exec<span style="color: #A6E22E;">)</span>;
        <span style="color: #A6E22E; font-weight: bold;">account_group_exec_runtime</span><span style="color: #A6E22E;">(</span>curtask, delta_exec<span style="color: #A6E22E;">)</span>;
    <span style="color: #66D9EF;">}</span>
<span style="color: #AE81FF;">}</span>

<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span>
<span style="color: #A6E22E; font-size: 130%;">__update_curr</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">curr</span>,
          <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">delta_exec</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">delta_exec_weighted</span>;

    <span style="color: #A6E22E; font-weight: bold;">schedstat_set</span><span style="color: #66D9EF;">(</span>curr-&gt;exec_max, <span style="color: #A6E22E; font-weight: bold;">max</span><span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">(</span><span style="color: #66D9EF;">u64</span><span style="color: #E6DB74;">)</span>delta_exec, curr-&gt;exec_max<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;

    curr-&gt;sum_exec_runtime += delta_exec;
    <span style="color: #A6E22E; font-weight: bold;">schedstat_add</span><span style="color: #66D9EF;">(</span>cfs_rq, exec_clock, delta_exec<span style="color: #66D9EF;">)</span>;
    delta_exec_weighted = <span style="color: #A6E22E; font-weight: bold;">calc_delta_fair</span><span style="color: #66D9EF;">(</span>delta_exec, curr<span style="color: #66D9EF;">)</span>;

    curr-&gt;vruntime += delta_exec_weighted;
    <span style="color: #A6E22E; font-weight: bold;">update_min_vruntime</span><span style="color: #66D9EF;">(</span>cfs_rq<span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>

</pre>
</div>

<ul class="org-ul">
<li>进程选择<br /></li>
</ul>
<p>
红黑树<br />
enqueue_entity +进程<br />
dequeue_entity -进程<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #A6E22E; font-size: 130%;">__pick_next_entity</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_node</span> *<span style="color: #FD971F;">left</span> = cfs_rq-&gt;rb_leftmost;

    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span>left<span style="color: #66D9EF;">)</span>
        <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;

    <span style="color: #F92672;">return</span> <span style="color: #A6E22E; font-weight: bold;">rb_entry</span><span style="color: #66D9EF;">(</span>left, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span>, run_node<span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>


</pre>
</div>

<ul class="org-ul">
<li>调度器函数 schedule-&gt;pick_next_task，会从高优先级到低优先级调度器类中找第一个进程<br /></li>
<li>休眠<br /></li>
</ul>
<p>
从可执行红黑树中移出，放入等待队列<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #A6E22E; font-size: 130%;">DEFINE_WAIT</span><span style="color: #AE81FF;">(</span>wait<span style="color: #AE81FF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21019;&#24314;&#38431;&#21015;&#39033;</span>
<span style="color: #A6E22E; font-size: 130%;">add_wait_queue</span><span style="color: #AE81FF;">(</span>q, &amp;wait<span style="color: #AE81FF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21152;&#20837;&#31561;&#24453;&#38431;&#21015;</span>
<span style="color: #A6E22E; font-weight: bold;">while</span><span style="color: #AE81FF;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span>condition<span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#26465;&#20214;&#19981;&#28385;&#36275;</span>
    <span style="color: #A6E22E; font-weight: bold;">prepare_to_wait</span><span style="color: #66D9EF;">(</span>&amp;q, &amp;wait, TASK_INTERRUPTIBLE<span style="color: #66D9EF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#35774;&#32622;&#36827;&#31243;&#29366;&#24577;&#65292;&#22914;&#26524;&#27492;&#26102;&#24050;&#36864;&#20986;&#31561;&#24453;&#38431;&#21015;&#65292;&#37325;&#26032;&#21152;&#20837;</span>
    <span style="color: #A6E22E; font-weight: bold;">if</span><span style="color: #66D9EF;">(</span><span style="color: #A6E22E; font-weight: bold;">signal_pending</span><span style="color: #A6E22E;">(</span>current<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span> <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#22788;&#29702;&#20449;&#21495;</span>
    <span style="color: #A6E22E; font-weight: bold;">schedule</span><span style="color: #66D9EF;">()</span>;<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#35843;&#24230;</span>
<span style="color: #AE81FF;">}</span>
<span style="color: #A6E22E; font-weight: bold;">finish_wait</span><span style="color: #AE81FF;">(</span>&amp;q, &amp;wait<span style="color: #AE81FF;">)</span>;<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#32467;&#26463;&#31561;&#24453;</span>
</pre>
</div>
<ul class="org-ul">
<li>唤醒<br /></li>
</ul>
<p>
从等待队列移到红黑树<br />
</p>
<ul class="org-ul">
<li>上下文切换<br /></li>
</ul>
<p>
switch_mm 切换虚拟内存映射<br />
switch_to 切换寄存器组<br />
</p>
<ul class="org-ul">
<li>用户抢占<br /></li>
</ul>
<p>
发生在系统调用或中断处理程序返回用户空间<br />
</p>
<ul class="org-ul">
<li>内核抢占<br /></li>
</ul>
<p>
<b>非内核抢占的操作系统中，调度程序没有办法在一个内核级的任务正在执行的时候重新调度</b><br />
thread_info-&gt;preempt_count为0时，可抢占(此时是否重新调度取决于need_resched)<br />
a. 中断处理程序返回内核空间<br />
b. 内核代码再一次有抢占性<br />
c. 显示调用schedule<br />
d. 内核任务阻塞(一般是加到等待队列，同时调用schedule)<br />
</p>
<ul class="org-ul">
<li>实时调度策略<br /></li>
</ul>
<p>
在sched_rt.c中,之前的CFS在sched_fair.c(SCHED_NORMAL)中<br />
a. SCHED_FIFO, 一直执行到主动放弃或被更高优先级抢占<br />
b. SCHED_RR, 带时间片的SCHED_FIFO<br />
实时优先级为静态优先级，不像普通进程会动态计算优先级<br />
</p>
<ul class="org-ul">
<li>优先级范围<br /></li>
</ul>
<p>
nice -20~+19 相当于 实时优先级 100~139<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;"> * Priority of a process goes from 0..MAX_PRIO-1, valid RT</span>
<span style="color: #E6DB74;"> * priority is 0..MAX_RT_PRIO-1, and SCHED_NORMAL/SCHED_BATCH</span>
<span style="color: #E6DB74;"> * tasks are in the range MAX_RT_PRIO..MAX_PRIO-1. Priority</span>
<span style="color: #E6DB74;"> * values are inverted: lower p-&gt;prio value means higher priority.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * The MAX_USER_RT_PRIO value allows the actual maximum</span>
<span style="color: #E6DB74;"> * RT priority to be separate from the value exported to</span>
<span style="color: #E6DB74;"> * user-space.  This allows kernel threads to set their</span>
<span style="color: #E6DB74;"> * priority to a value higher than any user task. Note:</span>
<span style="color: #E6DB74;"> * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.</span>
<span style="color: #E6DB74;"> </span><span style="color: #75715E;">*/</span>

<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">MAX_USER_RT_PRIO</span>    100
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">MAX_RT_PRIO</span>     MAX_USER_RT_PRIO

<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">MAX_PRIO</span>        <span style="color: #AE81FF;">(</span>MAX_RT_PRIO + 40<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">DEFAULT_PRIO</span>        <span style="color: #AE81FF;">(</span>MAX_RT_PRIO + 20<span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org492c967" class="outline-2">
<h2 id="org492c967"><span class="section-number-2">5</span> 第五章 系统调用</h2>
<div class="outline-text-2" id="text-5">
<p>
除异常和陷入外内核唯一的合法入口<br />
<b>当进程从用户态切换至内核栈时,X86会进行栈切换(取出tss段中的esp0)</b><br />
<b>需保证系统调用是可重入的,因为进程上下文中，内核可被抢占，所以同时可能存在多个相同的系统调用</b><br />
<b>反过来说中断处理程序不能休眠</b><br />
</p>

<p>
<b>asmlinkage</b> 限制词表示用栈传数据<br />
sys_call_table 是内核的系统调用表<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #E6DB74;">entry_32.S</span>
<span style="color: #AE81FF;">syscall_call</span>:
    <span style="color: #66D9EF;">call</span> *<span style="color: #A6E22E; font-size: 130%;">sys_call_table</span><span style="color: #AE81FF;">(</span>,%eax,4<span style="color: #AE81FF;">)</span>
    movl %eax,<span style="color: #A6E22E; font-weight: bold;">PT_EAX</span><span style="color: #AE81FF;">(</span>%esp<span style="color: #AE81FF;">)</span>      # store the <span style="color: #F92672;">return</span> value

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">entry_64.S</span>
<span style="color: #A6E22E; font-weight: bold;">ENTRY</span><span style="color: #AE81FF;">(</span>system_call<span style="color: #AE81FF;">)</span>
    CFI_STARTPROC   simple
    CFI_SIGNAL_FRAME
    <span style="color: #66D9EF;">CFI_DEF_CFA</span> <span style="color: #FD971F;">rsp</span>,<span style="color: #FD971F;">KERNEL_STACK_OFFSET</span>
    CFI_REGISTER    rip,<span style="color: #FD971F;">rcx</span>
    <span style="color: #75715E;">/*</span><span style="color: #E6DB74;">CFI_REGISTER  rflags,r11</span><span style="color: #75715E;">*/</span>
    SWAPGS_UNSAFE_STACK
</pre>
</div>

<p>
内核和用户空间间做数据传输时有可能会引起阻塞（所需页在磁盘上）<br />
</p>
<ul class="org-ul">
<li>copy_from_user 从用户空间拷贝<br /></li>
<li>copy_to_user   拷贝到用户空间<br /></li>
</ul>

<p>
capable可检查是否可操作指定资源<br />
</p>
</div>

<div id="outline-container-org1de932c" class="outline-3">
<h3 id="org1de932c"><span class="section-number-3">5.1</span> 新增系统调用</h3>
<div class="outline-text-3" id="text-5-1">
</div>
<div id="outline-container-orgdea6e0c" class="outline-4">
<h4 id="orgdea6e0c"><span class="section-number-4">5.1.1</span> 环境</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>linux kernel<br /></li>
</ul>
<p>
a. make defconfig<br />
b. make menuconfig<br />
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #75715E;"># </span><span style="color: #E6DB74;">make menuconfig</span>
[ ] Network packet filtering framework (Netfilter)  ---&gt;
</pre>
</div>
<p>
c. make<br />
</p>
<ul class="org-ul">
<li>busybox<br /></li>
</ul>
<p>
<b>git://git.busybox.net/busybox</b><br />
e50f74da70da645c25d7daa81b2d9796a738f718 tag: 1_24_2<br />
</p>

<p>
a. make menuconfig<br />
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #75715E;"># </span><span style="color: #E6DB74;">make menuconfig</span>
[*] Don<span style="color: #E6DB74;">'t use /usr</span>
<span style="color: #E6DB74;">[*] Build BusyBox as a static binary (no shared libs)</span>
<span style="color: #E6DB74;">[ ] sync</span>
</pre>
</div>
<p>
b. make<br />
c. make install<br />
</p>
<ul class="org-ul">
<li>initramfs<br /></li>
</ul>
<p>
a. 建立目录<br />
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #75715E;">#</span><span style="color: #E6DB74;">!/bin/</span><span style="color: #F92672;">bash</span>
mkdir -pv initramfs/x86-busybox
<span style="color: #F92672;">cd</span> initramfs/x86-busybox
mkdir -pv {bin,sbin,etc,proc,sys,usr/{bin,sbin}}
cp -av /mnt/hgfs/linux-2.6-git/busybox/_install/* .
</pre>
</div>
<p>
b. 在目录下建立init<br />
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #75715E;">#</span><span style="color: #E6DB74;">!/bin/</span><span style="color: #F92672;">sh</span>
mount -t proc none /proc
mount -t sysfs none /sys
<span style="color: #F92672;">echo</span> -e <span style="color: #E6DB74;">"\nBoot took $(</span><span style="color: #AE81FF; font-weight: bold;">cut</span><span style="color: #E6DB74;"> -d' ' -f1 /proc/uptime) seconds\n"</span>
<span style="color: #F92672;">exec</span> /bin/sh
</pre>
</div>
<p>
c. 生成initramfs<br />
在目录下<br />
find . -print0 | cpio &#x2013;null -ov &#x2013;format=newc | gzip -9 &gt; x86.cpio.gz<br />
</p>
<ul class="org-ul">
<li>qemu<br /></li>
</ul>
<p>
qemu -kernel bzImage -initrd ./x86.cpio.gz -nographic -append "console=ttyS0"<br />
</p>
</div>
</div>

<div id="outline-container-orge412014" class="outline-4">
<h4 id="orge412014"><span class="section-number-4">5.1.2</span> sys_foo</h4>
<div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>kernel<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #75715E;">; </span><span style="color: #E6DB74;">arch/x86/kernel/syscall_table_32.S</span>
  ...
      <span style="color: #F92672;">.long</span> sys_rt_tgsigqueueinfo   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">335 */</span>
      <span style="color: #F92672;">.long</span> sys_perf_event_open
      <span style="color: #F92672;">.long</span> sys_recvmmsg
      <span style="color: #F92672;">.long</span> sys_foo               <span style="color: #75715E;">;</span><span style="color: #E6DB74;">&#26032;&#22686;338</span>
  ...
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #E6DB74;">kernel/sys.c</span>
asmlinkage <span style="color: #66D9EF;">long</span> <span style="color: #A6E22E; font-size: 130%;">sys_foo</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">void</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">return</span> 0xabcd;
<span style="color: #AE81FF;">}</span>
</pre>
</div>
<ul class="org-ul">
<li>app<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #E6DB74;">foo_app.c : gcc -static foo_app.c -o foo_app</span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#include</span> <span style="color: #AE81FF;">&lt;</span><span style="color: #E6DB74;">stdio.h</span><span style="color: #AE81FF;">&gt;</span>
<span style="color: #F92672;">#include</span> <span style="color: #AE81FF;">&lt;</span><span style="color: #E6DB74;">syscall.h</span><span style="color: #AE81FF;">&gt;</span>

<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">__NR_foo</span> 338
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">main</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">argc</span>, <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">argv</span><span style="color: #66D9EF;">[]</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #A6E22E; font-weight: bold;">printf</span><span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"new sys_call return 0x%x\n"</span>, <span style="color: #A6E22E; font-weight: bold;">syscall</span><span style="color: #A6E22E;">(</span>__NR_foo<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">return</span> 0;
<span style="color: #AE81FF;">}</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #75715E;">#</span><span style="color: #E6DB74;">&#32769;&#30340;kernel</span>
new sys_call return 0xffffffff

<span style="color: #75715E;">#</span><span style="color: #E6DB74;">&#20462;&#25913;&#36807;&#30340;kernel</span>
new sys_call return 0xabcd
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd25d0b7" class="outline-2">
<h2 id="orgd25d0b7"><span class="section-number-2">6</span> 第六章 内核数据结构</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org7da6b98" class="outline-3">
<h3 id="org7da6b98"><span class="section-number-3">6.1</span> 链表</h3>
<div class="outline-text-3" id="text-6-1">
<p>
linux/list.h<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #AE81FF;">{</span>
      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">next</span>, *<span style="color: #FD971F;">prev</span>;
  <span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">  #define</span> <span style="color: #A6E22E; font-size: 130%;">LIST_HEAD_INIT</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">name</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span> &amp;<span style="color: #66D9EF;">(</span>name<span style="color: #66D9EF;">)</span>, &amp;<span style="color: #66D9EF;">(</span>name<span style="color: #66D9EF;">)</span> <span style="color: #AE81FF;">}</span> <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#38745;&#24577;&#22768;&#26126;</span>
<span style="color: #F92672;">  #define</span> <span style="color: #A6E22E; font-size: 130%;">LIST_HEAD</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">name</span><span style="color: #AE81FF;">)</span> \
      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">name</span> = <span style="color: #A6E22E; font-weight: bold;">LIST_HEAD_INIT</span><span style="color: #AE81FF;">(</span>name<span style="color: #AE81FF;">)</span>

  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">INIT_LIST_HEAD</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">list</span><span style="color: #AE81FF;">)</span> <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21160;&#24577;</span>
  <span style="color: #AE81FF;">{</span>
      list-&gt;next = list;
      list-&gt;prev = list;
  <span style="color: #AE81FF;">}</span>

  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">__list_add</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">new</span>,
                    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">prev</span>,
                    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">next</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      next-&gt;prev = new;
      new-&gt;next = next;
      new-&gt;prev = prev;
      prev-&gt;next = new;
  <span style="color: #AE81FF;">}</span>

  <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21152;&#20803;&#32032;&#65292;&#22312;head&#21518;&#38754;</span>
  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">list_add</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">new</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #A6E22E; font-weight: bold;">__list_add</span><span style="color: #66D9EF;">(</span>new, head, head-&gt;next<span style="color: #66D9EF;">)</span>;
  <span style="color: #AE81FF;">}</span>

  <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21152;&#20803;&#32032;&#65292;&#22312;&#38142;&#34920;&#23614;</span>
  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">list_add_tail</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">new</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #A6E22E; font-weight: bold;">__list_add</span><span style="color: #66D9EF;">(</span>new, head-&gt;prev, head<span style="color: #66D9EF;">)</span>;
  <span style="color: #AE81FF;">}</span>

  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">__list_del</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> * <span style="color: #FD971F;">prev</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> * <span style="color: #FD971F;">next</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      next-&gt;prev = prev;
      prev-&gt;next = next; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#20114;&#30456;&#25346;&#25509;</span>
  <span style="color: #AE81FF;">}</span>

  <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21024;&#38500;&#20803;&#32032;</span>
  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">list_del</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">entry</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #A6E22E; font-weight: bold;">__list_del</span><span style="color: #66D9EF;">(</span>entry-&gt;prev, entry-&gt;next<span style="color: #66D9EF;">)</span>;
      entry-&gt;next = LIST_POISON1;
      entry-&gt;prev = LIST_POISON2;
  <span style="color: #AE81FF;">}</span>


  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">list_move</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">list</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #A6E22E; font-weight: bold;">__list_del</span><span style="color: #66D9EF;">(</span>list-&gt;prev, list-&gt;next<span style="color: #66D9EF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">list&#20174;&#24403;&#21069;&#38142;&#34920;&#36864;&#20986;</span>
      <span style="color: #A6E22E; font-weight: bold;">list_add</span><span style="color: #66D9EF;">(</span>list, head<span style="color: #66D9EF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21152;&#21040;head&#21518;</span>
  <span style="color: #AE81FF;">}</span>

  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">list_move_tail</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">list</span>,
                    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #A6E22E; font-weight: bold;">__list_del</span><span style="color: #66D9EF;">(</span>list-&gt;prev, list-&gt;next<span style="color: #66D9EF;">)</span>;
      <span style="color: #A6E22E; font-weight: bold;">list_add_tail</span><span style="color: #66D9EF;">(</span>list, head<span style="color: #66D9EF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21152;&#21040;head-&gt;prev&#21518;</span>
  <span style="color: #AE81FF;">}</span>


  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">&lt;= head &lt;=&gt; head1 &lt;=&gt; head2 &lt;=&gt; .... head_end =&gt; </span><span style="color: #75715E;">*/</span>
  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">&lt;= list &lt;=&gt; list1 &lt;=&gt; list2 &lt;=&gt; .... list_end =&gt; </span><span style="color: #75715E;">*/</span>

  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">&lt;= head &lt;=&gt; list1 &lt;=&gt; list2 &lt;=&gt; .... list_end &lt;=&gt; head1 &lt;=&gt; head2 ... head_end =&gt; </span><span style="color: #75715E;">*/</span>
  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">__list_splice</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">list</span>,
                   <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">prev</span>,
                   <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">next</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">first</span> = list-&gt;next;
      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">last</span> = list-&gt;prev;

      first-&gt;prev = prev;
      prev-&gt;next = first;         <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">head &lt;=&gt; list-&gt;next </span><span style="color: #75715E;">*/</span>

      last-&gt;next = next;          <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">head-&gt;next &lt;=&gt; list-&gt;prev</span><span style="color: #75715E;">*/</span>
      next-&gt;prev = last;
  <span style="color: #AE81FF;">}</span>

  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">list_splice</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">list</span>,
                  <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span><span style="color: #A6E22E; font-weight: bold;">list_empty</span><span style="color: #A6E22E;">(</span>list<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>
          <span style="color: #A6E22E; font-weight: bold;">__list_splice</span><span style="color: #66D9EF;">(</span>list, head, head-&gt;next<span style="color: #66D9EF;">)</span>;
  <span style="color: #AE81FF;">}</span>

<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * list_for_each    -   iterate over a list</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@pos</span><span style="color: #E6DB74;">:    the &amp;struct list_head to use as a loop cursor.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@head</span><span style="color: #E6DB74;">:   the head for your list.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#36941;&#21382;</span>
<span style="color: #F92672;"> #define</span> <span style="color: #A6E22E; font-size: 130%;">list_for_each</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">pos</span>, <span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span> \
    <span style="color: #A6E22E; font-weight: bold;">for</span> <span style="color: #AE81FF;">(</span>pos = <span style="color: #66D9EF;">(</span>head<span style="color: #66D9EF;">)</span>-&gt;next; <span style="color: #A6E22E; font-weight: bold;">prefetch</span><span style="color: #66D9EF;">(</span>pos-&gt;next<span style="color: #66D9EF;">)</span>, pos != <span style="color: #66D9EF;">(</span>head<span style="color: #66D9EF;">)</span>; \
            pos = pos-&gt;next<span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * list_entry - get the struct for this entry</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@ptr</span><span style="color: #E6DB74;">:    the &amp;struct list_head pointer.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@type</span><span style="color: #E6DB74;">:   the type of the struct this is embedded in.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@member</span><span style="color: #E6DB74;">: the name of the list_struct within the struct.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #F92672;"> #define</span> <span style="color: #A6E22E; font-size: 130%;">list_entry</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">ptr</span>, <span style="color: #FD971F;">type</span>, <span style="color: #FD971F;">member</span><span style="color: #AE81FF;">)</span> \
    <span style="color: #A6E22E; font-weight: bold;">container_of</span><span style="color: #AE81FF;">(</span>ptr, type, member<span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * list_for_each_entry  -   iterate over list of given type</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@pos</span><span style="color: #E6DB74;">:    the type * to use as a loop cursor.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@head</span><span style="color: #E6DB74;">:   the head for your list.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@member</span><span style="color: #E6DB74;">: the name of the list_struct within the struct.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #F92672;"> #define</span> <span style="color: #A6E22E; font-size: 130%;">list_for_each_entry</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">pos</span>, <span style="color: #FD971F;">head</span>, <span style="color: #FD971F;">member</span><span style="color: #AE81FF;">)</span>             \
    <span style="color: #A6E22E; font-weight: bold;">for</span> <span style="color: #AE81FF;">(</span>pos = <span style="color: #A6E22E; font-weight: bold;">list_entry</span><span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>head<span style="color: #A6E22E;">)</span>-&gt;next, <span style="color: #A6E22E; font-weight: bold;">typeof</span><span style="color: #A6E22E;">(</span>*pos<span style="color: #A6E22E;">)</span>, member<span style="color: #66D9EF;">)</span>;  \
         <span style="color: #A6E22E; font-weight: bold;">prefetch</span><span style="color: #66D9EF;">(</span>pos-&gt;member.next<span style="color: #66D9EF;">)</span>, &amp;pos-&gt;member != <span style="color: #66D9EF;">(</span>head<span style="color: #66D9EF;">)</span>;    \
         pos = <span style="color: #A6E22E; font-weight: bold;">list_entry</span><span style="color: #66D9EF;">(</span>pos-&gt;member.next, <span style="color: #A6E22E; font-weight: bold;">typeof</span><span style="color: #A6E22E;">(</span>*pos<span style="color: #A6E22E;">)</span>, member<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * list_for_each_safe - iterate over a list safe against removal of list entry</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@pos</span><span style="color: #E6DB74;">:    the &amp;struct list_head to use as a loop cursor.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@n</span><span style="color: #E6DB74;">:      another &amp;struct list_head to use as temporary storage</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@head</span><span style="color: #E6DB74;">:   the head for your list.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#23433;&#20840;&#36941;&#21382;&#65292;&#29992;&#20110;&#22312;foreach&#20013;&#21024;&#38500;&#20803;&#32032;</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">list_for_each_safe</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">pos</span>, <span style="color: #FD971F;">n</span>, <span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span> \
    <span style="color: #A6E22E; font-weight: bold;">for</span> <span style="color: #AE81FF;">(</span>pos = <span style="color: #66D9EF;">(</span>head<span style="color: #66D9EF;">)</span>-&gt;next, n = pos-&gt;next; pos != <span style="color: #66D9EF;">(</span>head<span style="color: #66D9EF;">)</span>; \
        pos = n, n = pos-&gt;next<span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org1b2af30" class="outline-3">
<h3 id="org1b2af30"><span class="section-number-3">6.2</span> 数据队列</h3>
<div class="outline-text-3" id="text-6-2">
<p>
linux/kfifo.h<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">__kfifo_initializer</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">s</span>, <span style="color: #FD971F;">b</span><span style="color: #AE81FF;">)</span> \
    <span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span> \
        .size   = s, \
        .in = 0, \
        .out    = 0, \
        .buffer = b \
    <span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#32852;&#21512;&#20307;&#65292;&#22836;&#20026;kfifo&#32467;&#26500;&#65292;&#21518;&#38754;&#20026;buffer size</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">DECLARE_KFIFO</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">name</span>, <span style="color: #FD971F;">size</span><span style="color: #AE81FF;">)</span> \
<span style="color: #F92672;">union</span> <span style="color: #AE81FF;">{</span> \
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span> <span style="color: #FD971F;">name</span>; \
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">name</span>##kfifo_buffer<span style="color: #66D9EF;">[</span>size + <span style="color: #A6E22E; font-weight: bold;">sizeof</span><span style="color: #A6E22E;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">]</span>; \
<span style="color: #AE81FF;">}</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * INIT_KFIFO - Initialize a kfifo declared by DECLARE_KFIFO</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@name</span><span style="color: #E6DB74;">: name of the declared kfifo datatype</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">INIT_KFIFO</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">name</span><span style="color: #AE81FF;">)</span> \
    name = <span style="color: #A6E22E; font-weight: bold;">__kfifo_initializer</span><span style="color: #AE81FF;">(</span><span style="color: #A6E22E; font-weight: bold;">sizeof</span><span style="color: #66D9EF;">(</span>name##kfifo_buffer<span style="color: #66D9EF;">)</span> - \
                <span style="color: #A6E22E; font-weight: bold;">sizeof</span><span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span><span style="color: #66D9EF;">)</span>, \
                name##kfifo_buffer + <span style="color: #A6E22E; font-weight: bold;">sizeof</span><span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#20998;&#31163;&#30340;&#32467;&#26500;&#65292;&#19968;&#20010;&#26159;kfifo&#65292;&#25346;&#25509;buffer</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">DEFINE_KFIFO</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">name</span>, <span style="color: #FD971F;">size</span><span style="color: #AE81FF;">)</span> \
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">name</span>##kfifo_buffer<span style="color: #AE81FF;">[</span>size<span style="color: #AE81FF;">]</span>; \
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span> <span style="color: #FD971F;">name</span> = <span style="color: #A6E22E; font-weight: bold;">__kfifo_initializer</span><span style="color: #AE81FF;">(</span>size, name##kfifo_buffer<span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * kfifo_alloc - allocates a new FIFO internal buffer</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@fifo</span><span style="color: #E6DB74;">: the fifo to assign then new buffer</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@size</span><span style="color: #E6DB74;">: the size of the buffer to be allocated, this have to be a power of 2.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@gfp_mask</span><span style="color: #E6DB74;">: get_free_pages mask, passed to </span><span style="color: #AE81FF;">kmalloc()</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This function dynamically allocates a new fifo internal buffer</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * The size will be rounded-up to a power of 2.</span>
<span style="color: #E6DB74;"> * The buffer will be release with </span><span style="color: #AE81FF;">kfifo_free()</span><span style="color: #E6DB74;">.</span>
<span style="color: #E6DB74;"> * Return 0 if no error, otherwise the an error code</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#30003;&#35831;</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">kfifo_alloc</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span> *<span style="color: #FD971F;">fifo</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">size</span>, <span style="color: #66D9EF;">gfp_t</span> <span style="color: #FD971F;">gfp_mask</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#25512;&#20837;</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * kfifo_in - puts some data into the FIFO</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@fifo</span><span style="color: #E6DB74;">: the fifo to be used.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@from</span><span style="color: #E6DB74;">: the data to be added.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@len</span><span style="color: #E6DB74;">: the length of the data to be added.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This function copies at most </span><span style="color: #AE81FF;">@len</span><span style="color: #E6DB74;"> bytes from the </span><span style="color: #AE81FF;">@from</span><span style="color: #E6DB74;"> buffer into</span>
<span style="color: #E6DB74;"> * the FIFO depending on the free space, and returns the number of</span>
<span style="color: #E6DB74;"> * bytes copied.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * Note that with only one concurrent reader and one concurrent</span>
<span style="color: #E6DB74;"> * writer, you don't need extra locking to use these functions.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">kfifo_in</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span> *<span style="color: #FD971F;">fifo</span>, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">from</span>,
                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span><span style="color: #AE81FF;">)</span>


<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21462;&#20986;</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * kfifo_out - gets some data from the FIFO</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@fifo</span><span style="color: #E6DB74;">: the fifo to be used.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@to</span><span style="color: #E6DB74;">: where the data must be copied.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@len</span><span style="color: #E6DB74;">: the size of the destination buffer.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This function copies at most </span><span style="color: #AE81FF;">@len</span><span style="color: #E6DB74;"> bytes from the FIFO into the</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@to</span><span style="color: #E6DB74;"> buffer and returns the number of copied bytes.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * Note that with only one concurrent reader and one concurrent</span>
<span style="color: #E6DB74;"> * writer, you don't need extra locking to use these functions.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">kfifo_out</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span> *<span style="color: #FD971F;">fifo</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">to</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span><span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org45a4ddd" class="outline-3">
<h3 id="org45a4ddd"><span class="section-number-3">6.3</span> 映射</h3>
<div class="outline-text-3" id="text-6-3">
<p>
linux/idr.h<br />
不像python里的dict,key就是UID，是自动生成的<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21021;&#22987;&#21270;</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * idr_init - initialize idr handle</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@idp</span><span style="color: #E6DB74;">:    idr handle</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This function is use to set up the handle (</span><span style="color: #AE81FF;">@idp</span><span style="color: #E6DB74;">) that you will pass</span>
<span style="color: #E6DB74;"> * to the rest of the functions.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">idr_init</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">idr</span> *<span style="color: #FD971F;">idp</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#39044;&#20998;&#37197;UID</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * idr_pre_get - reserver resources for idr allocation</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@idp</span><span style="color: #E6DB74;">:    idr handle</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@gfp_mask</span><span style="color: #E6DB74;">:   memory allocation flags</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This function should be called prior to locking and calling the</span>
<span style="color: #E6DB74;"> * idr_get_new* functions. It preallocates enough memory to satisfy</span>
<span style="color: #E6DB74;"> * the worst possible allocation.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * If the system is REALLY out of memory this function returns 0,</span>
<span style="color: #E6DB74;"> * otherwise 1.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">idr_pre_get</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">idr</span> *<span style="color: #FD971F;">idp</span>, <span style="color: #66D9EF;">gfp_t</span> <span style="color: #FD971F;">gfp_mask</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#26144;&#23556;</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * idr_get_new - allocate new idr entry</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@idp</span><span style="color: #E6DB74;">: idr handle</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@ptr</span><span style="color: #E6DB74;">: pointer you want associated with the id</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@id</span><span style="color: #E6DB74;">: pointer to the allocated handle</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This is the allocate id function.  It should be called with any</span>
<span style="color: #E6DB74;"> * required locks.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * If memory is required, it will return -EAGAIN, you should unlock</span>
<span style="color: #E6DB74;"> * and go back to the </span><span style="color: #AE81FF;">idr_pre_get()</span><span style="color: #E6DB74;"> call.  If the idr is full, it will</span>
<span style="color: #E6DB74;"> * return -ENOSPC.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@id</span><span style="color: #E6DB74;"> returns a value in the range 0 ... 0x7fffffff</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">idr_get_new</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">idr</span> *<span style="color: #FD971F;">idp</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">ptr</span>, <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">id</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#26681;&#25454;UID&#21462;ptr</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * idr_find - return pointer for given id</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@idp</span><span style="color: #E6DB74;">: idr handle</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@id</span><span style="color: #E6DB74;">: lookup key</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * Return the pointer given the id it has been registered with.  A </span><span style="color: #AE81FF;">%NULL</span>
<span style="color: #E6DB74;"> * return indicates that </span><span style="color: #AE81FF;">@id</span><span style="color: #E6DB74;"> is not valid or you passed </span><span style="color: #AE81FF;">%NULL</span><span style="color: #E6DB74;"> in</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">idr_get_new()</span><span style="color: #E6DB74;">.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This function can be called under </span><span style="color: #AE81FF;">rcu_read_lock()</span><span style="color: #E6DB74;">, given that the leaf</span>
<span style="color: #E6DB74;"> * pointers lifetimes are correctly managed.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">void</span> *<span style="color: #A6E22E; font-size: 130%;">idr_find</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">idr</span> *<span style="color: #FD971F;">idp</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">id</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21024;&#38500;UID</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * idr_remove - remove the given id and free it's slot</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@idp</span><span style="color: #E6DB74;">: idr handle</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@id</span><span style="color: #E6DB74;">: unique key</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">idr_remove</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">idr</span> *<span style="color: #FD971F;">idp</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">id</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21024;&#38500;idr</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * idr_destroy - release all cached layers within an idr tree</span>
<span style="color: #E6DB74;"> * idp: idr handle</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">idr_destroy</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">idr</span> *<span style="color: #FD971F;">idp</span><span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4399c09" class="outline-3">
<h3 id="org4399c09"><span class="section-number-3">6.4</span> 红黑树</h3>
<div class="outline-text-3" id="text-6-4">
<p>
linux/rbtree.h<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21021;&#22987;&#21270;</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_root</span> <span style="color: #FD971F;">root</span> = RB_ROOT;

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#32418;&#40657;&#26641;&#27809;&#26377;&#25554;&#20837;&#21644;&#26597;&#25214;&#25509;&#21475;&#65292;&#38656;&#33258;&#24050;&#23454;&#29616;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> * <span style="color: #A6E22E; font-size: 130%;">rb_search_page_cache</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> * <span style="color: #FD971F;">inode</span>,
                         <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">offset</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_node</span> * <span style="color: #FD971F;">n</span> = inode-&gt;i_rb_page_cache.rb_node;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> * <span style="color: #FD971F;">page</span>;

    <span style="color: #A6E22E; font-weight: bold;">while</span> <span style="color: #66D9EF;">(</span>n<span style="color: #66D9EF;">)</span>
    <span style="color: #66D9EF;">{</span>
        page = <span style="color: #A6E22E; font-weight: bold;">rb_entry</span><span style="color: #A6E22E;">(</span>n, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span>, rb_page_cache<span style="color: #A6E22E;">)</span>;

        <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #A6E22E;">(</span>offset &lt; page-&gt;offset<span style="color: #A6E22E;">)</span>
            n = n-&gt;rb_left;
        <span style="color: #F92672;">else</span> <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #A6E22E;">(</span>offset &gt; page-&gt;offset<span style="color: #A6E22E;">)</span>
            n = n-&gt;rb_right;
        <span style="color: #F92672;">else</span>
            <span style="color: #F92672;">return</span> page;
    <span style="color: #66D9EF;">}</span>
    <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> * <span style="color: #A6E22E; font-size: 130%;">rb_insert_page_cache</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> * <span style="color: #FD971F;">inode</span>,
                         <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">offset</span>,
                         <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_node</span> * <span style="color: #FD971F;">node</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> * <span style="color: #FD971F;">ret</span>;
    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>ret = <span style="color: #A6E22E; font-weight: bold;">__rb_insert_page_cache</span><span style="color: #E6DB74;">(</span>inode, offset, node<span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
    <span style="color: #A6E22E; font-weight: bold;">rb_insert_color</span><span style="color: #66D9EF;">(</span>node, &amp;inode-&gt;i_rb_page_cache<span style="color: #66D9EF;">)</span>;
 <span style="color: #AE81FF;">out</span>:
    <span style="color: #F92672;">return</span> ret;
<span style="color: #AE81FF;">}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd0530be" class="outline-2">
<h2 id="orgd0530be"><span class="section-number-2">7</span> 第七章 中断和中断处理</h2>
<div class="outline-text-2" id="text-7">
<p>
中断可能随时发生，中断上下文不可阻塞<br />
</p>

<p>
上半部 - 处理有严格时限的工作<br />
下半部 - 处理大量逻辑的工作<br />
</p>

<p>
request_irq里会调用kmalloc，有时会导致睡眠<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #E6DB74;">irq     &#20013;&#26029;&#21495; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">handler &#20013;&#26029;&#22788;&#29702;&#31243;&#24207; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">flags   &#20013;&#26029;&#22788;&#29702;&#26631;&#24535; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">- IRQF_DISABLE       &#20013;&#26029;&#22788;&#29702;&#31243;&#24207;&#26102;&#31105;&#27490;&#25152;&#26377;&#20013;&#26029; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">- IRQF_SAMPLE_RANDOM &#38543;&#26426;&#29109;&#28304; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">- IRQF_TIMER         &#19987;&#20026;&#31995;&#32479;&#23450;&#26102;&#22120;&#30340;&#20013;&#26029;&#22788;&#29702; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">- IRQF_SHARED        &#20849;&#20139;&#20013;&#26029;&#32447; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">name    ASCII&#25991;&#26412; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">dev     &#20849;&#20139;&#20013;&#26029;&#26102;&#30340;priv&#25351;&#38024; </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">typedef</span> <span style="color: #66D9EF;">irqreturn_t</span> <span style="color: #AE81FF;">(</span>*<span style="color: #66D9EF;">irq_handler_t</span><span style="color: #AE81FF;">)(</span><span style="color: #66D9EF;">int</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #AE81FF;">)</span>;
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">__must_check</span>
<span style="color: #A6E22E; font-weight: bold;">request_irq</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">irq</span>, <span style="color: #66D9EF;">irq_handler_t</span> <span style="color: #FD971F;">handler</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span>,
        <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">name</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">dev</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">return</span> <span style="color: #A6E22E; font-weight: bold;">request_threaded_irq</span><span style="color: #66D9EF;">(</span>irq, handler, <span style="color: #AE81FF;">NULL</span>, flags, name, dev<span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #F92672;">extern</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">free_irq</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
<b>linux的中断处理程序无须重入，当一个中断执行时，相应的中断号会在所有处理器上被屏蔽，同一个中断处理程充绝不会同时被调用以处理嵌套中断</b><br />
</p>

<p>
共享中断要求<br />
</p>
<ol class="org-ol">
<li>IRQF_SHARED<br /></li>
<li>dev参数唯一<br /></li>
<li>必须区分是自已的设备产生了中断，而不是共享了这个中断号的其他设备<br /></li>
</ol>

<p>
中断上下文和进程无关，所以不可以睡眠，同时有严格的时间限制<br />
</p>

<p>
中断流程<br />
硬件产生一个中断 -&gt; 中断控制器 -&gt; 处理器 -&gt; 处理器中断内核 -&gt; do_IRQ() -&gt; handle_IRQ_event() 可能在此开启其他中断 -&gt; 运行挂接的所有中断处理程序 -&gt; 关中断 -&gt; ret_from_intr()<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;"> * do_IRQ handles all normal device IRQ's (the special</span>
<span style="color: #E6DB74;"> * SMP cross-CPU interrupts have their own specific</span>
<span style="color: #E6DB74;"> * handlers).</span>
<span style="color: #E6DB74;"> </span><span style="color: #75715E;">*/</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">__irq_entry</span> <span style="color: #A6E22E; font-weight: bold;">do_IRQ</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pt_regs</span> *<span style="color: #FD971F;">regs</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pt_regs</span> *<span style="color: #FD971F;">old_regs</span> = <span style="color: #A6E22E; font-weight: bold;">set_irq_regs</span><span style="color: #66D9EF;">(</span>regs<span style="color: #66D9EF;">)</span>;

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">high bit used in ret_from_ code  </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">vector</span> = ~regs-&gt;orig_ax;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">irq</span>;

    <span style="color: #A6E22E; font-weight: bold;">exit_idle</span><span style="color: #66D9EF;">()</span>;
    <span style="color: #A6E22E; font-weight: bold;">irq_enter</span><span style="color: #66D9EF;">()</span>;

    irq = <span style="color: #A6E22E; font-weight: bold;">__get_cpu_var</span><span style="color: #66D9EF;">(</span>vector_irq<span style="color: #66D9EF;">)[</span>vector<span style="color: #66D9EF;">]</span>;

    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span><span style="color: #A6E22E; font-weight: bold;">handle_irq</span><span style="color: #A6E22E;">(</span>irq, regs<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #A6E22E; font-weight: bold;">ack_APIC_irq</span><span style="color: #A6E22E;">()</span>;

        <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #A6E22E;">(</span><span style="color: #A6E22E; font-weight: bold;">printk_ratelimit</span><span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span>
            <span style="color: #A6E22E; font-weight: bold;">pr_emerg</span><span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"%s: %d.%d No irq handler for vector (irq %d)\n"</span>,
                __func__, <span style="color: #A6E22E; font-weight: bold;">smp_processor_id</span><span style="color: #E6DB74;">()</span>, vector, irq<span style="color: #A6E22E;">)</span>;
    <span style="color: #66D9EF;">}</span>

    <span style="color: #A6E22E; font-weight: bold;">irq_exit</span><span style="color: #66D9EF;">()</span>;

    <span style="color: #A6E22E; font-weight: bold;">set_irq_regs</span><span style="color: #66D9EF;">(</span>old_regs<span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">return</span> 1;
<span style="color: #AE81FF;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #A6E22E; font-size: 130%;">ret_from_intr</span>:
    <span style="color: #F92672;">GET_THREAD_INFO</span>(<span style="color: #FD971F;">%ebp</span>)
<span style="color: #A6E22E; font-size: 130%;">check_userspace</span>:
    <span style="color: #F92672;">movl</span> PT_EFLAGS(<span style="color: #FD971F;">%esp</span>), <span style="color: #FD971F;">%eax</span>  # mix EFLAGS and CS
    <span style="color: #F92672;">movb</span> PT_CS(<span style="color: #FD971F;">%esp</span>), <span style="color: #FD971F;">%al</span> <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#26816;&#26597;&#26632;&#20013;&#30340;cs&#65292;&#26159;&#21542;&#26159;&#29992;&#25143;&#26435;&#38480;&#26469;&#21028;&#26029;&#26159;&#21542;&#20174;&#29992;&#25143;&#24577;&#20013;&#26029;</span>
    <span style="color: #F92672;">andl</span> $(X86_EFLAGS_VM | SEGMENT_RPL_MASK), <span style="color: #FD971F;">%eax</span>
    <span style="color: #F92672;">cmpl</span> $USER_RPL, <span style="color: #FD971F;">%eax</span>
    <span style="color: #F92672;">jb</span> resume_kernel        # not returning to v8086 or userspace

<span style="color: #A6E22E; font-size: 130%;">ENTRY</span>(resume_userspace)
    <span style="color: #F92672;">LOCKDEP_SYS_EXIT</span>
    <span style="color: #F92672;">DISABLE_INTERRUPTS</span>(CLBR_ANY)    # make sure we don't miss an interrupt
                    # setting need_resched or sigpending
                    # between sampling and the iret
    <span style="color: #F92672;">TRACE_IRQS_OFF</span>
    <span style="color: #F92672;">movl</span> TI_flags(<span style="color: #FD971F;">%ebp</span>), <span style="color: #FD971F;">%ecx</span>
    <span style="color: #F92672;">andl</span> $_TIF_WORK_MASK, <span style="color: #FD971F;">%ecx</span>  # is there any work to be done on
                    # int/exception return?
    <span style="color: #F92672;">jne</span> work_pending
    <span style="color: #F92672;">jmp</span> restore_all
</pre>
</div>

<p>
如下，第一列中断号，第二列是中断计数，第三列是中断控制器，第四列是中断名<br />
</p>
<div class="org-src-container">
<pre class="src src-bash">        CPU0       
 0:        268   IO-APIC-edge      timer
 1:       3261   IO-APIC-edge      i8042
 4:      31532   IO-APIC-edge    
 8:          1   IO-APIC-edge      rtc0
 9:          0   IO-APIC-fasteoi   acpi
12:       6289   IO-APIC-edge      i8042
14:          0   IO-APIC-edge      ata_piix
15:          0   IO-APIC-edge      ata_piix
16:     229317   IO-APIC-fasteoi   eth1
17:      52749   IO-APIC-fasteoi   ioc0, Ensoniq AudioPCI
18:        228   IO-APIC-fasteoi   ehci_hcd:usb1, uhci_hcd:usb2
</pre>
</div>

<p>
中断控制<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">说明</th>
<th scope="col" class="org-left">可否嵌套</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">local_irq_disable</td>
<td class="org-left">禁止本地中断</td>
<td class="org-left">否</td>
</tr>

<tr>
<td class="org-left">local_irq_enable</td>
<td class="org-left">使能本地中断</td>
<td class="org-left">否</td>
</tr>

<tr>
<td class="org-left">local_irq_save</td>
<td class="org-left">保存本地中断状态，禁止本地中断</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">local_irq_restore</td>
<td class="org-left">恢复之前的中断状态</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">disable_irq</td>
<td class="org-left">等待所有处理程序完毕，才关指点定中断线</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">disable_irq_nosync</td>
<td class="org-left">不等，直接关</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">enable_irq</td>
<td class="org-left">使能指定中断线</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">synchronize_irq</td>
<td class="org-left">等待直到中断处理程序退出</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">irqs_disabled</td>
<td class="org-left">本地中断是否关闭</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">in_interrupt</td>
<td class="org-left">中断上下文为0(包括下半部，判断软件标记位)，进程上下文为1</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">in_irq</td>
<td class="org-left">正在执行中断处理程为1</td>
<td class="org-left">N/A</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: xuali2</p>
<p class="date">Created: 2020-10-14 Wed 23:25</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
