<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-10-24 六 21:48 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>linux内核设计与实现 - 基于x86 linux2.6</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="xuali2" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">linux内核设计与实现 - 基于x86 linux2.6</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org179ccb3">1. 第一章 linux内核简介</a></li>
<li><a href="#org82f936b">2. 第二章 从内核出发</a></li>
<li><a href="#orgf9839d3">3. 第三章 进程管理</a></li>
<li><a href="#org56a7278">4. 第四章 进程调度</a></li>
<li><a href="#org3dc3de9">5. 第五章 系统调用</a>
<ul>
<li><a href="#org1fe883f">5.1. 新增系统调用</a>
<ul>
<li><a href="#org05dbf15">5.1.1. 环境</a></li>
<li><a href="#org2f00859">5.1.2. sys_foo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org733883b">6. 第六章 内核数据结构</a>
<ul>
<li><a href="#org6d858c1">6.1. 链表</a></li>
<li><a href="#org615b994">6.2. 数据队列</a></li>
<li><a href="#orgd4b74fb">6.3. 映射</a></li>
<li><a href="#orgb32c7dd">6.4. 红黑树</a></li>
</ul>
</li>
<li><a href="#org4ef9fe1">7. 第七章 中断和中断处理</a></li>
<li><a href="#orgae86db9">8. 第八章 下半部和推后执行的工作</a></li>
<li><a href="#org75effc6">9. 第九章 内核同步介绍</a></li>
<li><a href="#org978921c">10. 第十章 内核同步方法</a></li>
<li><a href="#org189a8ce">11. 第十一章 定时器和时间管理</a></li>
<li><a href="#org43234df">12. 第十二章 内存管理</a></li>
<li><a href="#org3a0d70b">13. 第十三章 虚拟文件系统</a></li>
<li><a href="#orgcbef99c">14. 第十四章 块I/O层</a></li>
<li><a href="#orgdd0454b">15. 第十五章 进程地址空间</a></li>
<li><a href="#orgd784b54">16. 第十六章 页高速缓存和页回写</a></li>
<li><a href="#org7545ecf">17. 第十七章 设备与模块</a></li>
<li><a href="#org8dfcf0c">18. 第十八章 调试</a></li>
<li><a href="#org9bc92ef">19. 第十九章 可移植性</a></li>
<li><a href="#orgf81b955">20. 第二十章 补丁、开发和社区</a></li>
</ul>
</div>
</div>


<div id="outline-container-org179ccb3" class="outline-2">
<h2 id="org179ccb3"><span class="section-number-2">1</span> 第一章 linux内核简介</h2>
<div class="outline-text-2" id="text-1">
<p>
内核是一个不可分割的静态可执行文件<br />
</p>

<ul class="org-ul">
<li>单内核 - 单独的大过程，功能实现基本是函数调用，linux<br /></li>
<li>微内核 - 分割为多个独立的过程，少数运行在特权模式，过程间用IPC通信，但实际应用中由于开销比较大，向单内核靠拢<br /></li>
</ul>

<p>
linux版本 主版本号.从版本号.修订版本号.稳定版本号，其中 <b>从版本号偶数为稳定版</b><br />
</p>

<p>
上下文:<br />
</p>
<ul class="org-ul">
<li>运行于用户态，执行用户进程<br /></li>
<li>运行于内核空间，处于进程上下文，代表某个特定的进程执行 (int 0x80)<br /></li>
<li>运行于内核空间，处于中断上下文，与任何进程无关，处理特定中断， <b>实际是用了被中断进程的内核栈</b><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org82f936b" class="outline-2">
<h2 id="org82f936b"><span class="section-number-2">2</span> 第二章 从内核出发</h2>
<div class="outline-text-2" id="text-2">
<p>
<b>git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git</b><br />
e40152ee1e1c7a63f4777791863215e3faa37a86<br />
</p>

<p>
iso: <a href="http://mirrors.ustc.edu.cn/ubuntu-old-releases/releases/10.04.0/ubuntu-10.04-desktop-i386.iso">http://mirrors.ustc.edu.cn/ubuntu-old-releases/releases/10.04.0/ubuntu-10.04-desktop-i386.iso</a><br />
</p>

<div class="org-src-container">
<pre class="src src-txt">###### Ubuntu Main Repos
######

deb http://old-releases.ubuntu.com/ubuntu/ lucid main restricted
deb-src http://old-releases.ubuntu.com/ubuntu/ lucid main restricted
</pre>
</div>

<p>
由于linux-2.6内核相对于现在来说很老了，最新的gcc glibc编译老的2.6内核会有各种问题，所以用老的基于linux2.6的系统最为方便<br />
</p>

<ul class="org-ul">
<li>软件包推荐<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">openssh-server</td>
<td class="org-left">ssh server</td>
</tr>

<tr>
<td class="org-left">vion</td>
<td class="org-left">VNC server，自带</td>
</tr>

<tr>
<td class="org-left">ncurses-dev</td>
<td class="org-left">make menuconfig所需</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>内核配置<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">make config</td>
<td class="org-left">遍历所有配置项</td>
</tr>

<tr>
<td class="org-left"><b>make menuconfig</b></td>
<td class="org-left">图形界面工具</td>
</tr>

<tr>
<td class="org-left">make defconfig</td>
<td class="org-left">缺省配置</td>
</tr>

<tr>
<td class="org-left">make oldconfig</td>
<td class="org-left">验证和更新配置</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>拷贝本系统配置<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-bash">zcat /proc/config.gz &gt; .config  <span style="color: #75715E;"># </span><span style="color: #E6DB74;">&#22914;&#26524;&#31995;&#32479;&#24050;&#24320;&#21551;CONFIG_IKCONFIG_PROC</span>
make oldconfig
</pre>
</div>

<ul class="org-ul">
<li>内核编译<br /></li>
</ul>
<p>
.config配置好以后, 执行make<br />
</p>

<ul class="org-ul">
<li>内核安装<br /></li>
<li>生成的arch/i386/boot/bzImage拷到/boot下<br /></li>
<li>make modules_install<br /></li>
</ul>

<p>
内核开发的特点<br />
</p>
<ul class="org-ul">
<li>无libc库或无标准头文件<br /></li>
<li>经常使用编译器扩展特性<br /></li>
</ul>
<p>
内联函数<br />
内联汇编<br />
链接脚本<br />
关于时间戳，是64位的，但是经常也用到高32位，为了防止每次都额外做一次位运算，定义两个符号，指向同一个地址，一个是32位的，一个是64位<br />
likely和unlikely<br />
</p>
<ul class="org-ul">
<li>无内存保护<br /></li>
<li>浮点<br /></li>
</ul>
<p>
以前的cpu做浮点运算都有个协处理器，这样会使CPU陷入，所以尽量不要用浮点<br />
</p>
<ul class="org-ul">
<li>内核栈大小有限，32位机默认是8KB<br /></li>
<li><b>同步和并发</b> 开了内核抢占和非抢占时锁的行为和中断发生的时为不一样，要特别注意<br /></li>
<li>可移植性，尽量做到体系无关<br /></li>
</ul>
</div>
</div>

<div id="outline-container-orgf9839d3" class="outline-2">
<h2 id="orgf9839d3"><span class="section-number-2">3</span> 第三章 进程管理</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>进程列表存放在任务队列的双向循环链表中 - task list<br /></li>
<li>task_struct指针在thread_info中，thread_info在内核栈栈底，这样获取thread_info地址简单的方法就是esp &amp; (0xFFFFFFFF &lt;&lt; 13)，task_struct就是(esp &amp; (0xFFFFFFFF &lt;&lt; 13))-&gt;task<br /></li>
</ul>

<p>
<b>像POWERPC, task_struct指针直接存在r2，相对的说原因之一就是x86的寄存器不够用</b><br />
</p>

<ul class="org-ul">
<li>默认最大PID是32768<br /></li>
<li>进程状态<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">TASK_RUNNINNG</td>
<td class="org-left">运行</td>
</tr>

<tr>
<td class="org-left">TASK_INNTERRUPTIBLE</td>
<td class="org-left">可中断，正在睡眠</td>
</tr>

<tr>
<td class="org-left">TASK_UNINTERRUPTIBLE</td>
<td class="org-left">类似可中断，但对信号不做响应</td>
</tr>

<tr>
<td class="org-left">__TASK_TRACED</td>
<td class="org-left">被其他进程跟踪</td>
</tr>

<tr>
<td class="org-left">__TASK_STOPPED</td>
<td class="org-left">进程停止执行</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>task-&gt;state是进程状态<br /></li>
<li>所有进程都是PID为1的init进程的后代， <b>而init进程的相关数据是静态写在kernel代码里的</b>, parent是父进程，childern是子进程链表，sibling是兄弟进程链表，同时所有进程在双向链表tasks中<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">volatile</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">state</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">-1 unrunnable, 0 runnable, &gt;0 stopped </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">stack</span>;
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">usage</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flags</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">per process flags, defined below </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">ptrace</span>;

    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">lock_depth</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">BKL lock depth </span><span style="color: #75715E;">*/</span>

<span style="color: #F92672;">#ifdef</span> CONFIG_SMP
<span style="color: #F92672;">#ifdef</span> __ARCH_WANT_UNLOCKED_CTXSW
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">oncpu</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#endif</span>

    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">prio</span>, <span style="color: #FD971F;">static_prio</span>, <span style="color: #FD971F;">normal_prio</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">rt_priority</span>;
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_class</span> *<span style="color: #FD971F;">sched_class</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> <span style="color: #FD971F;">se</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_rt_entity</span> <span style="color: #FD971F;">rt</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_PREEMPT_NOTIFIERS
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">list of struct preempt_notifier: </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_head</span> <span style="color: #FD971F;">preempt_notifiers</span>;
<span style="color: #F92672;">#endif</span>

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * fpu_counter contains the number of consecutive context switches</span>
<span style="color: #E6DB74;">     * that the FPU is used. If this is over a threshold, the lazy fpu</span>
<span style="color: #E6DB74;">     * saving becomes unlazy to save the trap. This is an unsigned char</span>
<span style="color: #E6DB74;">     * so that after 256 times the counter wraps and the behavior turns</span>
<span style="color: #E6DB74;">     * lazy again; this to deal with bursty apps that only use FPU for</span>
<span style="color: #E6DB74;">     * a short time</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">fpu_counter</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_BLK_DEV_IO_TRACE
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">btrace_seq</span>;
<span style="color: #F92672;">#endif</span>

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">policy</span>;
    <span style="color: #66D9EF;">cpumask_t</span> <span style="color: #FD971F;">cpus_allowed</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_TREE_PREEMPT_RCU
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">rcu_read_lock_nesting</span>;
    <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">rcu_read_unlock_special</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rcu_node</span> *<span style="color: #FD971F;">rcu_blocked_node</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">rcu_node_entry</span>;
<span style="color: #F92672;">#endif</span> <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">#ifdef CONFIG_TREE_PREEMPT_RCU </span><span style="color: #75715E;">*/</span>

<span style="color: #F92672;">#if</span> <span style="color: #F92672;">defined</span><span style="color: #66D9EF;">(</span>CONFIG_SCHEDSTATS<span style="color: #66D9EF;">)</span> || <span style="color: #F92672;">defined</span><span style="color: #66D9EF;">(</span>CONFIG_TASK_DELAY_ACCT<span style="color: #66D9EF;">)</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_info</span> <span style="color: #FD971F;">sched_info</span>;
<span style="color: #F92672;">#endif</span>

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">tasks</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">plist_node</span> <span style="color: #FD971F;">pushable_tasks</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mm_struct</span> *<span style="color: #FD971F;">mm</span>, *<span style="color: #FD971F;">active_mm</span>;
<span style="color: #F92672;">#if</span> <span style="color: #F92672;">defined</span><span style="color: #66D9EF;">(</span>SPLIT_RSS_COUNTING<span style="color: #66D9EF;">)</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_rss_stat</span>    <span style="color: #FD971F;">rss_stat</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">task state </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">exit_state</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">exit_code</span>, <span style="color: #FD971F;">exit_signal</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">pdeath_signal</span>;  <span style="color: #75715E;">/*  </span><span style="color: #E6DB74;">The signal sent when the parent dies  </span><span style="color: #75715E;">*/</span>
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">??? </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">personality</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">did_exec</span>:1;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">in_execve</span>:1;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Tell the LSMs that the process is doing an</span>
<span style="color: #E6DB74;">                 * execve </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">in_iowait</span>:1;


    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Revert to default priority/policy when forking </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">sched_reset_on_fork</span>:1;

    <span style="color: #66D9EF;">pid_t</span> <span style="color: #FD971F;">pid</span>;
    <span style="color: #66D9EF;">pid_t</span> <span style="color: #FD971F;">tgid</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_CC_STACKPROTECTOR
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Canary value for the -fstack-protector gcc feature </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">stack_canary</span>;
<span style="color: #F92672;">#endif</span>

    <span style="color: #75715E;">/* </span>
<span style="color: #E6DB74;">     * pointers to (original) parent process, youngest child, younger sibling,</span>
<span style="color: #E6DB74;">     * older sibling, respectively.  (p-&gt;father can be replaced with </span>
<span style="color: #E6DB74;">     * p-&gt;real_parent-&gt;pid)</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">real_parent</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">real parent process </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">parent</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">recipient of SIGCHLD, wait4() reports </span><span style="color: #75715E;">*/</span>
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * children/sibling forms the list of my natural children</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">children</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">list of my children </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">sibling</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">linkage in my parent's children list </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">group_leader</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">threadgroup leader </span><span style="color: #75715E;">*/</span>

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * ptraced is the list of tasks this task is using ptrace on.</span>
<span style="color: #E6DB74;">     * This includes both natural children and PTRACE_ATTACH targets.</span>
<span style="color: #E6DB74;">     * p-&gt;ptrace_entry is p's link on the p-&gt;parent-&gt;ptraced list.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">ptraced</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">ptrace_entry</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * This is the tracer handle for the ptrace BTS extension.</span>
<span style="color: #E6DB74;">     * This field actually belongs to the ptracer task.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">bts_context</span> *<span style="color: #FD971F;">bts</span>;

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">PID/PID hash table linkage. </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pid_link</span> <span style="color: #FD971F;">pids</span><span style="color: #66D9EF;">[</span>PIDTYPE_MAX<span style="color: #66D9EF;">]</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">thread_group</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">completion</span> *<span style="color: #FD971F;">vfork_done</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">for vfork() </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *set_child_tid;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">CLONE_CHILD_SETTID </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__user</span> *clear_child_tid;        <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">CLONE_CHILD_CLEARTID </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">cputime_t</span> <span style="color: #FD971F;">utime</span>, <span style="color: #FD971F;">stime</span>, <span style="color: #FD971F;">utimescaled</span>, <span style="color: #FD971F;">stimescaled</span>;
    <span style="color: #66D9EF;">cputime_t</span> <span style="color: #FD971F;">gtime</span>;
<span style="color: #F92672;">#if</span><span style="color: #F92672; font-weight: bold;">n</span><span style="color: #F92672;">def</span> CONFIG_VIRT_CPU_ACCOUNTING
    <span style="color: #66D9EF;">cputime_t</span> <span style="color: #FD971F;">prev_utime</span>, <span style="color: #FD971F;">prev_stime</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">nvcsw</span>, <span style="color: #FD971F;">nivcsw</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">context switch counts </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">timespec</span> <span style="color: #FD971F;">start_time</span>;         <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">monotonic time </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">timespec</span> <span style="color: #FD971F;">real_start_time</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">boot based time </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">min_flt</span>, <span style="color: #FD971F;">maj_flt</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_cputime</span> <span style="color: #FD971F;">cputime_expires</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">cpu_timers</span><span style="color: #66D9EF;">[</span>3<span style="color: #66D9EF;">]</span>;

<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">process credentials </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cred</span> *<span style="color: #FD971F;">real_cred</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">objective and real subjective task</span>
<span style="color: #E6DB74;">                     * credentials (COW) </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cred</span> *<span style="color: #FD971F;">cred</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">effective (overridable) subjective task</span>
<span style="color: #E6DB74;">                     * credentials (COW) </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mutex</span> <span style="color: #FD971F;">cred_guard_mutex</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">guard against foreign influences on</span>
<span style="color: #E6DB74;">                     * credential calculations</span>
<span style="color: #E6DB74;">                     * (notably. ptrace) </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cred</span> *<span style="color: #FD971F;">replacement_session_keyring</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">for KEYCTL_SESSION_TO_PARENT </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">comm</span><span style="color: #66D9EF;">[</span>TASK_COMM_LEN<span style="color: #66D9EF;">]</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">executable name excluding path</span>
<span style="color: #E6DB74;">                     - access with [gs]et_task_comm (which lock</span>
<span style="color: #E6DB74;">                       it with task_lock())</span>
<span style="color: #E6DB74;">                     - initialized normally by setup_new_exec </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">file system info </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">link_count</span>, <span style="color: #FD971F;">total_link_count</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_SYSVIPC
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">ipc stuff </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sysv_sem</span> <span style="color: #FD971F;">sysvsem</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_DETECT_HUNG_TASK
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">hung task detection </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">last_switch_count</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">CPU-specific state of this task </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">thread_struct</span> <span style="color: #FD971F;">thread</span>;
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">filesystem information </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">fs_struct</span> *<span style="color: #FD971F;">fs</span>;
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">open file information </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">files_struct</span> *<span style="color: #FD971F;">files</span>;
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">namespaces </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">nsproxy</span> *<span style="color: #FD971F;">nsproxy</span>;
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">signal handlers </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">signal_struct</span> *<span style="color: #FD971F;">signal</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sighand_struct</span> *<span style="color: #FD971F;">sighand</span>;

    <span style="color: #66D9EF;">sigset_t</span> <span style="color: #FD971F;">blocked</span>, <span style="color: #FD971F;">real_blocked</span>;
    <span style="color: #66D9EF;">sigset_t</span> <span style="color: #FD971F;">saved_sigmask</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">restored if set_restore_sigmask() was used </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sigpending</span> <span style="color: #FD971F;">pending</span>;

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">sas_ss_sp</span>;
    <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">sas_ss_size</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*notifier<span style="color: #66D9EF;">)(</span><span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">priv</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">notifier_data</span>;
    <span style="color: #66D9EF;">sigset_t</span> *<span style="color: #FD971F;">notifier_mask</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">audit_context</span> *<span style="color: #FD971F;">audit_context</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_AUDITSYSCALL
    <span style="color: #66D9EF;">uid_t</span> <span style="color: #FD971F;">loginuid</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">sessionid</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #66D9EF;">seccomp_t</span> <span style="color: #FD971F;">seccomp</span>;

<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Thread group tracking </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">parent_exec_id</span>;
    <span style="color: #66D9EF;">u32</span> <span style="color: #FD971F;">self_exec_id</span>;
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Protection of (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed,</span>
<span style="color: #E6DB74;"> * mempolicy </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">spinlock_t</span> <span style="color: #FD971F;">alloc_lock</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_GENERIC_HARDIRQS
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">IRQ handler threads </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">irqaction</span> *<span style="color: #FD971F;">irqaction</span>;
<span style="color: #F92672;">#endif</span>

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Protection of the PI data structures: </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">raw_spinlock_t</span> <span style="color: #FD971F;">pi_lock</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_RT_MUTEXES
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">PI waiters blocked on a rt_mutex held by this task </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">plist_head</span> <span style="color: #FD971F;">pi_waiters</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Deadlock detection and priority inheritance handling </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rt_mutex_waiter</span> *<span style="color: #FD971F;">pi_blocked_on</span>;
<span style="color: #F92672;">#endif</span>

<span style="color: #F92672;">#ifdef</span> CONFIG_DEBUG_MUTEXES
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">mutex deadlock detection </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mutex_waiter</span> *<span style="color: #FD971F;">blocked_on</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_TRACE_IRQFLAGS
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">irq_events</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">hardirq_enable_ip</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">hardirq_disable_ip</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">hardirq_enable_event</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">hardirq_disable_event</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">hardirqs_enabled</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">hardirq_context</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">softirq_disable_ip</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">softirq_enable_ip</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">softirq_disable_event</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">softirq_enable_event</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">softirqs_enabled</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">softirq_context</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_LOCKDEP
<span style="color: #F92672;"># define</span> <span style="color: #FD971F;">MAX_LOCK_DEPTH</span> 48UL
    <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">curr_chain_key</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">lockdep_depth</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">lockdep_recursion</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">held_lock</span> <span style="color: #FD971F;">held_locks</span><span style="color: #66D9EF;">[</span>MAX_LOCK_DEPTH<span style="color: #66D9EF;">]</span>;
    <span style="color: #66D9EF;">gfp_t</span> <span style="color: #FD971F;">lockdep_reclaim_gfp</span>;
<span style="color: #F92672;">#endif</span>

<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">journalling filesystem info </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">journal_info</span>;

<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">stacked block device info </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">bio_list</span> *<span style="color: #FD971F;">bio_list</span>;

<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">VM state </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">reclaim_state</span> *<span style="color: #FD971F;">reclaim_state</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">backing_dev_info</span> *<span style="color: #FD971F;">backing_dev_info</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">io_context</span> *<span style="color: #FD971F;">io_context</span>;

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">ptrace_message</span>;
    <span style="color: #66D9EF;">siginfo_t</span> *<span style="color: #FD971F;">last_siginfo</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">For ptrace use.  </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_io_accounting</span> <span style="color: #FD971F;">ioac</span>;
<span style="color: #F92672;">#if</span> <span style="color: #F92672;">defined</span><span style="color: #66D9EF;">(</span>CONFIG_TASK_XACCT<span style="color: #66D9EF;">)</span>
    <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">acct_rss_mem1</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">accumulated rss usage </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">acct_vm_mem1</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">accumulated virtual memory usage </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">cputime_t</span> <span style="color: #FD971F;">acct_timexpd</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">stime + utime since last update </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_CPUSETS
    <span style="color: #66D9EF;">nodemask_t</span> <span style="color: #FD971F;">mems_allowed</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Protected by alloc_lock </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cpuset_mem_spread_rotor</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_CGROUPS
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Control Group info protected by css_set_lock </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">css_set</span> *<span style="color: #FD971F;">cgroups</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">cg_list protected by css_set_lock and tsk-&gt;alloc_lock </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">cg_list</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_FUTEX
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">robust_list_head</span> <span style="color: #66D9EF;">__user</span> *<span style="color: #FD971F;">robust_list</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_COMPAT
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">compat_robust_list_head</span> <span style="color: #66D9EF;">__user</span> *<span style="color: #FD971F;">compat_robust_list</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">pi_state_list</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">futex_pi_state</span> *<span style="color: #FD971F;">pi_state_cache</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_PERF_EVENTS
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">perf_event_context</span> *<span style="color: #FD971F;">perf_event_ctxp</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mutex</span> <span style="color: #FD971F;">perf_event_mutex</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">perf_event_list</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_NUMA
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mempolicy</span> *<span style="color: #FD971F;">mempolicy</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Protected by alloc_lock </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">short</span> <span style="color: #FD971F;">il_next</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">fs_excl</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">holding fs exclusive resources </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rcu_head</span> <span style="color: #FD971F;">rcu</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * cache last used pipe for splice</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pipe_inode_info</span> *<span style="color: #FD971F;">splice_pipe</span>;
<span style="color: #F92672;">#ifdef</span>  CONFIG_TASK_DELAY_ACCT
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_delay_info</span> *<span style="color: #FD971F;">delays</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_FAULT_INJECTION
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">make_it_fail</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">prop_local_single</span> <span style="color: #FD971F;">dirties</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_LATENCYTOP
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">latency_record_count</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">latency_record</span> <span style="color: #FD971F;">latency_record</span><span style="color: #66D9EF;">[</span>LT_SAVECOUNT<span style="color: #66D9EF;">]</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * time slack values; these are used to round up poll() and</span>
<span style="color: #E6DB74;">     * select() etc timeout values. These are in nanoseconds.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">timer_slack_ns</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">default_timer_slack_ns</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    *<span style="color: #FD971F;">scm_work_list</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_FUNCTION_GRAPH_TRACER
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Index of current stored address in ret_stack </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">curr_ret_stack</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Stack of return addresses for return function tracing </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">ftrace_ret_stack</span> *<span style="color: #FD971F;">ret_stack</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">time stamp for last schedule </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">ftrace_timestamp</span>;
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * Number of functions that haven't been traced</span>
<span style="color: #E6DB74;">     * because of depth overrun.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">trace_overrun</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Pause for the tracing </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">tracing_graph_pause</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_TRACING
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">state flags for use by tracers </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">trace</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">bitmask of trace recursion </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">trace_recursion</span>;
<span style="color: #F92672;">#endif</span> <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">CONFIG_TRACING </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_CGROUP_MEM_RES_CTLR <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">memcg uses this to do batch job </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">memcg_batch_info</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">do_batch</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">incremented when batch uncharge started </span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mem_cgroup</span> *<span style="color: #FD971F;">memcg</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">target memcg of uncharge </span><span style="color: #75715E;">*/</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">bytes</span>;        <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">uncharged usage </span><span style="color: #75715E;">*/</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">memsw_bytes</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">uncharged mem+swap usage </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">}</span> <span style="color: #FD971F;">memcg_batch</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">thread_info</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span>  *<span style="color: #FD971F;">task</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">main task structure </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">exec_domain</span>  *<span style="color: #FD971F;">exec_domain</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">execution domain </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">__u32</span>           <span style="color: #FD971F;">flags</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">low level flags </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">__u32</span>           <span style="color: #FD971F;">status</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">thread synchronous flags </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">__u32</span>           <span style="color: #FD971F;">cpu</span>;        <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">current CPU </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span>         <span style="color: #FD971F;">preempt_count</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">0 =&gt; preemptable,</span>
<span style="color: #E6DB74;">                           &lt;0 =&gt; BUG </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">mm_segment_t</span>        <span style="color: #FD971F;">addr_limit</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">restart_block</span>    <span style="color: #FD971F;">restart_block</span>;
    <span style="color: #66D9EF;">void</span> <span style="color: #FD971F;">__user</span>     *sysenter_return;
<span style="color: #F92672;">#ifdef</span> CONFIG_X86_32
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>           <span style="color: #FD971F;">previous_esp</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">ESP of the previous stack in</span>
<span style="color: #E6DB74;">                           case of nested (IRQ) stacks</span>
<span style="color: #E6DB74;">                        </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">__u8</span>            <span style="color: #FD971F;">supervisor_stack</span><span style="color: #66D9EF;">[</span>0<span style="color: #66D9EF;">]</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #66D9EF;">int</span>         <span style="color: #FD971F;">uaccess_err</span>;
<span style="color: #AE81FF;">}</span>;
</pre>
</div>
<ul class="org-ul">
<li>写时拷贝,页权限设为只读，真正要写的时候再拷贝新页<br /></li>

<li>用户态fork -&gt; 用户态clone -&gt; 内核态do_fork -&gt; copy_process:<br /></li>
</ul>
<p>
dup_task_struct<br />
检查进程资源限制<br />
子进程task_struct某些信息清0<br />
子进程state = UNINTERRUPTIBLE<br />
copy_flags<br />
alloc_pid申请子进程pid<br />
资源分配<br />
</p>
<ul class="org-ul">
<li>vfork为了那些马上exec的进程使用，不推荐<br /></li>
<li>linux进程与线程的区别只在与是否共享某些资源<br /></li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">CLONE 参数标志</th>
<th scope="col" class="org-left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">CLONE_FILES</td>
<td class="org-left">共享打开的文件</td>
</tr>

<tr>
<td class="org-left">CLONE_FS</td>
<td class="org-left">共享文件系统信息</td>
</tr>

<tr>
<td class="org-left">CLONE_IDLETASK</td>
<td class="org-left">PID设为0(dedicated for init process)</td>
</tr>

<tr>
<td class="org-left">CLONE_NEWNS</td>
<td class="org-left">子进程有新的命令空间</td>
</tr>

<tr>
<td class="org-left">CLONE_PARENT</td>
<td class="org-left">子进程与父进程拥有同一个父进程</td>
</tr>

<tr>
<td class="org-left">CLONE_PTRACE</td>
<td class="org-left">调试子进程，gdb会用这个</td>
</tr>

<tr>
<td class="org-left">CLONE_SETTID</td>
<td class="org-left">将TID回写至用户空间</td>
</tr>

<tr>
<td class="org-left">CLONE_SETTLS</td>
<td class="org-left">为子进程创建新的TLS</td>
</tr>

<tr>
<td class="org-left">CLONE_SIGHAND</td>
<td class="org-left">共享信号处理函数及被阻断的信号</td>
</tr>

<tr>
<td class="org-left">CLONE_SYSVEM</td>
<td class="org-left">共享SytemV SEM_UNDO语义</td>
</tr>

<tr>
<td class="org-left">CLONE_THREAD</td>
<td class="org-left">相同的线程组</td>
</tr>

<tr>
<td class="org-left">CLONE_VFORK</td>
<td class="org-left">vfork()使用</td>
</tr>

<tr>
<td class="org-left">CLONE_UNTRACED</td>
<td class="org-left">防止被trace,主要是防止跟踪</td>
</tr>

<tr>
<td class="org-left">CLONE_STOP</td>
<td class="org-left">以TASK_STOPPED状态开始进程</td>
</tr>

<tr>
<td class="org-left">CLONE_CHILD_CLEARTID</td>
<td class="org-left">清除子进程的TID</td>
</tr>

<tr>
<td class="org-left">CLONE_CHILD_SETTID</td>
<td class="org-left">设置子进程的TID</td>
</tr>

<tr>
<td class="org-left">CLONE_PARENT_SETTID</td>
<td class="org-left">设置父进程的TID</td>
</tr>

<tr>
<td class="org-left">CLONE_VM</td>
<td class="org-left"><b>共享地址空间</b></td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>内核线程，没用用户空间的线程， mm为NULL, 相关头文件为kthread.h<br /></li>
<li>exit -&gt; do_exit，永不返回<br /></li>
</ul>
<p>
task_struct标志PF_EXITING<br />
del_timer_sync<br />
exit_sem, exit_mm, exit_files, exit_fs<br />
设置exit_code<br />
exit_notify让其父进程为其子进程重新设置父进程，同时设状态为ZOMBIE<br />
schedule，父进程通过wait帮其清理内核栈, thread_info，task_struct<br />
</p>
<ul class="org-ul">
<li>wait<br /></li>
</ul>
<p>
为退出进程的子进程找新的父进程<br />
为被退出进程trace的进程找新的父进程<br />
</p>
</div>
</div>

<div id="outline-container-org56a7278" class="outline-2">
<h2 id="org56a7278"><span class="section-number-2">4</span> 第四章 进程调度</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>preemption 内核调度程序决定进程挂起与运行<br /></li>
<li>yielding   进程本身主动挂起<br /></li>
<li>进程调度在响应时间和吞吐量之间做平衡<br /></li>
<li>传统的绝对时间片会引发的固定的切换频率问题，linux使用了公平调度<br /></li>
</ul>
<p>
se 是调度器实体<br />
vruntime 虚拟实时，系统定时器周期性调用update_curr()更新<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">load_weight</span>  <span style="color: #FD971F;">load</span>;       <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">for load-balancing </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_node</span>      <span style="color: #FD971F;">run_node</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">group_node</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">on_rq</span>;

    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">exec_start</span>;
    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">sum_exec_runtime</span>;
    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">vruntime</span>;
    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">prev_sum_exec_runtime</span>;

    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">last_wakeup</span>;
    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">avg_overlap</span>;

    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">nr_migrations</span>;

    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">start_runtime</span>;
    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">avg_wakeup</span>;
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">...</span>
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">update_curr</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">curr</span> = cfs_rq-&gt;curr;
    <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">now</span> = <span style="color: #A6E22E; font-weight: bold;">rq_of</span><span style="color: #66D9EF;">(</span>cfs_rq<span style="color: #66D9EF;">)</span>-&gt;clock;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">delta_exec</span>;

    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #A6E22E; font-weight: bold;">unlikely</span><span style="color: #A6E22E;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span>curr<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>
        <span style="color: #F92672;">return</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * Get the amount of time the current task was running</span>
<span style="color: #E6DB74;">     * since the last time we changed load (this cannot</span>
<span style="color: #E6DB74;">     * overflow on 32 bits):</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    delta_exec = <span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span><span style="color: #66D9EF;">)(</span>now - curr-&gt;exec_start<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span>delta_exec<span style="color: #66D9EF;">)</span>
        <span style="color: #F92672;">return</span>;

    <span style="color: #A6E22E; font-weight: bold;">__update_curr</span><span style="color: #66D9EF;">(</span>cfs_rq, curr, delta_exec<span style="color: #66D9EF;">)</span>;
    curr-&gt;exec_start = now;

    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #A6E22E; font-weight: bold;">entity_is_task</span><span style="color: #A6E22E;">(</span>curr<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">curtask</span> = <span style="color: #A6E22E; font-weight: bold;">task_of</span><span style="color: #A6E22E;">(</span>curr<span style="color: #A6E22E;">)</span>;

        <span style="color: #A6E22E; font-weight: bold;">trace_sched_stat_runtime</span><span style="color: #A6E22E;">(</span>curtask, delta_exec, curr-&gt;vruntime<span style="color: #A6E22E;">)</span>;
        <span style="color: #A6E22E; font-weight: bold;">cpuacct_charge</span><span style="color: #A6E22E;">(</span>curtask, delta_exec<span style="color: #A6E22E;">)</span>;
        <span style="color: #A6E22E; font-weight: bold;">account_group_exec_runtime</span><span style="color: #A6E22E;">(</span>curtask, delta_exec<span style="color: #A6E22E;">)</span>;
    <span style="color: #66D9EF;">}</span>
<span style="color: #AE81FF;">}</span>

<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span>
<span style="color: #A6E22E; font-size: 130%;">__update_curr</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #FD971F;">curr</span>,
          <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">delta_exec</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">delta_exec_weighted</span>;

    <span style="color: #A6E22E; font-weight: bold;">schedstat_set</span><span style="color: #66D9EF;">(</span>curr-&gt;exec_max, <span style="color: #A6E22E; font-weight: bold;">max</span><span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">(</span><span style="color: #66D9EF;">u64</span><span style="color: #E6DB74;">)</span>delta_exec, curr-&gt;exec_max<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;

    curr-&gt;sum_exec_runtime += delta_exec;
    <span style="color: #A6E22E; font-weight: bold;">schedstat_add</span><span style="color: #66D9EF;">(</span>cfs_rq, exec_clock, delta_exec<span style="color: #66D9EF;">)</span>;
    delta_exec_weighted = <span style="color: #A6E22E; font-weight: bold;">calc_delta_fair</span><span style="color: #66D9EF;">(</span>delta_exec, curr<span style="color: #66D9EF;">)</span>;

    curr-&gt;vruntime += delta_exec_weighted;
    <span style="color: #A6E22E; font-weight: bold;">update_min_vruntime</span><span style="color: #66D9EF;">(</span>cfs_rq<span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>

</pre>
</div>

<ul class="org-ul">
<li>进程选择<br /></li>
</ul>
<p>
红黑树<br />
enqueue_entity +进程<br />
dequeue_entity -进程<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span> *<span style="color: #A6E22E; font-size: 130%;">__pick_next_entity</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cfs_rq</span> *<span style="color: #FD971F;">cfs_rq</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_node</span> *<span style="color: #FD971F;">left</span> = cfs_rq-&gt;rb_leftmost;

    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span>left<span style="color: #66D9EF;">)</span>
        <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;

    <span style="color: #F92672;">return</span> <span style="color: #A6E22E; font-weight: bold;">rb_entry</span><span style="color: #66D9EF;">(</span>left, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sched_entity</span>, run_node<span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>


</pre>
</div>

<ul class="org-ul">
<li>调度器函数 schedule-&gt;pick_next_task，会从高优先级到低优先级调度器类中找第一个进程<br /></li>
<li>休眠<br /></li>
</ul>
<p>
从可执行红黑树中移出，放入等待队列<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #A6E22E; font-size: 130%;">DEFINE_WAIT</span><span style="color: #AE81FF;">(</span>wait<span style="color: #AE81FF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21019;&#24314;&#38431;&#21015;&#39033;</span>
<span style="color: #A6E22E; font-size: 130%;">add_wait_queue</span><span style="color: #AE81FF;">(</span>q, &amp;wait<span style="color: #AE81FF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21152;&#20837;&#31561;&#24453;&#38431;&#21015;</span>
<span style="color: #A6E22E; font-weight: bold;">while</span><span style="color: #AE81FF;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span>condition<span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#26465;&#20214;&#19981;&#28385;&#36275;</span>
    <span style="color: #A6E22E; font-weight: bold;">prepare_to_wait</span><span style="color: #66D9EF;">(</span>&amp;q, &amp;wait, TASK_INTERRUPTIBLE<span style="color: #66D9EF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#35774;&#32622;&#36827;&#31243;&#29366;&#24577;&#65292;&#22914;&#26524;&#27492;&#26102;&#24050;&#36864;&#20986;&#31561;&#24453;&#38431;&#21015;&#65292;&#37325;&#26032;&#21152;&#20837;</span>
    <span style="color: #A6E22E; font-weight: bold;">if</span><span style="color: #66D9EF;">(</span><span style="color: #A6E22E; font-weight: bold;">signal_pending</span><span style="color: #A6E22E;">(</span>current<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span> <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#22788;&#29702;&#20449;&#21495;</span>
    <span style="color: #A6E22E; font-weight: bold;">schedule</span><span style="color: #66D9EF;">()</span>;<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#35843;&#24230;</span>
<span style="color: #AE81FF;">}</span>
<span style="color: #A6E22E; font-weight: bold;">finish_wait</span><span style="color: #AE81FF;">(</span>&amp;q, &amp;wait<span style="color: #AE81FF;">)</span>;<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#32467;&#26463;&#31561;&#24453;</span>
</pre>
</div>
<ul class="org-ul">
<li>唤醒<br /></li>
</ul>
<p>
从等待队列移到红黑树<br />
</p>
<ul class="org-ul">
<li>上下文切换<br /></li>
</ul>
<p>
switch_mm 切换虚拟内存映射<br />
switch_to 切换寄存器组<br />
</p>
<ul class="org-ul">
<li>用户抢占<br /></li>
</ul>
<p>
发生在系统调用或中断处理程序返回用户空间<br />
</p>
<ul class="org-ul">
<li>内核抢占<br /></li>
</ul>
<p>
<b>非内核抢占的操作系统中，调度程序没有办法在一个内核级的任务正在执行的时候重新调度</b><br />
thread_info-&gt;preempt_count为0时，可抢占(此时是否重新调度取决于need_resched)<br />
a. 中断处理程序返回内核空间<br />
b. 内核代码再一次有抢占性<br />
c. 显示调用schedule<br />
d. 内核任务阻塞(一般是加到等待队列，同时调用schedule)<br />
</p>
<ul class="org-ul">
<li>实时调度策略<br /></li>
</ul>
<p>
在sched_rt.c中,之前的CFS在sched_fair.c(SCHED_NORMAL)中<br />
a. SCHED_FIFO, 一直执行到主动放弃或被更高优先级抢占<br />
b. SCHED_RR, 带时间片的SCHED_FIFO<br />
实时优先级为静态优先级，不像普通进程会动态计算优先级<br />
</p>
<ul class="org-ul">
<li>优先级范围<br /></li>
</ul>
<p>
nice -20~+19 相当于 实时优先级 100~139<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;"> * Priority of a process goes from 0..MAX_PRIO-1, valid RT</span>
<span style="color: #E6DB74;"> * priority is 0..MAX_RT_PRIO-1, and SCHED_NORMAL/SCHED_BATCH</span>
<span style="color: #E6DB74;"> * tasks are in the range MAX_RT_PRIO..MAX_PRIO-1. Priority</span>
<span style="color: #E6DB74;"> * values are inverted: lower p-&gt;prio value means higher priority.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * The MAX_USER_RT_PRIO value allows the actual maximum</span>
<span style="color: #E6DB74;"> * RT priority to be separate from the value exported to</span>
<span style="color: #E6DB74;"> * user-space.  This allows kernel threads to set their</span>
<span style="color: #E6DB74;"> * priority to a value higher than any user task. Note:</span>
<span style="color: #E6DB74;"> * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.</span>
<span style="color: #E6DB74;"> </span><span style="color: #75715E;">*/</span>

<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">MAX_USER_RT_PRIO</span>    100
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">MAX_RT_PRIO</span>     MAX_USER_RT_PRIO

<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">MAX_PRIO</span>        <span style="color: #AE81FF;">(</span>MAX_RT_PRIO + 40<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">DEFAULT_PRIO</span>        <span style="color: #AE81FF;">(</span>MAX_RT_PRIO + 20<span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org3dc3de9" class="outline-2">
<h2 id="org3dc3de9"><span class="section-number-2">5</span> 第五章 系统调用</h2>
<div class="outline-text-2" id="text-5">
<p>
除异常和陷入外内核唯一的合法入口<br />
<b>当进程从用户态切换至内核栈时,X86会进行栈切换(取出tss段中的esp0)</b><br />
<b>需保证系统调用是可重入的,因为进程上下文中，内核可被抢占，所以同时可能存在多个相同的系统调用</b><br />
<b>反过来说中断处理程序不能休眠</b><br />
</p>

<p>
<b>asmlinkage</b> 限制词表示用栈传数据<br />
sys_call_table 是内核的系统调用表<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #E6DB74;">entry_32.S</span>
<span style="color: #AE81FF;">syscall_call</span>:
    <span style="color: #66D9EF;">call</span> *<span style="color: #A6E22E; font-size: 130%;">sys_call_table</span><span style="color: #AE81FF;">(</span>,%eax,4<span style="color: #AE81FF;">)</span>
    movl %eax,<span style="color: #A6E22E; font-weight: bold;">PT_EAX</span><span style="color: #AE81FF;">(</span>%esp<span style="color: #AE81FF;">)</span>      # store the <span style="color: #F92672;">return</span> value

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">entry_64.S</span>
<span style="color: #A6E22E; font-weight: bold;">ENTRY</span><span style="color: #AE81FF;">(</span>system_call<span style="color: #AE81FF;">)</span>
    CFI_STARTPROC   simple
    CFI_SIGNAL_FRAME
    <span style="color: #66D9EF;">CFI_DEF_CFA</span> <span style="color: #FD971F;">rsp</span>,<span style="color: #FD971F;">KERNEL_STACK_OFFSET</span>
    CFI_REGISTER    rip,<span style="color: #FD971F;">rcx</span>
    <span style="color: #75715E;">/*</span><span style="color: #E6DB74;">CFI_REGISTER  rflags,r11</span><span style="color: #75715E;">*/</span>
    SWAPGS_UNSAFE_STACK
</pre>
</div>

<p>
内核和用户空间间做数据传输时有可能会引起阻塞（所需页在磁盘上）<br />
</p>
<ul class="org-ul">
<li>copy_from_user 从用户空间拷贝<br /></li>
<li>copy_to_user   拷贝到用户空间<br /></li>
</ul>

<p>
capable可检查是否可操作指定资源<br />
</p>
</div>

<div id="outline-container-org1fe883f" class="outline-3">
<h3 id="org1fe883f"><span class="section-number-3">5.1</span> 新增系统调用</h3>
<div class="outline-text-3" id="text-5-1">
</div>
<div id="outline-container-org05dbf15" class="outline-4">
<h4 id="org05dbf15"><span class="section-number-4">5.1.1</span> 环境</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>linux kernel<br /></li>
</ul>
<p>
a. make defconfig<br />
b. make menuconfig<br />
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #75715E;"># </span><span style="color: #E6DB74;">make menuconfig</span>
[ ] Network packet filtering framework (Netfilter)  ---&gt;
</pre>
</div>
<p>
c. make<br />
</p>
<ul class="org-ul">
<li>busybox<br /></li>
</ul>
<p>
<b>git://git.busybox.net/busybox</b><br />
e50f74da70da645c25d7daa81b2d9796a738f718 tag: 1_24_2<br />
</p>

<p>
a. make menuconfig<br />
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #75715E;"># </span><span style="color: #E6DB74;">make menuconfig</span>
[*] Don<span style="color: #E6DB74;">'t use /usr</span>
<span style="color: #E6DB74;">[*] Build BusyBox as a static binary (no shared libs)</span>
<span style="color: #E6DB74;">[ ] sync</span>
</pre>
</div>
<p>
b. make<br />
c. make install<br />
</p>
<ul class="org-ul">
<li>initramfs<br /></li>
</ul>
<p>
a. 建立目录<br />
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #75715E;">#</span><span style="color: #E6DB74;">!/bin/</span><span style="color: #F92672;">bash</span>
mkdir -pv initramfs/x86-busybox
<span style="color: #F92672;">cd</span> initramfs/x86-busybox
mkdir -pv {bin,sbin,etc,proc,sys,usr/{bin,sbin}}
cp -av /mnt/hgfs/linux-2.6-git/busybox/_install/* .
</pre>
</div>
<p>
b. 在目录下建立init<br />
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #75715E;">#</span><span style="color: #E6DB74;">!/bin/</span><span style="color: #F92672;">sh</span>
mount -t proc none /proc
mount -t sysfs none /sys
<span style="color: #F92672;">echo</span> -e <span style="color: #E6DB74;">"\nBoot took $(</span><span style="color: #AE81FF; font-weight: bold;">cut</span><span style="color: #E6DB74;"> -d' ' -f1 /proc/uptime) seconds\n"</span>
<span style="color: #F92672;">exec</span> /bin/sh
</pre>
</div>
<p>
c. 生成initramfs<br />
在目录下<br />
find . -print0 | cpio &#x2013;null -ov &#x2013;format=newc | gzip -9 &gt; x86.cpio.gz<br />
</p>
<ul class="org-ul">
<li>qemu<br /></li>
</ul>
<p>
qemu -kernel bzImage -initrd ./x86.cpio.gz -nographic -append "console=ttyS0"<br />
</p>
</div>
</div>

<div id="outline-container-org2f00859" class="outline-4">
<h4 id="org2f00859"><span class="section-number-4">5.1.2</span> sys_foo</h4>
<div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>kernel<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #75715E;">; </span><span style="color: #E6DB74;">arch/x86/kernel/syscall_table_32.S</span>
  ...
      <span style="color: #F92672;">.long</span> sys_rt_tgsigqueueinfo   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">335 */</span>
      <span style="color: #F92672;">.long</span> sys_perf_event_open
      <span style="color: #F92672;">.long</span> sys_recvmmsg
      <span style="color: #F92672;">.long</span> sys_foo               <span style="color: #75715E;">;</span><span style="color: #E6DB74;">&#26032;&#22686;338</span>
  ...
</pre>
</div>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #E6DB74;">kernel/sys.c</span>
asmlinkage <span style="color: #66D9EF;">long</span> <span style="color: #A6E22E; font-size: 130%;">sys_foo</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">void</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">return</span> 0xabcd;
<span style="color: #AE81FF;">}</span>
</pre>
</div>
<ul class="org-ul">
<li>app<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #E6DB74;">foo_app.c : gcc -static foo_app.c -o foo_app</span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#include</span> <span style="color: #AE81FF;">&lt;</span><span style="color: #E6DB74;">stdio.h</span><span style="color: #AE81FF;">&gt;</span>
<span style="color: #F92672;">#include</span> <span style="color: #AE81FF;">&lt;</span><span style="color: #E6DB74;">syscall.h</span><span style="color: #AE81FF;">&gt;</span>

<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">__NR_foo</span> 338
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">main</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">argc</span>, <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">argv</span><span style="color: #66D9EF;">[]</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #A6E22E; font-weight: bold;">printf</span><span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"new sys_call return 0x%x\n"</span>, <span style="color: #A6E22E; font-weight: bold;">syscall</span><span style="color: #A6E22E;">(</span>__NR_foo<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">return</span> 0;
<span style="color: #AE81FF;">}</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #75715E;">#</span><span style="color: #E6DB74;">&#32769;&#30340;kernel</span>
new sys_call return 0xffffffff

<span style="color: #75715E;">#</span><span style="color: #E6DB74;">&#20462;&#25913;&#36807;&#30340;kernel</span>
new sys_call return 0xabcd
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org733883b" class="outline-2">
<h2 id="org733883b"><span class="section-number-2">6</span> 第六章 内核数据结构</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org6d858c1" class="outline-3">
<h3 id="org6d858c1"><span class="section-number-3">6.1</span> 链表</h3>
<div class="outline-text-3" id="text-6-1">
<p>
linux/list.h<br />
</p>
<div class="org-src-container">
<pre class="src src-c">  <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #AE81FF;">{</span>
      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">next</span>, *<span style="color: #FD971F;">prev</span>;
  <span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">  #define</span> <span style="color: #A6E22E; font-size: 130%;">LIST_HEAD_INIT</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">name</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span> &amp;<span style="color: #66D9EF;">(</span>name<span style="color: #66D9EF;">)</span>, &amp;<span style="color: #66D9EF;">(</span>name<span style="color: #66D9EF;">)</span> <span style="color: #AE81FF;">}</span> <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#38745;&#24577;&#22768;&#26126;</span>
<span style="color: #F92672;">  #define</span> <span style="color: #A6E22E; font-size: 130%;">LIST_HEAD</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">name</span><span style="color: #AE81FF;">)</span> \
      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">name</span> = <span style="color: #A6E22E; font-weight: bold;">LIST_HEAD_INIT</span><span style="color: #AE81FF;">(</span>name<span style="color: #AE81FF;">)</span>

  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">INIT_LIST_HEAD</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">list</span><span style="color: #AE81FF;">)</span> <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21160;&#24577;</span>
  <span style="color: #AE81FF;">{</span>
      list-&gt;next = list;
      list-&gt;prev = list;
  <span style="color: #AE81FF;">}</span>

  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">__list_add</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">new</span>,
                    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">prev</span>,
                    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">next</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      next-&gt;prev = new;
      new-&gt;next = next;
      new-&gt;prev = prev;
      prev-&gt;next = new;
  <span style="color: #AE81FF;">}</span>

  <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21152;&#20803;&#32032;&#65292;&#22312;head&#21518;&#38754;</span>
  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">list_add</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">new</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #A6E22E; font-weight: bold;">__list_add</span><span style="color: #66D9EF;">(</span>new, head, head-&gt;next<span style="color: #66D9EF;">)</span>;
  <span style="color: #AE81FF;">}</span>

  <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21152;&#20803;&#32032;&#65292;&#22312;&#38142;&#34920;&#23614;</span>
  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">list_add_tail</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">new</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #A6E22E; font-weight: bold;">__list_add</span><span style="color: #66D9EF;">(</span>new, head-&gt;prev, head<span style="color: #66D9EF;">)</span>;
  <span style="color: #AE81FF;">}</span>

  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">__list_del</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> * <span style="color: #FD971F;">prev</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> * <span style="color: #FD971F;">next</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      next-&gt;prev = prev;
      prev-&gt;next = next; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#20114;&#30456;&#25346;&#25509;</span>
  <span style="color: #AE81FF;">}</span>

  <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21024;&#38500;&#20803;&#32032;</span>
  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">list_del</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">entry</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #A6E22E; font-weight: bold;">__list_del</span><span style="color: #66D9EF;">(</span>entry-&gt;prev, entry-&gt;next<span style="color: #66D9EF;">)</span>;
      entry-&gt;next = LIST_POISON1;
      entry-&gt;prev = LIST_POISON2;
  <span style="color: #AE81FF;">}</span>


  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">list_move</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">list</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #A6E22E; font-weight: bold;">__list_del</span><span style="color: #66D9EF;">(</span>list-&gt;prev, list-&gt;next<span style="color: #66D9EF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">list&#20174;&#24403;&#21069;&#38142;&#34920;&#36864;&#20986;</span>
      <span style="color: #A6E22E; font-weight: bold;">list_add</span><span style="color: #66D9EF;">(</span>list, head<span style="color: #66D9EF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21152;&#21040;head&#21518;</span>
  <span style="color: #AE81FF;">}</span>

  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">list_move_tail</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">list</span>,
                    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #A6E22E; font-weight: bold;">__list_del</span><span style="color: #66D9EF;">(</span>list-&gt;prev, list-&gt;next<span style="color: #66D9EF;">)</span>;
      <span style="color: #A6E22E; font-weight: bold;">list_add_tail</span><span style="color: #66D9EF;">(</span>list, head<span style="color: #66D9EF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21152;&#21040;head-&gt;prev&#21518;</span>
  <span style="color: #AE81FF;">}</span>


  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">&lt;= head &lt;=&gt; head1 &lt;=&gt; head2 &lt;=&gt; .... head_end =&gt; </span><span style="color: #75715E;">*/</span>
  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">&lt;= list &lt;=&gt; list1 &lt;=&gt; list2 &lt;=&gt; .... list_end =&gt; </span><span style="color: #75715E;">*/</span>

  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">&lt;= head &lt;=&gt; list1 &lt;=&gt; list2 &lt;=&gt; .... list_end &lt;=&gt; head1 &lt;=&gt; head2 ... head_end =&gt; </span><span style="color: #75715E;">*/</span>
  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">__list_splice</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">list</span>,
                   <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">prev</span>,
                   <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">next</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">first</span> = list-&gt;next;
      <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">last</span> = list-&gt;prev;

      first-&gt;prev = prev;
      prev-&gt;next = first;         <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">head &lt;=&gt; list-&gt;next </span><span style="color: #75715E;">*/</span>

      last-&gt;next = next;          <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">head-&gt;next &lt;=&gt; list-&gt;prev</span><span style="color: #75715E;">*/</span>
      next-&gt;prev = last;
  <span style="color: #AE81FF;">}</span>

  <span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">list_splice</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">list</span>,
                  <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> *<span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span>
  <span style="color: #AE81FF;">{</span>
      <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span><span style="color: #A6E22E; font-weight: bold;">list_empty</span><span style="color: #A6E22E;">(</span>list<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>
          <span style="color: #A6E22E; font-weight: bold;">__list_splice</span><span style="color: #66D9EF;">(</span>list, head, head-&gt;next<span style="color: #66D9EF;">)</span>;
  <span style="color: #AE81FF;">}</span>

<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * list_for_each    -   iterate over a list</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@pos</span><span style="color: #E6DB74;">:    the &amp;struct list_head to use as a loop cursor.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@head</span><span style="color: #E6DB74;">:   the head for your list.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#36941;&#21382;</span>
<span style="color: #F92672;"> #define</span> <span style="color: #A6E22E; font-size: 130%;">list_for_each</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">pos</span>, <span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span> \
    <span style="color: #A6E22E; font-weight: bold;">for</span> <span style="color: #AE81FF;">(</span>pos = <span style="color: #66D9EF;">(</span>head<span style="color: #66D9EF;">)</span>-&gt;next; <span style="color: #A6E22E; font-weight: bold;">prefetch</span><span style="color: #66D9EF;">(</span>pos-&gt;next<span style="color: #66D9EF;">)</span>, pos != <span style="color: #66D9EF;">(</span>head<span style="color: #66D9EF;">)</span>; \
            pos = pos-&gt;next<span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * list_entry - get the struct for this entry</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@ptr</span><span style="color: #E6DB74;">:    the &amp;struct list_head pointer.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@type</span><span style="color: #E6DB74;">:   the type of the struct this is embedded in.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@member</span><span style="color: #E6DB74;">: the name of the list_struct within the struct.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #F92672;"> #define</span> <span style="color: #A6E22E; font-size: 130%;">list_entry</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">ptr</span>, <span style="color: #FD971F;">type</span>, <span style="color: #FD971F;">member</span><span style="color: #AE81FF;">)</span> \
    <span style="color: #A6E22E; font-weight: bold;">container_of</span><span style="color: #AE81FF;">(</span>ptr, type, member<span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * list_for_each_entry  -   iterate over list of given type</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@pos</span><span style="color: #E6DB74;">:    the type * to use as a loop cursor.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@head</span><span style="color: #E6DB74;">:   the head for your list.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@member</span><span style="color: #E6DB74;">: the name of the list_struct within the struct.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #F92672;"> #define</span> <span style="color: #A6E22E; font-size: 130%;">list_for_each_entry</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">pos</span>, <span style="color: #FD971F;">head</span>, <span style="color: #FD971F;">member</span><span style="color: #AE81FF;">)</span>             \
    <span style="color: #A6E22E; font-weight: bold;">for</span> <span style="color: #AE81FF;">(</span>pos = <span style="color: #A6E22E; font-weight: bold;">list_entry</span><span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>head<span style="color: #A6E22E;">)</span>-&gt;next, <span style="color: #A6E22E; font-weight: bold;">typeof</span><span style="color: #A6E22E;">(</span>*pos<span style="color: #A6E22E;">)</span>, member<span style="color: #66D9EF;">)</span>;  \
         <span style="color: #A6E22E; font-weight: bold;">prefetch</span><span style="color: #66D9EF;">(</span>pos-&gt;member.next<span style="color: #66D9EF;">)</span>, &amp;pos-&gt;member != <span style="color: #66D9EF;">(</span>head<span style="color: #66D9EF;">)</span>;    \
         pos = <span style="color: #A6E22E; font-weight: bold;">list_entry</span><span style="color: #66D9EF;">(</span>pos-&gt;member.next, <span style="color: #A6E22E; font-weight: bold;">typeof</span><span style="color: #A6E22E;">(</span>*pos<span style="color: #A6E22E;">)</span>, member<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * list_for_each_safe - iterate over a list safe against removal of list entry</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@pos</span><span style="color: #E6DB74;">:    the &amp;struct list_head to use as a loop cursor.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@n</span><span style="color: #E6DB74;">:      another &amp;struct list_head to use as temporary storage</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@head</span><span style="color: #E6DB74;">:   the head for your list.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#23433;&#20840;&#36941;&#21382;&#65292;&#29992;&#20110;&#22312;foreach&#20013;&#21024;&#38500;&#20803;&#32032;</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">list_for_each_safe</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">pos</span>, <span style="color: #FD971F;">n</span>, <span style="color: #FD971F;">head</span><span style="color: #AE81FF;">)</span> \
    <span style="color: #A6E22E; font-weight: bold;">for</span> <span style="color: #AE81FF;">(</span>pos = <span style="color: #66D9EF;">(</span>head<span style="color: #66D9EF;">)</span>-&gt;next, n = pos-&gt;next; pos != <span style="color: #66D9EF;">(</span>head<span style="color: #66D9EF;">)</span>; \
        pos = n, n = pos-&gt;next<span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org615b994" class="outline-3">
<h3 id="org615b994"><span class="section-number-3">6.2</span> 数据队列</h3>
<div class="outline-text-3" id="text-6-2">
<p>
linux/kfifo.h<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">__kfifo_initializer</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">s</span>, <span style="color: #FD971F;">b</span><span style="color: #AE81FF;">)</span> \
    <span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span> \
        .size   = s, \
        .in = 0, \
        .out    = 0, \
        .buffer = b \
    <span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#32852;&#21512;&#20307;&#65292;&#22836;&#20026;kfifo&#32467;&#26500;&#65292;&#21518;&#38754;&#20026;buffer size</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">DECLARE_KFIFO</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">name</span>, <span style="color: #FD971F;">size</span><span style="color: #AE81FF;">)</span> \
<span style="color: #F92672;">union</span> <span style="color: #AE81FF;">{</span> \
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span> <span style="color: #FD971F;">name</span>; \
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">name</span>##kfifo_buffer<span style="color: #66D9EF;">[</span>size + <span style="color: #A6E22E; font-weight: bold;">sizeof</span><span style="color: #A6E22E;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">]</span>; \
<span style="color: #AE81FF;">}</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * INIT_KFIFO - Initialize a kfifo declared by DECLARE_KFIFO</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@name</span><span style="color: #E6DB74;">: name of the declared kfifo datatype</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">INIT_KFIFO</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">name</span><span style="color: #AE81FF;">)</span> \
    name = <span style="color: #A6E22E; font-weight: bold;">__kfifo_initializer</span><span style="color: #AE81FF;">(</span><span style="color: #A6E22E; font-weight: bold;">sizeof</span><span style="color: #66D9EF;">(</span>name##kfifo_buffer<span style="color: #66D9EF;">)</span> - \
                <span style="color: #A6E22E; font-weight: bold;">sizeof</span><span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span><span style="color: #66D9EF;">)</span>, \
                name##kfifo_buffer + <span style="color: #A6E22E; font-weight: bold;">sizeof</span><span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#20998;&#31163;&#30340;&#32467;&#26500;&#65292;&#19968;&#20010;&#26159;kfifo&#65292;&#25346;&#25509;buffer</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">DEFINE_KFIFO</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">name</span>, <span style="color: #FD971F;">size</span><span style="color: #AE81FF;">)</span> \
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">name</span>##kfifo_buffer<span style="color: #AE81FF;">[</span>size<span style="color: #AE81FF;">]</span>; \
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span> <span style="color: #FD971F;">name</span> = <span style="color: #A6E22E; font-weight: bold;">__kfifo_initializer</span><span style="color: #AE81FF;">(</span>size, name##kfifo_buffer<span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * kfifo_alloc - allocates a new FIFO internal buffer</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@fifo</span><span style="color: #E6DB74;">: the fifo to assign then new buffer</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@size</span><span style="color: #E6DB74;">: the size of the buffer to be allocated, this have to be a power of 2.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@gfp_mask</span><span style="color: #E6DB74;">: get_free_pages mask, passed to </span><span style="color: #AE81FF;">kmalloc()</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This function dynamically allocates a new fifo internal buffer</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * The size will be rounded-up to a power of 2.</span>
<span style="color: #E6DB74;"> * The buffer will be release with </span><span style="color: #AE81FF;">kfifo_free()</span><span style="color: #E6DB74;">.</span>
<span style="color: #E6DB74;"> * Return 0 if no error, otherwise the an error code</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#30003;&#35831;</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">kfifo_alloc</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span> *<span style="color: #FD971F;">fifo</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">size</span>, <span style="color: #66D9EF;">gfp_t</span> <span style="color: #FD971F;">gfp_mask</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#25512;&#20837;</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * kfifo_in - puts some data into the FIFO</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@fifo</span><span style="color: #E6DB74;">: the fifo to be used.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@from</span><span style="color: #E6DB74;">: the data to be added.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@len</span><span style="color: #E6DB74;">: the length of the data to be added.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This function copies at most </span><span style="color: #AE81FF;">@len</span><span style="color: #E6DB74;"> bytes from the </span><span style="color: #AE81FF;">@from</span><span style="color: #E6DB74;"> buffer into</span>
<span style="color: #E6DB74;"> * the FIFO depending on the free space, and returns the number of</span>
<span style="color: #E6DB74;"> * bytes copied.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * Note that with only one concurrent reader and one concurrent</span>
<span style="color: #E6DB74;"> * writer, you don't need extra locking to use these functions.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">kfifo_in</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span> *<span style="color: #FD971F;">fifo</span>, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">from</span>,
                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span><span style="color: #AE81FF;">)</span>


<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21462;&#20986;</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * kfifo_out - gets some data from the FIFO</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@fifo</span><span style="color: #E6DB74;">: the fifo to be used.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@to</span><span style="color: #E6DB74;">: where the data must be copied.</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@len</span><span style="color: #E6DB74;">: the size of the destination buffer.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This function copies at most </span><span style="color: #AE81FF;">@len</span><span style="color: #E6DB74;"> bytes from the FIFO into the</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@to</span><span style="color: #E6DB74;"> buffer and returns the number of copied bytes.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * Note that with only one concurrent reader and one concurrent</span>
<span style="color: #E6DB74;"> * writer, you don't need extra locking to use these functions.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">kfifo_out</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kfifo</span> *<span style="color: #FD971F;">fifo</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">to</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span><span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd4b74fb" class="outline-3">
<h3 id="orgd4b74fb"><span class="section-number-3">6.3</span> 映射</h3>
<div class="outline-text-3" id="text-6-3">
<p>
linux/idr.h<br />
不像python里的dict,key就是UID，是自动生成的<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21021;&#22987;&#21270;</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * idr_init - initialize idr handle</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@idp</span><span style="color: #E6DB74;">:    idr handle</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This function is use to set up the handle (</span><span style="color: #AE81FF;">@idp</span><span style="color: #E6DB74;">) that you will pass</span>
<span style="color: #E6DB74;"> * to the rest of the functions.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">idr_init</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">idr</span> *<span style="color: #FD971F;">idp</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#39044;&#20998;&#37197;UID</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * idr_pre_get - reserver resources for idr allocation</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@idp</span><span style="color: #E6DB74;">:    idr handle</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@gfp_mask</span><span style="color: #E6DB74;">:   memory allocation flags</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This function should be called prior to locking and calling the</span>
<span style="color: #E6DB74;"> * idr_get_new* functions. It preallocates enough memory to satisfy</span>
<span style="color: #E6DB74;"> * the worst possible allocation.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * If the system is REALLY out of memory this function returns 0,</span>
<span style="color: #E6DB74;"> * otherwise 1.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">idr_pre_get</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">idr</span> *<span style="color: #FD971F;">idp</span>, <span style="color: #66D9EF;">gfp_t</span> <span style="color: #FD971F;">gfp_mask</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#26144;&#23556;</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * idr_get_new - allocate new idr entry</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@idp</span><span style="color: #E6DB74;">: idr handle</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@ptr</span><span style="color: #E6DB74;">: pointer you want associated with the id</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@id</span><span style="color: #E6DB74;">: pointer to the allocated handle</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This is the allocate id function.  It should be called with any</span>
<span style="color: #E6DB74;"> * required locks.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * If memory is required, it will return -EAGAIN, you should unlock</span>
<span style="color: #E6DB74;"> * and go back to the </span><span style="color: #AE81FF;">idr_pre_get()</span><span style="color: #E6DB74;"> call.  If the idr is full, it will</span>
<span style="color: #E6DB74;"> * return -ENOSPC.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@id</span><span style="color: #E6DB74;"> returns a value in the range 0 ... 0x7fffffff</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">idr_get_new</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">idr</span> *<span style="color: #FD971F;">idp</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">ptr</span>, <span style="color: #66D9EF;">int</span> *<span style="color: #FD971F;">id</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#26681;&#25454;UID&#21462;ptr</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * idr_find - return pointer for given id</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@idp</span><span style="color: #E6DB74;">: idr handle</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@id</span><span style="color: #E6DB74;">: lookup key</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * Return the pointer given the id it has been registered with.  A </span><span style="color: #AE81FF;">%NULL</span>
<span style="color: #E6DB74;"> * return indicates that </span><span style="color: #AE81FF;">@id</span><span style="color: #E6DB74;"> is not valid or you passed </span><span style="color: #AE81FF;">%NULL</span><span style="color: #E6DB74;"> in</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">idr_get_new()</span><span style="color: #E6DB74;">.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * This function can be called under </span><span style="color: #AE81FF;">rcu_read_lock()</span><span style="color: #E6DB74;">, given that the leaf</span>
<span style="color: #E6DB74;"> * pointers lifetimes are correctly managed.</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">void</span> *<span style="color: #A6E22E; font-size: 130%;">idr_find</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">idr</span> *<span style="color: #FD971F;">idp</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">id</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21024;&#38500;UID</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * idr_remove - remove the given id and free it's slot</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@idp</span><span style="color: #E6DB74;">: idr handle</span>
<span style="color: #E6DB74;"> * </span><span style="color: #AE81FF;">@id</span><span style="color: #E6DB74;">: unique key</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">idr_remove</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">idr</span> *<span style="color: #FD971F;">idp</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">id</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21024;&#38500;idr</span>
<span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * idr_destroy - release all cached layers within an idr tree</span>
<span style="color: #E6DB74;"> * idp: idr handle</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">idr_destroy</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">idr</span> *<span style="color: #FD971F;">idp</span><span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb32c7dd" class="outline-3">
<h3 id="orgb32c7dd"><span class="section-number-3">6.4</span> 红黑树</h3>
<div class="outline-text-3" id="text-6-4">
<p>
linux/rbtree.h<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21021;&#22987;&#21270;</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_root</span> <span style="color: #FD971F;">root</span> = RB_ROOT;

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#32418;&#40657;&#26641;&#27809;&#26377;&#25554;&#20837;&#21644;&#26597;&#25214;&#25509;&#21475;&#65292;&#38656;&#33258;&#24050;&#23454;&#29616;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> * <span style="color: #A6E22E; font-size: 130%;">rb_search_page_cache</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> * <span style="color: #FD971F;">inode</span>,
                         <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">offset</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_node</span> * <span style="color: #FD971F;">n</span> = inode-&gt;i_rb_page_cache.rb_node;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> * <span style="color: #FD971F;">page</span>;

    <span style="color: #A6E22E; font-weight: bold;">while</span> <span style="color: #66D9EF;">(</span>n<span style="color: #66D9EF;">)</span>
    <span style="color: #66D9EF;">{</span>
        page = <span style="color: #A6E22E; font-weight: bold;">rb_entry</span><span style="color: #A6E22E;">(</span>n, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span>, rb_page_cache<span style="color: #A6E22E;">)</span>;

        <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #A6E22E;">(</span>offset &lt; page-&gt;offset<span style="color: #A6E22E;">)</span>
            n = n-&gt;rb_left;
        <span style="color: #F92672;">else</span> <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #A6E22E;">(</span>offset &gt; page-&gt;offset<span style="color: #A6E22E;">)</span>
            n = n-&gt;rb_right;
        <span style="color: #F92672;">else</span>
            <span style="color: #F92672;">return</span> page;
    <span style="color: #66D9EF;">}</span>
    <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">NULL</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> * <span style="color: #A6E22E; font-size: 130%;">rb_insert_page_cache</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> * <span style="color: #FD971F;">inode</span>,
                         <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">offset</span>,
                         <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_node</span> * <span style="color: #FD971F;">node</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> * <span style="color: #FD971F;">ret</span>;
    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>ret = <span style="color: #A6E22E; font-weight: bold;">__rb_insert_page_cache</span><span style="color: #E6DB74;">(</span>inode, offset, node<span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">out</span>;
    <span style="color: #A6E22E; font-weight: bold;">rb_insert_color</span><span style="color: #66D9EF;">(</span>node, &amp;inode-&gt;i_rb_page_cache<span style="color: #66D9EF;">)</span>;
 <span style="color: #AE81FF;">out</span>:
    <span style="color: #F92672;">return</span> ret;
<span style="color: #AE81FF;">}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4ef9fe1" class="outline-2">
<h2 id="org4ef9fe1"><span class="section-number-2">7</span> 第七章 中断和中断处理</h2>
<div class="outline-text-2" id="text-7">
<p>
中断可能随时发生，中断上下文不可阻塞<br />
</p>

<p>
上半部 - 处理有严格时限的工作<br />
下半部 - 处理大量逻辑的工作<br />
</p>

<p>
request_irq里会调用kmalloc，有时会导致睡眠<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #E6DB74;">irq     &#20013;&#26029;&#21495; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">handler &#20013;&#26029;&#22788;&#29702;&#31243;&#24207; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">flags   &#20013;&#26029;&#22788;&#29702;&#26631;&#24535; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">- IRQF_DISABLE       &#20013;&#26029;&#22788;&#29702;&#31243;&#24207;&#26102;&#31105;&#27490;&#25152;&#26377;&#20013;&#26029; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">- IRQF_SAMPLE_RANDOM &#38543;&#26426;&#29109;&#28304; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">- IRQF_TIMER         &#19987;&#20026;&#31995;&#32479;&#23450;&#26102;&#22120;&#30340;&#20013;&#26029;&#22788;&#29702; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">- IRQF_SHARED        &#20849;&#20139;&#20013;&#26029;&#32447; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">name    ASCII&#25991;&#26412; </span><span style="color: #75715E;">*/</span>
<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">dev     &#20849;&#20139;&#20013;&#26029;&#26102;&#30340;priv&#25351;&#38024; </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">typedef</span> <span style="color: #66D9EF;">irqreturn_t</span> <span style="color: #AE81FF;">(</span>*<span style="color: #66D9EF;">irq_handler_t</span><span style="color: #AE81FF;">)(</span><span style="color: #66D9EF;">int</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #AE81FF;">)</span>;
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">__must_check</span>
<span style="color: #A6E22E; font-weight: bold;">request_irq</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">irq</span>, <span style="color: #66D9EF;">irq_handler_t</span> <span style="color: #FD971F;">handler</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span>,
        <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">name</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">dev</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">return</span> <span style="color: #A6E22E; font-weight: bold;">request_threaded_irq</span><span style="color: #66D9EF;">(</span>irq, handler, <span style="color: #AE81FF;">NULL</span>, flags, name, dev<span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #F92672;">extern</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">free_irq</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
<b>linux的中断处理程序无须重入，当一个中断执行时，相应的中断号会在所有处理器上被屏蔽，同一个中断处理程充绝不会同时被调用以处理嵌套中断</b><br />
</p>

<p>
共享中断要求<br />
</p>
<ol class="org-ol">
<li>IRQF_SHARED<br /></li>
<li>dev参数唯一<br /></li>
<li>必须区分是自已的设备产生了中断，而不是共享了这个中断号的其他设备<br /></li>
</ol>

<p>
中断上下文和进程无关，所以不可以睡眠，同时有严格的时间限制<br />
</p>

<p>
中断流程<br />
硬件产生一个中断 -&gt; 中断控制器 -&gt; 处理器 -&gt; 处理器中断内核 -&gt; do_IRQ() -&gt; handle_IRQ_event() 可能在此开启其他中断 -&gt; 运行挂接的所有中断处理程序 -&gt; 关中断 -&gt; ret_from_intr()<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;"> * do_IRQ handles all normal device IRQ's (the special</span>
<span style="color: #E6DB74;"> * SMP cross-CPU interrupts have their own specific</span>
<span style="color: #E6DB74;"> * handlers).</span>
<span style="color: #E6DB74;"> </span><span style="color: #75715E;">*/</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">__irq_entry</span> <span style="color: #A6E22E; font-weight: bold;">do_IRQ</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pt_regs</span> *<span style="color: #FD971F;">regs</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pt_regs</span> *<span style="color: #FD971F;">old_regs</span> = <span style="color: #A6E22E; font-weight: bold;">set_irq_regs</span><span style="color: #66D9EF;">(</span>regs<span style="color: #66D9EF;">)</span>;

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">high bit used in ret_from_ code  </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">vector</span> = ~regs-&gt;orig_ax;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #FD971F;">irq</span>;

    <span style="color: #A6E22E; font-weight: bold;">exit_idle</span><span style="color: #66D9EF;">()</span>;
    <span style="color: #A6E22E; font-weight: bold;">irq_enter</span><span style="color: #66D9EF;">()</span>;

    irq = <span style="color: #A6E22E; font-weight: bold;">__get_cpu_var</span><span style="color: #66D9EF;">(</span>vector_irq<span style="color: #66D9EF;">)[</span>vector<span style="color: #66D9EF;">]</span>;

    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span><span style="color: #A6E22E; font-weight: bold;">handle_irq</span><span style="color: #A6E22E;">(</span>irq, regs<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #A6E22E; font-weight: bold;">ack_APIC_irq</span><span style="color: #A6E22E;">()</span>;

        <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #A6E22E;">(</span><span style="color: #A6E22E; font-weight: bold;">printk_ratelimit</span><span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span>
            <span style="color: #A6E22E; font-weight: bold;">pr_emerg</span><span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"%s: %d.%d No irq handler for vector (irq %d)\n"</span>,
                __func__, <span style="color: #A6E22E; font-weight: bold;">smp_processor_id</span><span style="color: #E6DB74;">()</span>, vector, irq<span style="color: #A6E22E;">)</span>;
    <span style="color: #66D9EF;">}</span>

    <span style="color: #A6E22E; font-weight: bold;">irq_exit</span><span style="color: #66D9EF;">()</span>;

    <span style="color: #A6E22E; font-weight: bold;">set_irq_regs</span><span style="color: #66D9EF;">(</span>old_regs<span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">return</span> 1;
<span style="color: #AE81FF;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #A6E22E; font-size: 130%;">ret_from_intr</span>:
    <span style="color: #F92672;">GET_THREAD_INFO</span>(<span style="color: #FD971F;">%ebp</span>)
<span style="color: #A6E22E; font-size: 130%;">check_userspace</span>:
    <span style="color: #F92672;">movl</span> PT_EFLAGS(<span style="color: #FD971F;">%esp</span>), <span style="color: #FD971F;">%eax</span>  # mix EFLAGS and CS
    <span style="color: #F92672;">movb</span> PT_CS(<span style="color: #FD971F;">%esp</span>), <span style="color: #FD971F;">%al</span> <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#26816;&#26597;&#26632;&#20013;&#30340;cs&#65292;&#26159;&#21542;&#26159;&#29992;&#25143;&#26435;&#38480;&#26469;&#21028;&#26029;&#26159;&#21542;&#20174;&#29992;&#25143;&#24577;&#20013;&#26029;</span>
    <span style="color: #F92672;">andl</span> $(X86_EFLAGS_VM | SEGMENT_RPL_MASK), <span style="color: #FD971F;">%eax</span>
    <span style="color: #F92672;">cmpl</span> $USER_RPL, <span style="color: #FD971F;">%eax</span>
    <span style="color: #F92672;">jb</span> resume_kernel        # not returning to v8086 or userspace

<span style="color: #A6E22E; font-size: 130%;">ENTRY</span>(resume_userspace)
    <span style="color: #F92672;">LOCKDEP_SYS_EXIT</span>
    <span style="color: #F92672;">DISABLE_INTERRUPTS</span>(CLBR_ANY)    # make sure we don't miss an interrupt
                    # setting need_resched or sigpending
                    # between sampling and the iret
    <span style="color: #F92672;">TRACE_IRQS_OFF</span>
    <span style="color: #F92672;">movl</span> TI_flags(<span style="color: #FD971F;">%ebp</span>), <span style="color: #FD971F;">%ecx</span>
    <span style="color: #F92672;">andl</span> $_TIF_WORK_MASK, <span style="color: #FD971F;">%ecx</span>  # is there any work to be done on
                    # int/exception return?
    <span style="color: #F92672;">jne</span> work_pending
    <span style="color: #F92672;">jmp</span> restore_all
</pre>
</div>

<p>
如下，第一列中断号，第二列是中断计数，第三列是中断控制器，第四列是中断名<br />
</p>
<div class="org-src-container">
<pre class="src src-bash">        CPU0       
 0:        268   IO-APIC-edge      timer
 1:       3261   IO-APIC-edge      i8042
 4:      31532   IO-APIC-edge    
 8:          1   IO-APIC-edge      rtc0
 9:          0   IO-APIC-fasteoi   acpi
12:       6289   IO-APIC-edge      i8042
14:          0   IO-APIC-edge      ata_piix
15:          0   IO-APIC-edge      ata_piix
16:     229317   IO-APIC-fasteoi   eth1
17:      52749   IO-APIC-fasteoi   ioc0, Ensoniq AudioPCI
18:        228   IO-APIC-fasteoi   ehci_hcd:usb1, uhci_hcd:usb2
</pre>
</div>

<p>
中断控制<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">说明</th>
<th scope="col" class="org-left">可否嵌套</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">local_irq_disable</td>
<td class="org-left">禁止本地中断</td>
<td class="org-left">否</td>
</tr>

<tr>
<td class="org-left">local_irq_enable</td>
<td class="org-left">使能本地中断</td>
<td class="org-left">否</td>
</tr>

<tr>
<td class="org-left">local_irq_save</td>
<td class="org-left">保存本地中断状态，禁止本地中断</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">local_irq_restore</td>
<td class="org-left">恢复之前的中断状态</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">disable_irq</td>
<td class="org-left">等待所有处理程序完毕，才关指点定中断线</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">disable_irq_nosync</td>
<td class="org-left">不等，直接关</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">enable_irq</td>
<td class="org-left">使能指定中断线</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">synchronize_irq</td>
<td class="org-left">等待直到中断处理程序退出</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">irqs_disabled</td>
<td class="org-left">本地中断是否关闭</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">in_interrupt</td>
<td class="org-left">中断上下文为0(包括下半部，判断软件标记位)，进程上下文为1</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">in_irq</td>
<td class="org-left">正在执行中断处理程为1</td>
<td class="org-left">N/A</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgae86db9" class="outline-2">
<h2 id="orgae86db9"><span class="section-number-2">8</span> 第八章 下半部和推后执行的工作</h2>
<div class="outline-text-2" id="text-8">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Policy</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">上半部</td>
<td class="org-left">对时间非常敏感</td>
</tr>

<tr>
<td class="org-left">上半部</td>
<td class="org-left">和硬件相关</td>
</tr>

<tr>
<td class="org-left">上半部</td>
<td class="org-left">保证不被其他中断</td>
</tr>

<tr>
<td class="org-left">下半部</td>
<td class="org-left">除开上面</td>
</tr>
</tbody>
</table>

<p>
下半部机制: 软中断、tasklets、工作队列<br />
</p>

<ul class="org-ul">
<li>软中断 kernel/softirq.c<br /></li>
</ul>
<p>
编译时静态分配<br />
</p>

<p>
<b>注意，因为看pending的标志是32位的，所以最多有32个软中断</b><br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">enum</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #FD971F;">HI_SOFTIRQ</span>=0,
    <span style="color: #FD971F;">TIMER_SOFTIRQ</span>,
    <span style="color: #FD971F;">NET_TX_SOFTIRQ</span>,
    <span style="color: #FD971F;">NET_RX_SOFTIRQ</span>,
    <span style="color: #FD971F;">BLOCK_SOFTIRQ</span>,
    <span style="color: #FD971F;">BLOCK_IOPOLL_SOFTIRQ</span>,
    <span style="color: #FD971F;">TASKLET_SOFTIRQ</span>,
    <span style="color: #FD971F;">SCHED_SOFTIRQ</span>,
    <span style="color: #FD971F;">HRTIMER_SOFTIRQ</span>,
    <span style="color: #FD971F;">RCU_SOFTIRQ</span>,    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Preferable RCU should always be the last softirq </span><span style="color: #75715E;">*/</span>

    <span style="color: #FD971F;">NR_SOFTIRQS</span>
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">softirq_action</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #A6E22E; font-weight: bold;">void</span>    <span style="color: #66D9EF;">(</span>*action<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">softirq_action</span> *<span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">static</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">softirq_action</span> <span style="color: #FD971F;">softirq_vec</span><span style="color: #AE81FF;">[</span>NR_SOFTIRQS<span style="color: #AE81FF;">]</span> __cacheline_aligned_in_smp;

</pre>
</div>

<p>
<b>一个软中断不会抢占另外一个软中断，唯一可抢占软中断的是中断处理程序</b><br />
</p>

<p>
软中断何时被运行:<br />
</p>
<ol class="org-ol">
<li>硬件中断代码返回时<br /></li>
<li>ksoftirq内核线程中<br /></li>
<li>显示检查和执行待处理的软中断的代码中<br /></li>
</ol>

<div class="org-src-container">
<pre class="src src-c">asmlinkage <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">__do_softirq</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">void</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">softirq_action</span> *<span style="color: #FD971F;">h</span>;
    <span style="color: #66D9EF;">__u32</span> <span style="color: #FD971F;">pending</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">max_restart</span> = MAX_SOFTIRQ_RESTART;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cpu</span>;

    pending = <span style="color: #A6E22E; font-weight: bold;">local_softirq_pending</span><span style="color: #66D9EF;">()</span>;

    ...

    h = softirq_vec;

    <span style="color: #F92672;">do</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #A6E22E;">(</span>pending &amp; 1<span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
            <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">prev_count</span> = <span style="color: #A6E22E; font-weight: bold;">preempt_count</span><span style="color: #E6DB74;">()</span>;
            <span style="color: #A6E22E; font-weight: bold;">kstat_incr_softirqs_this_cpu</span><span style="color: #E6DB74;">(</span>h - softirq_vec<span style="color: #E6DB74;">)</span>;

            <span style="color: #A6E22E; font-weight: bold;">trace_softirq_entry</span><span style="color: #E6DB74;">(</span>h, softirq_vec<span style="color: #E6DB74;">)</span>;
            h-&gt;<span style="color: #A6E22E; font-weight: bold;">action</span><span style="color: #E6DB74;">(</span>h<span style="color: #E6DB74;">)</span>;


        h++;
        pending &gt;&gt;= 1;
    <span style="color: #A6E22E;">}</span> <span style="color: #A6E22E; font-weight: bold;">while</span> <span style="color: #A6E22E;">(</span>pending<span style="color: #A6E22E;">)</span>;

    ...
<span style="color: #66D9EF;">}</span>

asmlinkage <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">do_softirq</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">void</span><span style="color: #66D9EF;">)</span>
<span style="color: #66D9EF;">{</span>
    <span style="color: #66D9EF;">__u32</span> <span style="color: #FD971F;">pending</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span>;

    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #A6E22E;">(</span><span style="color: #A6E22E; font-weight: bold;">in_interrupt</span><span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span>
        <span style="color: #F92672;">return</span>;

    <span style="color: #A6E22E; font-weight: bold;">local_irq_save</span><span style="color: #A6E22E;">(</span>flags<span style="color: #A6E22E;">)</span>;

    pending = <span style="color: #A6E22E; font-weight: bold;">local_softirq_pending</span><span style="color: #A6E22E;">()</span>;

    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #A6E22E;">(</span>pending<span style="color: #A6E22E;">)</span>
        <span style="color: #A6E22E; font-weight: bold;">__do_softirq</span><span style="color: #A6E22E;">()</span>;

    <span style="color: #A6E22E; font-weight: bold;">local_irq_restore</span><span style="color: #A6E22E;">(</span>flags<span style="color: #A6E22E;">)</span>;
<span style="color: #66D9EF;">}</span>
</pre>
</div>

<p>
软中断执行过程中，允许响应中断，但自身不能休眠，通常来说软中断用于处理单处理器数据<br />
</p>

<ul class="org-ul">
<li>tasklet<br /></li>
</ul>

<p>
源头是软中断的HI_SOFTIRQ和TASKLET_SOFTIRQ<br />
</p>
<div class="org-src-container">
<pre class="src src-c">
<span style="color: #F92672;">enum</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #FD971F;">TASKLET_STATE_SCHED</span>,    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Tasklet is scheduled for execution </span><span style="color: #75715E;">*/</span>
    <span style="color: #FD971F;">TASKLET_STATE_RUN</span>   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Tasklet is running (SMP only) </span><span style="color: #75715E;">*/</span>
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tasklet_struct</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tasklet_struct</span> *<span style="color: #FD971F;">next</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#38142;&#34920;&#25351;&#38024;&#65292;&#22836;&#26159;task_vec&#21644;task_hi_vec</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">state</span>; <span style="color: #75715E;">// </span><span style="color: #E6DB74;">TASKLET_STATE_RUN&#30340;&#35805;&#26159;&#30475;&#20854;&#20182;&#22788;&#29702;&#22120;&#26159;&#21542;&#22312;&#36816;&#34892;</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">count</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#19981;&#20026;0&#34920;&#31034;tassklet&#34987;&#31105;&#27490;</span>
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*func<span style="color: #66D9EF;">)(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">data</span>;
<span style="color: #AE81FF;">}</span>;

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#38745;&#24577;&#21019;&#24314;</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">DECLARE_TASKLET</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">name</span>, <span style="color: #FD971F;">func</span>, <span style="color: #FD971F;">data</span><span style="color: #AE81FF;">)</span> \
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tasklet_struct</span> <span style="color: #FD971F;">name</span> = <span style="color: #AE81FF;">{</span> <span style="color: #AE81FF;">NULL</span>, 0, <span style="color: #A6E22E; font-weight: bold;">ATOMIC_INIT</span><span style="color: #66D9EF;">(</span>0<span style="color: #66D9EF;">)</span>, func, data <span style="color: #AE81FF;">}</span>

<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">DECLARE_TASKLET_DISABLED</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">name</span>, <span style="color: #FD971F;">func</span>, <span style="color: #FD971F;">data</span><span style="color: #AE81FF;">)</span> \
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tasklet_struct</span> <span style="color: #FD971F;">name</span> = <span style="color: #AE81FF;">{</span> <span style="color: #AE81FF;">NULL</span>, 0, <span style="color: #A6E22E; font-weight: bold;">ATOMIC_INIT</span><span style="color: #66D9EF;">(</span>1<span style="color: #66D9EF;">)</span>, func, data <span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21160;&#24577;&#21019;&#24314;</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">tasklet_init</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tasklet_struct</span> *<span style="color: #FD971F;">t</span>,
          <span style="color: #66D9EF;">void</span> <span style="color: #66D9EF;">(</span>*<span style="color: #A6E22E; font-size: 130%;">func</span><span style="color: #66D9EF;">)(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span><span style="color: #66D9EF;">)</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">data</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    t-&gt;next = <span style="color: #AE81FF;">NULL</span>;
    t-&gt;state = 0;
    <span style="color: #A6E22E; font-weight: bold;">atomic_set</span><span style="color: #66D9EF;">(</span>&amp;t-&gt;count, 0<span style="color: #66D9EF;">)</span>;
    t-&gt;func = func;
    t-&gt;data = data;
<span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
加tasklet的函数是tasklet_schedule和tasklet_hi_vec，功能是加到tasklet_vec和tasklet_hi_vec链表中<br />
执行tasklet的函数是tasklet_action和tasklet_hi_action，功能是遍历tasklet_vec和tasklet_hi_vec链表，执行action，同时如果tasklet_struct-&gt;count不为0，则重新加入链表<br />
</p>

<ul class="org-ul">
<li>ksoftirqd<br /></li>
</ul>
<p>
立即处理所有软中断(包括重复自触发)         - 大量软中断存在时无法调度用户任务<br />
下一次中断时处理所有软中断(包括重复自触发) - 系统空闲没有太多中断时影响响应时间<br />
</p>

<p>
<b>每个处长理器创建最低优先级内核线程ksoftirqd/n</b><br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">run_ksoftirqd</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">void</span> * <span style="color: #FD971F;">__bind_cpu</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #A6E22E; font-weight: bold;">set_current_state</span><span style="color: #66D9EF;">(</span>TASK_INTERRUPTIBLE<span style="color: #66D9EF;">)</span>;

    <span style="color: #A6E22E; font-weight: bold;">while</span> <span style="color: #66D9EF;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span><span style="color: #A6E22E; font-weight: bold;">kthread_should_stop</span><span style="color: #A6E22E;">()</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span> <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#27515;&#24490;&#29615;</span>
        <span style="color: #A6E22E; font-weight: bold;">preempt_disable</span><span style="color: #A6E22E;">()</span>;
        <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #A6E22E;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span><span style="color: #A6E22E; font-weight: bold;">local_softirq_pending</span><span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span> <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#26080;&#36719;&#20013;&#26029;&#21017;&#35843;&#24230;</span>
            <span style="color: #A6E22E; font-weight: bold;">preempt_enable_no_resched</span><span style="color: #E6DB74;">()</span>;
            <span style="color: #A6E22E; font-weight: bold;">schedule</span><span style="color: #E6DB74;">()</span>;
            <span style="color: #A6E22E; font-weight: bold;">preempt_disable</span><span style="color: #E6DB74;">()</span>;
        <span style="color: #A6E22E;">}</span>

        <span style="color: #A6E22E; font-weight: bold;">__set_current_state</span><span style="color: #A6E22E;">(</span>TASK_RUNNING<span style="color: #A6E22E;">)</span>;

        <span style="color: #A6E22E; font-weight: bold;">while</span> <span style="color: #A6E22E;">(</span><span style="color: #A6E22E; font-weight: bold;">local_softirq_pending</span><span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
            <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Preempt disable stops cpu going offline.</span>
<span style="color: #E6DB74;">               If already offline, we'll be on wrong CPU:</span>
<span style="color: #E6DB74;">               don't process </span><span style="color: #75715E;">*/</span>
            <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #E6DB74;">(</span><span style="color: #A6E22E; font-weight: bold;">cpu_is_offline</span><span style="color: #FD971F;">(</span><span style="color: #F92672;">(</span><span style="color: #66D9EF;">long</span><span style="color: #F92672;">)</span>__bind_cpu<span style="color: #FD971F;">)</span><span style="color: #E6DB74;">)</span>
                <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">wait_to_die</span>;
            <span style="color: #A6E22E; font-weight: bold;">do_softirq</span><span style="color: #E6DB74;">()</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#26377;&#36719;&#20013;&#26029;&#65292;&#22788;&#29702;</span>
            <span style="color: #A6E22E; font-weight: bold;">preempt_enable_no_resched</span><span style="color: #E6DB74;">()</span>;
            <span style="color: #A6E22E; font-weight: bold;">cond_resched</span><span style="color: #E6DB74;">()</span>;
            <span style="color: #A6E22E; font-weight: bold;">preempt_disable</span><span style="color: #E6DB74;">()</span>;
            <span style="color: #A6E22E; font-weight: bold;">rcu_sched_qs</span><span style="color: #E6DB74;">(</span><span style="color: #FD971F;">(</span><span style="color: #66D9EF;">long</span><span style="color: #FD971F;">)</span>__bind_cpu<span style="color: #E6DB74;">)</span>;
        <span style="color: #A6E22E;">}</span>
        <span style="color: #A6E22E; font-weight: bold;">preempt_enable</span><span style="color: #A6E22E;">()</span>;
        <span style="color: #A6E22E; font-weight: bold;">set_current_state</span><span style="color: #A6E22E;">(</span>TASK_INTERRUPTIBLE<span style="color: #A6E22E;">)</span>;
    <span style="color: #66D9EF;">}</span>
    <span style="color: #A6E22E; font-weight: bold;">__set_current_state</span><span style="color: #66D9EF;">(</span>TASK_RUNNING<span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">return</span> 0;

<span style="color: #AE81FF;">wait_to_die</span>:
    <span style="color: #A6E22E; font-weight: bold;">preempt_enable</span><span style="color: #66D9EF;">()</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Wait for kthread_stop </span><span style="color: #75715E;">*/</span>
    <span style="color: #A6E22E; font-weight: bold;">set_current_state</span><span style="color: #66D9EF;">(</span>TASK_INTERRUPTIBLE<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">while</span> <span style="color: #66D9EF;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span><span style="color: #A6E22E; font-weight: bold;">kthread_should_stop</span><span style="color: #A6E22E;">()</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #A6E22E; font-weight: bold;">schedule</span><span style="color: #A6E22E;">()</span>;
        <span style="color: #A6E22E; font-weight: bold;">set_current_state</span><span style="color: #A6E22E;">(</span>TASK_INTERRUPTIBLE<span style="color: #A6E22E;">)</span>;
    <span style="color: #66D9EF;">}</span>
    <span style="color: #A6E22E; font-weight: bold;">__set_current_state</span><span style="color: #66D9EF;">(</span>TASK_RUNNING<span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">return</span> 0;
<span style="color: #AE81FF;">}</span>
</pre>
</div>

<ul class="org-ul">
<li>工作队列<br /></li>
</ul>
<p>
任务交由内核线程去执行，同时可以睡眠<br />
可能自已创建一个内核线程，但最好使用默认建好的线程events/n<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#24037;&#20316;&#32773;&#32467;&#26500;&#65292;&#21487;&#20197;&#26377;&#26377;&#22810;&#20010;&#23454;&#20363;&#65292;&#40664;&#35748;&#26159;events&#20869;&#26680;&#32447;&#31243;&#32452;</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">workqueue_struct</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cpu_workqueue_struct</span> *<span style="color: #FD971F;">cpu_wq</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#23454;&#38469;&#26159;&#20010;&#25968;&#32452;&#65292;&#27599;&#19968;&#39033;&#23545;&#24212;&#19968;&#20010;&#22788;&#29702;&#22120;</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">list</span>;
    <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">name</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">singlethread</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">freezeable</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Freeze threads during suspend </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">rt</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_LOCKDEP
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">lockdep_map</span> <span style="color: #FD971F;">lockdep_map</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #AE81FF;">}</span>;

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#27599;&#20010;CPU&#26377;&#19968;&#20010;&#20869;&#26680;&#32447;&#31243;&#65292;&#20256;&#36827;&#21435;&#30340;&#32467;&#26500;&#23601;&#26159;struct cpu_workqueue_struct</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cpu_workqueue_struct</span> <span style="color: #AE81FF;">{</span>

    <span style="color: #66D9EF;">spinlock_t</span> <span style="color: #FD971F;">lock</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">worklist</span>;
    <span style="color: #66D9EF;">wait_queue_head_t</span> <span style="color: #FD971F;">more_work</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">work_struct</span> *<span style="color: #FD971F;">current_work</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">workqueue_struct</span> *<span style="color: #FD971F;">wq</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">thread</span>;
<span style="color: #AE81FF;">}</span> <span style="color: #FD971F;">____cacheline_aligned</span>;

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#20855;&#20307;&#24037;&#20316;&#65292;&#25346;&#22312;struct cpu_workqueue_struct-&gt;more_work</span>
<span style="color: #F92672;">typedef</span> <span style="color: #66D9EF;">void</span> <span style="color: #AE81FF;">(</span>*<span style="color: #66D9EF;">work_func_t</span><span style="color: #AE81FF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">work_struct</span> *<span style="color: #FD971F;">work</span><span style="color: #AE81FF;">)</span>;
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">work_struct</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">atomic_long_t</span> <span style="color: #FD971F;">data</span>;
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">WORK_STRUCT_PENDING</span> 0       <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">T if work item pending execution </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">WORK_STRUCT_STATIC</span>  1       <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">static initializer (debugobjects) </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">WORK_STRUCT_FLAG_MASK</span> <span style="color: #66D9EF;">(</span>3UL<span style="color: #66D9EF;">)</span>
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">WORK_STRUCT_WQ_DATA_MASK</span> <span style="color: #66D9EF;">(</span>~WORK_STRUCT_FLAG_MASK<span style="color: #66D9EF;">)</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">entry</span>;
    <span style="color: #66D9EF;">work_func_t</span> <span style="color: #FD971F;">func</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_LOCKDEP
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">lockdep_map</span> <span style="color: #FD971F;">lockdep_map</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #AE81FF;">}</span>;

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#27599;&#20010;&#24037;&#20316;&#32773;&#32447;&#31243;&#37117;&#20351;&#29992;&#20869;&#26680;&#32447;&#31243;&#65292;&#24182;&#25191;&#34892;worker_thread</span>
<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">worker_thread</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">__cwq</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cpu_workqueue_struct</span> *<span style="color: #FD971F;">cwq</span> = __cwq;
    <span style="color: #A6E22E; font-size: 130%;">DEFINE_WAIT</span><span style="color: #66D9EF;">(</span>wait<span style="color: #66D9EF;">)</span>;

    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span>cwq-&gt;wq-&gt;freezeable<span style="color: #66D9EF;">)</span>
        <span style="color: #A6E22E; font-weight: bold;">set_freezable</span><span style="color: #66D9EF;">()</span>;

    <span style="color: #A6E22E; font-weight: bold;">for</span> <span style="color: #66D9EF;">(</span>;;<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #A6E22E; font-weight: bold;">prepare_to_wait</span><span style="color: #A6E22E;">(</span>&amp;cwq-&gt;more_work, &amp;wait, TASK_INTERRUPTIBLE<span style="color: #A6E22E;">)</span>;
        <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #A6E22E;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span><span style="color: #A6E22E; font-weight: bold;">freezing</span><span style="color: #E6DB74;">(</span>current<span style="color: #E6DB74;">)</span> &amp;&amp;
            <span style="color: #E6DB74; font-weight: bold;">!</span><span style="color: #A6E22E; font-weight: bold;">kthread_should_stop</span><span style="color: #E6DB74;">()</span> &amp;&amp;
            <span style="color: #A6E22E; font-weight: bold;">list_empty</span><span style="color: #E6DB74;">(</span>&amp;cwq-&gt;worklist<span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span>
            <span style="color: #A6E22E; font-weight: bold;">schedule</span><span style="color: #A6E22E;">()</span>;
        <span style="color: #A6E22E; font-weight: bold;">finish_wait</span><span style="color: #A6E22E;">(</span>&amp;cwq-&gt;more_work, &amp;wait<span style="color: #A6E22E;">)</span>;

        <span style="color: #A6E22E; font-weight: bold;">try_to_freeze</span><span style="color: #A6E22E;">()</span>;

        <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #A6E22E;">(</span><span style="color: #A6E22E; font-weight: bold;">kthread_should_stop</span><span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span>
            <span style="color: #F92672;">break</span>;

        <span style="color: #A6E22E; font-weight: bold;">run_workqueue</span><span style="color: #A6E22E;">(</span>cwq<span style="color: #A6E22E;">)</span>;
    <span style="color: #66D9EF;">}</span>

    <span style="color: #F92672;">return</span> 0;
<span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#24037;&#20316;&#21021;&#22987;&#21270;</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">DECLARE_WORK</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">n</span>, <span style="color: #FD971F;">f</span><span style="color: #AE81FF;">)</span>                  \
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">work_struct</span> <span style="color: #FD971F;">n</span> = <span style="color: #A6E22E; font-weight: bold;">__WORK_INITIALIZER</span><span style="color: #AE81FF;">(</span>n, f<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">INIT_WORK</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">_work</span>, <span style="color: #FD971F;">_func</span><span style="color: #AE81FF;">)</span>                 \
    <span style="color: #F92672;">do</span> <span style="color: #AE81FF;">{</span>                            \
        <span style="color: #A6E22E; font-weight: bold;">__INIT_WORK</span><span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>_work<span style="color: #A6E22E;">)</span>, <span style="color: #A6E22E;">(</span>_func<span style="color: #A6E22E;">)</span>, 0<span style="color: #66D9EF;">)</span>;       \
    <span style="color: #AE81FF;">}</span> <span style="color: #A6E22E; font-weight: bold;">while</span> <span style="color: #AE81FF;">(</span>0<span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#25554;&#20837;events&#24037;&#20316;&#32447;&#31243;</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">schedule_work</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">work_struct</span> *<span style="color: #FD971F;">work</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">return</span> <span style="color: #A6E22E; font-weight: bold;">queue_work</span><span style="color: #66D9EF;">(</span>keventd_wq, work<span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#25554;&#20837;events&#24037;&#20316;&#32447;&#31243; &#20294;&#32463;&#36807;delay&#21518;&#25165;&#21487;&#34987;&#25191;&#34892;</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">schedule_delayed_work</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">delayed_work</span> *<span style="color: #FD971F;">dwork</span>,
                    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">delay</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">return</span> <span style="color: #A6E22E; font-weight: bold;">queue_delayed_work</span><span style="color: #66D9EF;">(</span>keventd_wq, dwork, delay<span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#31561;&#24453;&#25152;&#26377;&#38750;delay work&#24037;&#20316;&#37117;&#34987;&#25191;&#34892;&#21518;&#25165;&#36820;&#22238;&#65292;&#21487;&#33021;&#20250;&#20241;&#30496;</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">flush_scheduled_work</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">void</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #A6E22E; font-weight: bold;">flush_workqueue</span><span style="color: #66D9EF;">(</span>keventd_wq<span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21462;&#28040;&#24310;&#26102;&#25191;&#34892;&#30340;&#24037;&#20316;</span>
<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">cancel_delayed_work_sync</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">delayed_work</span> *<span style="color: #FD971F;">dwork</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">return</span> <span style="color: #A6E22E; font-weight: bold;">__cancel_work_timer</span><span style="color: #66D9EF;">(</span>&amp;dwork-&gt;work, &amp;dwork-&gt;timer<span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21019;&#24314;&#33258;&#24050;&#30340;&#24037;&#20316;&#32773;&#32467;&#26500;&#65292;&#31561;&#21516;events/n</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">create_workqueue</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">name</span><span style="color: #AE81FF;">)</span> <span style="color: #A6E22E; font-weight: bold;">__create_workqueue</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">(</span>name<span style="color: #66D9EF;">)</span>, 0, 0, 0<span style="color: #AE81FF;">)</span>
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21152;&#20837;&#33258;&#23450;&#20041;&#30340;&#24037;&#20316;&#38431;&#21015;</span>
<span style="color: #F92672;">extern</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">queue_work</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">workqueue_struct</span> *<span style="color: #FD971F;">wq</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">work_struct</span> *<span style="color: #FD971F;">work</span><span style="color: #AE81FF;">)</span>;
<span style="color: #F92672;">extern</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">queue_delayed_work</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">workqueue_struct</span> *<span style="color: #FD971F;">wq</span>,
            <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">delayed_work</span> *<span style="color: #FD971F;">work</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">delay</span><span style="color: #AE81FF;">)</span>;
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21047;&#26032;</span>
<span style="color: #F92672;">extern</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">flush_workqueue</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">workqueue_struct</span> *<span style="color: #FD971F;">wq</span><span style="color: #AE81FF;">)</span>;
</pre>
</div>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">下半部</th>
<th scope="col" class="org-left">上下文</th>
<th scope="col" class="org-left">顺序执行保障</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">软中断</td>
<td class="org-left">中断</td>
<td class="org-left">没有</td>
</tr>

<tr>
<td class="org-left">tasklet</td>
<td class="org-left">中断</td>
<td class="org-left">同类型不能同时运行</td>
</tr>

<tr>
<td class="org-left">工作队列</td>
<td class="org-left">进程</td>
<td class="org-left">没有</td>
</tr>
</tbody>
</table>

<p>
进程上下文和下半部共享数据时加锁, 禁止下半部<br />
中断上下文和下半部共享数据时加锁，禁中断<br />
</p>

<p>
local_bh_disable禁止软中断和tasklet，并可嵌套调用，实现方式就是preempt_count + SOFTIRQ_OFFSET<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;"> * We put the hardirq and softirq counter into the preemption</span>
<span style="color: #E6DB74;"> * counter. The bitmask has the following meaning:</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * - bits 0-7 are the preemption count (max preemption depth: 256)</span>
<span style="color: #E6DB74;"> * - bits 8-15 are the softirq count (max # of softirqs: 256)</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * The hardirq count can in theory reach the same as NR_IRQS.</span>
<span style="color: #E6DB74;"> * In reality, the number of nested IRQS is limited to the stack</span>
<span style="color: #E6DB74;"> * size as well. For archs with over 1000 IRQS it is not practical</span>
<span style="color: #E6DB74;"> * to expect that they will all nest. We give a max of 10 bits for</span>
<span style="color: #E6DB74;"> * hardirq nesting. An arch may choose to give less than 10 bits.</span>
<span style="color: #E6DB74;"> * m68k expects it to be 8.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * - bits 16-25 are the hardirq count (max # of nested hardirqs: 1024)</span>
<span style="color: #E6DB74;"> * - bit 26 is the NMI_MASK</span>
<span style="color: #E6DB74;"> * - bit 28 is the PREEMPT_ACTIVE flag</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * PREEMPT_MASK: 0x000000ff</span>
<span style="color: #E6DB74;"> * SOFTIRQ_MASK: 0x0000ff00</span>
<span style="color: #E6DB74;"> * HARDIRQ_MASK: 0x03ff0000</span>
<span style="color: #E6DB74;"> *     NMI_MASK: 0x04000000</span>
<span style="color: #E6DB74;"> </span><span style="color: #75715E;">*/</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org75effc6" class="outline-2">
<h2 id="org75effc6"><span class="section-number-2">9</span> 第九章 内核同步介绍</h2>
<div class="outline-text-2" id="text-9">
<p>
临界区   - 访问和操作共享数据的代码段<br />
竞争条件 - 临界区被同时执行<br />
同步     - 避免并发和防止竞争条件<br />
</p>

<p>
并发的场景<br />
</p>
<ul class="org-ul">
<li>中断，在任何时间异步发生<br /></li>
<li>软中断和tasklet, 在任何时间异步发生<br /></li>
<li>内核抢占, 内核任务可能被另一任务抢占<br /></li>
<li>睡眠及用户空间的同步<br /></li>
<li>多处理器<br /></li>
</ul>

<p>
竞争条件<br />
</p>
<ul class="org-ul">
<li>和中断处理程序共享资源<br /></li>
<li>访问共享资源可被抢占<br /></li>
<li>临界区里睡眠<br /></li>
<li>多处理器访问同一个共享数据<br /></li>
</ul>

<p>
安全代码<br />
</p>
<ul class="org-ul">
<li>interrupt-safe<br /></li>
<li>smp-safe<br /></li>
<li>preempt-safe<br /></li>
</ul>

<p>
当分析数据是否是共享时<br />
<b>这个数据是不是全局的？除了当前线程外，其他线程能不能访问它</b><br />
<b>这个数据会不会在进程上下文和中断上下文中共享？它是不是要在两个不同的中断处理程序中共享?</b><br />
<b>进程在访问数据时可不可能被抢占？被调度的新程序会不会访问同一数据</b><br />
<b>这个函数又在另一个处理器上被调度会发生什么</b><br />
</p>

<p>
对于死锁，加锁的顺序所有流程应一致，解锁的顺序无所谓，但最好以获得锁的相反顺序<br />
</p>
</div>
</div>

<div id="outline-container-org978921c" class="outline-2">
<h2 id="org978921c"><span class="section-number-2">10</span> 第十章 内核同步方法</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li><b>原子操作</b><br /></li>
</ul>

<p>
常用作计数器<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">typedef</span> <span style="color: #F92672;">struct</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">volatile</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">counter</span>;
<span style="color: #AE81FF;">}</span> <span style="color: #66D9EF;">atomic_t</span>;

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#38745;&#24577;&#21021;&#22987;&#21270;</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">ATOMIC_INIT</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">i</span><span style="color: #AE81FF;">)</span>  <span style="color: #AE81FF;">{</span> <span style="color: #66D9EF;">(</span>i<span style="color: #66D9EF;">)</span> <span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21407;&#23376;&#35774;&#20540;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">atomic_set</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">atomic_t</span> *<span style="color: #FD971F;">v</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    v-&gt;counter = i;
<span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21407;&#23376;&#21152;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">atomic_add</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span>, <span style="color: #66D9EF;">atomic_t</span> *<span style="color: #FD971F;">v</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">asm</span> <span style="color: #A6E22E; font-weight: bold;">volatile</span><span style="color: #66D9EF;">(</span>LOCK_PREFIX <span style="color: #E6DB74;">"addl %1,%0"</span>
             : <span style="color: #E6DB74;">"+m"</span> <span style="color: #A6E22E;">(</span>v-&gt;counter<span style="color: #A6E22E;">)</span>
             : <span style="color: #E6DB74;">"ir"</span> <span style="color: #A6E22E;">(</span>i<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21407;&#23376;&#20943;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">atomic_sub</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span>, <span style="color: #66D9EF;">atomic_t</span> *<span style="color: #FD971F;">v</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">asm</span> <span style="color: #A6E22E; font-weight: bold;">volatile</span><span style="color: #66D9EF;">(</span>LOCK_PREFIX <span style="color: #E6DB74;">"subl %1,%0"</span>
             : <span style="color: #E6DB74;">"+m"</span> <span style="color: #A6E22E;">(</span>v-&gt;counter<span style="color: #A6E22E;">)</span>
             : <span style="color: #E6DB74;">"ir"</span> <span style="color: #A6E22E;">(</span>i<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21407;&#23376;&#33258;&#22686;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">atomic_inc</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">atomic_t</span> *<span style="color: #FD971F;">v</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">asm</span> <span style="color: #A6E22E; font-weight: bold;">volatile</span><span style="color: #66D9EF;">(</span>LOCK_PREFIX <span style="color: #E6DB74;">"incl %0"</span>
             : <span style="color: #E6DB74;">"+m"</span> <span style="color: #A6E22E;">(</span>v-&gt;counter<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21407;&#23376;&#33258;&#20943;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">atomic_dec</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">atomic_t</span> *<span style="color: #FD971F;">v</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">asm</span> <span style="color: #A6E22E; font-weight: bold;">volatile</span><span style="color: #66D9EF;">(</span>LOCK_PREFIX <span style="color: #E6DB74;">"decl %0"</span>
             : <span style="color: #E6DB74;">"+m"</span> <span style="color: #A6E22E;">(</span>v-&gt;counter<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21407;&#23376;&#36716;&#25442;&#25104;int</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">atomic_read</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">const</span> <span style="color: #66D9EF;">atomic_t</span> *<span style="color: #FD971F;">v</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">return</span> v-&gt;counter;
<span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21407;&#23376;&#20943;&#65292;&#32467;&#26524;&#20026;0&#36820;&#22238;&#30495;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">atomic_sub_and_test</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span>, <span style="color: #66D9EF;">atomic_t</span> *<span style="color: #FD971F;">v</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">c</span>;

    <span style="color: #F92672;">asm</span> <span style="color: #A6E22E; font-weight: bold;">volatile</span><span style="color: #66D9EF;">(</span>LOCK_PREFIX <span style="color: #E6DB74;">"subl %2,%0; sete %1"</span>
             : <span style="color: #E6DB74;">"+m"</span> <span style="color: #A6E22E;">(</span>v-&gt;counter<span style="color: #A6E22E;">)</span>, <span style="color: #E6DB74;">"=qm"</span> <span style="color: #A6E22E;">(</span>c<span style="color: #A6E22E;">)</span>
             : <span style="color: #E6DB74;">"ir"</span> <span style="color: #A6E22E;">(</span>i<span style="color: #A6E22E;">)</span> : <span style="color: #E6DB74;">"memory"</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">return</span> c;
<span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21407;&#23376;&#21152;&#65292;&#32467;&#26524;&#26159;&#36127;&#25968;&#36820;&#22238;&#30495;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">atomic_add_negative</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span>, <span style="color: #66D9EF;">atomic_t</span> *<span style="color: #FD971F;">v</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">c</span>;

    <span style="color: #F92672;">asm</span> <span style="color: #A6E22E; font-weight: bold;">volatile</span><span style="color: #66D9EF;">(</span>LOCK_PREFIX <span style="color: #E6DB74;">"addl %2,%0; sets %1"</span>
             : <span style="color: #E6DB74;">"+m"</span> <span style="color: #A6E22E;">(</span>v-&gt;counter<span style="color: #A6E22E;">)</span>, <span style="color: #E6DB74;">"=qm"</span> <span style="color: #A6E22E;">(</span>c<span style="color: #A6E22E;">)</span>
             : <span style="color: #E6DB74;">"ir"</span> <span style="color: #A6E22E;">(</span>i<span style="color: #A6E22E;">)</span> : <span style="color: #E6DB74;">"memory"</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">return</span> c;
<span style="color: #AE81FF;">}</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21407;&#23376;&#21152;&#65292;&#36820;&#22238;&#32467;&#26524;</span>
<span style="color: #F92672;">static</span> <span style="color: #F92672;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">atomic_add_return</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span>, <span style="color: #66D9EF;">atomic_t</span> *<span style="color: #FD971F;">v</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__i</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_M386
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span>;
    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #A6E22E; font-weight: bold;">unlikely</span><span style="color: #A6E22E;">(</span>boot_cpu_data.x86 &lt;= 3<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>
        <span style="color: #F92672;">goto</span> <span style="color: #AE81FF;">no_xadd</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Modern 486+ processor </span><span style="color: #75715E;">*/</span>
    __i = i;
    <span style="color: #F92672;">asm</span> <span style="color: #A6E22E; font-weight: bold;">volatile</span><span style="color: #66D9EF;">(</span>LOCK_PREFIX <span style="color: #E6DB74;">"xaddl %0, %1"</span>
             : <span style="color: #E6DB74;">"+r"</span> <span style="color: #A6E22E;">(</span>i<span style="color: #A6E22E;">)</span>, <span style="color: #E6DB74;">"+m"</span> <span style="color: #A6E22E;">(</span>v-&gt;counter<span style="color: #A6E22E;">)</span>
             : : <span style="color: #E6DB74;">"memory"</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">return</span> i + __i;

<span style="color: #F92672;">#ifdef</span> CONFIG_M386
<span style="color: #AE81FF;">no_xadd</span>: <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Legacy 386 processor </span><span style="color: #75715E;">*/</span>
    <span style="color: #A6E22E; font-weight: bold;">raw_local_irq_save</span><span style="color: #66D9EF;">(</span>flags<span style="color: #66D9EF;">)</span>;
    __i = <span style="color: #A6E22E; font-weight: bold;">atomic_read</span><span style="color: #66D9EF;">(</span>v<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">atomic_set</span><span style="color: #66D9EF;">(</span>v, i + __i<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">raw_local_irq_restore</span><span style="color: #66D9EF;">(</span>flags<span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">return</span> i + __i;
<span style="color: #F92672;">#endif</span>
<span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
<b>要区分原子性与顺序性</b><br />
原子性 - 保证指令全部执行完，要么不执行 例: 两个操作写，结果必为两个写中的一个<br />
顺序性 - 保证多指令出现在不同的线程中也要保证原来的读写顺序 例: 读必须在写之前完成<br />
</p>

<p>
64位的原子类型是atomic64_t<br />
</p>

<p>
<b>原子</b> 位操作bitops.h，基本单位32位<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">set_bit(nr, addr)</td>
<td class="org-left">addr的第nr位设bit1</td>
</tr>

<tr>
<td class="org-left">clear_bit(nr, addr)</td>
<td class="org-left">addr的第nr位设bit0</td>
</tr>

<tr>
<td class="org-left">change_bit(nr, addr)</td>
<td class="org-left">翻转addr的第nr位</td>
</tr>

<tr>
<td class="org-left">test_and_set_bit(nr, addr)</td>
<td class="org-left">addr的第nr位设bit1 同时返回旧值</td>
</tr>

<tr>
<td class="org-left">test_and_clear_bit(nr, addr)</td>
<td class="org-left">addr的第nr位设bit0 同时返回旧值</td>
</tr>

<tr>
<td class="org-left">test_and_change_bit(nr, addr)</td>
<td class="org-left">翻转addr的第nr位，同时返回旧值</td>
</tr>

<tr>
<td class="org-left">test_bit(nr, addr)</td>
<td class="org-left">返回第nr位</td>
</tr>
</tbody>
</table>
<p>
32位机，31位是最高位，32是下个字的最低位<br />
非原子操作函数名类似，前面加__，如非原子set bit是__set_bit<br />
</p>

<p>
位搜索<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">find_first_bit</td>
<td class="org-left">第一个bit1</td>
</tr>

<tr>
<td class="org-left">find_first_zero_bit</td>
<td class="org-left">第一个bit0</td>
</tr>

<tr>
<td class="org-left">_ffs</td>
<td class="org-left">一个字内第一个bit1</td>
</tr>

<tr>
<td class="org-left">ffz</td>
<td class="org-left">一个字内第一个bit0</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>自旋锁spinlock<br /></li>
</ul>
<p>
自旋锁最多只能被一个执行线程持有，如果已被持有，则一直进行 <b>忙循环</b><br />
自旋锁不可递归，同时在单处理器中，自旋锁只是禁止内核抢占，如果编译内核时不指定内核抢占，那么什么都不做<br />
</p>

<p>
常用的加锁代码:<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #A6E22E; font-size: 130%;">DEFINE_SPINLOCK</span><span style="color: #AE81FF;">(</span>mr_lock<span style="color: #AE81FF;">)</span>;
<span style="color: #A6E22E; font-weight: bold;">spin_lock</span><span style="color: #AE81FF;">(</span>&amp;mr_lock<span style="color: #AE81FF;">)</span>;
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#20020;&#30028;&#21306;</span>
<span style="color: #A6E22E; font-weight: bold;">spin_unlock</span><span style="color: #AE81FF;">(</span>&amp;mr_lock<span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
中断程序使用自旋锁:<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #A6E22E; font-size: 130%;">DEFINE_SPINLOCK</span><span style="color: #AE81FF;">(</span>mr_lock<span style="color: #AE81FF;">)</span>;
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">log</span> <span style="color: #FD971F;">flags</span>;

<span style="color: #A6E22E; font-weight: bold;">spin_lock_irqsave</span><span style="color: #AE81FF;">(</span>&amp;mr_lock, flags<span style="color: #AE81FF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#30452;&#25509;&#20851;&#20013;&#26029;&#21487;&#20197;spin_lock_irq&#65292;&#20294;&#26159;&#19981;&#25512;&#33616;&#20351;&#29992;</span>
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#20020;&#30028;&#21306;</span>
<span style="color: #A6E22E; font-weight: bold;">spin_lock_irqrestore</span><span style="color: #AE81FF;">(</span>&amp;mr_lock, flags<span style="color: #AE81FF;">)</span>;
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">spin_lock</td>
<td class="org-left">获取锁</td>
</tr>

<tr>
<td class="org-left">spin_lock_irq</td>
<td class="org-left">禁止本地中断并获取锁</td>
</tr>

<tr>
<td class="org-left">spin_lock_irqsave</td>
<td class="org-left">保存中断状态，禁止本地中断并获取锁</td>
</tr>

<tr>
<td class="org-left">spin_unlock</td>
<td class="org-left">释放锁</td>
</tr>

<tr>
<td class="org-left">spin_unlock_irq</td>
<td class="org-left">释放锁并激活中断</td>
</tr>

<tr>
<td class="org-left">spin_unlock_irqrestore</td>
<td class="org-left">释放锁，恢复中断状态</td>
</tr>

<tr>
<td class="org-left">spin_lock_init</td>
<td class="org-left">动态初始化</td>
</tr>

<tr>
<td class="org-left">spin_trylock</td>
<td class="org-left">试图获取锁，如未成功返回非0</td>
</tr>

<tr>
<td class="org-left">spin_is_locked</td>
<td class="org-left">锁被获取返回非0</td>
</tr>

<tr>
<td class="org-left">spin_lock_bh</td>
<td class="org-left">获取锁并禁止下半部</td>
</tr>

<tr>
<td class="org-left">spin_unlock_bh</td>
<td class="org-left">释放锁并激活下半部</td>
</tr>
</tbody>
</table>

<p>
读写自旋锁类似，区别是可允许多个读<br />
</p>

<ul class="org-ul">
<li>信号量 semaphore.h<br /></li>
</ul>
<p>
是一种 <b>睡眠</b> 锁，适用于锁会被长时间持有的情况， <b>只能在进程上下文中用</b><br />
只允许一个使用锁时为二值信号量<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">sema_init</td>
<td class="org-left">以指定的计数值初始化</td>
</tr>

<tr>
<td class="org-left">init_MUTEX</td>
<td class="org-left">动态初始化二值信号量</td>
</tr>

<tr>
<td class="org-left">init_MUTEX_LOCKED</td>
<td class="org-left">动态初始化已加锁二值信号量</td>
</tr>

<tr>
<td class="org-left">down_interruptible</td>
<td class="org-left">获得锁，会睡眠，会被信号打断会返回-ENITR</td>
</tr>

<tr>
<td class="org-left">down</td>
<td class="org-left">获得锁，会睡眠，不会被信号打断</td>
</tr>

<tr>
<td class="org-left">down_trylock</td>
<td class="org-left">试图获得锁，不成功返回非0</td>
</tr>

<tr>
<td class="org-left">up</td>
<td class="org-left">释放</td>
</tr>
</tbody>
</table>

<p>
读写信号量类似，区别是可允许多个读，函数返回值会有所区别<br />
</p>

<p>
内核有单独的互斥锁，代替二值信号量<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">mutex_init</td>
<td class="org-left">初始化</td>
</tr>

<tr>
<td class="org-left">mutex_lock</td>
<td class="org-left">加锁，会睡眠</td>
</tr>

<tr>
<td class="org-left">mutex_unlock</td>
<td class="org-left">解锁</td>
</tr>

<tr>
<td class="org-left">mutex_trylock</td>
<td class="org-left">试图获得锁，如成功则返回1</td>
</tr>

<tr>
<td class="org-left">mutex_is_lock</td>
<td class="org-left">锁已被用返回1</td>
</tr>
</tbody>
</table>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;"> * Simple, straightforward mutexes with strict semantics:</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * - only one task can hold the mutex at a time</span>
<span style="color: #E6DB74;"> * - only the owner can unlock the mutex</span>
<span style="color: #E6DB74;"> * - multiple unlocks are not permitted</span>
<span style="color: #E6DB74;"> * - recursive locking is not permitted</span>
<span style="color: #E6DB74;"> * - a mutex object must be initialized via the API</span>
<span style="color: #E6DB74;"> * - a mutex object must not be initialized via memset or copying</span>
<span style="color: #E6DB74;"> * - task may not exit with mutex held</span>
<span style="color: #E6DB74;"> * - memory areas where held locks reside must not be freed</span>
<span style="color: #E6DB74;"> * - held mutexes must not be reinitialized</span>
<span style="color: #E6DB74;"> * - mutexes may not be used in hardware or software interrupt</span>
<span style="color: #E6DB74;"> *   contexts such as tasklets and timers</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * These semantics are fully enforced when DEBUG_MUTEXES is</span>
<span style="color: #E6DB74;"> * enabled. Furthermore, besides enforcing the above rules, the mutex</span>
<span style="color: #E6DB74;"> * debugging code also implements a number of additional features</span>
<span style="color: #E6DB74;"> * that make lock debugging easier and faster:</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * - uses symbolic names of mutexes, whenever they are printed in debug output</span>
<span style="color: #E6DB74;"> * - point-of-acquire tracking, symbolic lookup of function names</span>
<span style="color: #E6DB74;"> * - list of all locks held in the system, printout of them</span>
<span style="color: #E6DB74;"> * - owner tracking</span>
<span style="color: #E6DB74;"> * - detects self-recursing locks and prints out all relevant info</span>
<span style="color: #E6DB74;"> * - detects multi-task circular deadlocks and prints out all affected</span>
<span style="color: #E6DB74;"> *   locks and tasks (and only those tasks)</span>
<span style="color: #E6DB74;"> </span><span style="color: #75715E;">*/</span>
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">需求</th>
<th scope="col" class="org-left">加锁方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">低开销加锁</td>
<td class="org-left">自旋锁</td>
</tr>

<tr>
<td class="org-left">短期锁定</td>
<td class="org-left">自旋锁</td>
</tr>

<tr>
<td class="org-left">长期加锁</td>
<td class="org-left">互斥锁</td>
</tr>

<tr>
<td class="org-left">中断上下文&amp;下半部</td>
<td class="org-left">自旋锁</td>
</tr>

<tr>
<td class="org-left">需要睡眠</td>
<td class="org-left">互斥锁</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>完成变量（条件变量）completion.h<br /></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">init_completion</td>
<td class="org-left">初始化</td>
</tr>

<tr>
<td class="org-left">wait_for_completion</td>
<td class="org-left">等待指定的完成变量接收信号</td>
</tr>

<tr>
<td class="org-left">complete</td>
<td class="org-left">发信号唤醒任何等待任务</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>顺序锁 seqlock.h<br /></li>
</ul>
<p>
对写者有利，有读时写锁也可获得，读时会在前后读计数确定中间没有写操作<br />
jiffies用的是顺序锁<br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#20363;&#31243;</span>

<span style="color: #66D9EF;">seqlock_t</span> <span style="color: #FD971F;">mr_seq_lock</span> = <span style="color: #A6E22E; font-weight: bold;">DEFINE_SEQLOCK</span><span style="color: #AE81FF;">(</span>mr_seq_lock<span style="color: #AE81FF;">)</span>;

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#20889;</span>
<span style="color: #A6E22E; font-weight: bold;">write_seqlock</span><span style="color: #AE81FF;">(</span>&amp;mr_seq_lock<span style="color: #AE81FF;">)</span>;
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">do sth writing</span>
<span style="color: #A6E22E; font-weight: bold;">write_sequnlock</span><span style="color: #AE81FF;">(</span>&amp;mr_seq_lock<span style="color: #AE81FF;">)</span>;


<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#35835;</span>
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">seq</span>;
<span style="color: #F92672;">do</span> <span style="color: #AE81FF;">{</span>
    seq = <span style="color: #A6E22E; font-weight: bold;">read_seqbegin</span><span style="color: #66D9EF;">(</span>&amp;mr_seq_lock<span style="color: #66D9EF;">)</span>;
    <span style="color: #75715E;">//</span><span style="color: #E6DB74;">do sth reading</span>
<span style="color: #AE81FF;">}</span> <span style="color: #A6E22E; font-weight: bold;">while</span><span style="color: #AE81FF;">(</span><span style="color: #A6E22E; font-weight: bold;">read_seqretry</span><span style="color: #66D9EF;">(</span>&amp;mr_seq_lock, seq<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>;

</pre>
</div>

<ul class="org-ul">
<li>禁止抢占<br /></li>
</ul>
<p>
常用于保护per处理器数据，不需要用自旋锁，所以关内核抢占就行了<br />
preempt_disable和preempt_enable<br />
</p>

<ul class="org-ul">
<li>顺序和屏障<br /></li>
</ul>
<p>
多用于硬件驱动程序<br />
</p>

<p>
编译器 - 对于看起来不相关的的多个读写，优化打乱顺序<br />
处理器 - 运行时看起来不相关的的多个读写，打乱顺序<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">屏障</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">rmb</td>
<td class="org-left">阻止屏障前后的读发生重排序</td>
</tr>

<tr>
<td class="org-left">read_barrier_depends</td>
<td class="org-left">阻止屏障前后的有数据依赖的读发生重排序</td>
</tr>

<tr>
<td class="org-left">wmb</td>
<td class="org-left">阻止屏障前后的写发生重排序</td>
</tr>

<tr>
<td class="org-left">mb</td>
<td class="org-left">阻止屏障前后的读写发生重排序</td>
</tr>

<tr>
<td class="org-left">smp_rmb</td>
<td class="org-left">支持SMP</td>
</tr>

<tr>
<td class="org-left">smp_read_barrier_depends</td>
<td class="org-left">支持SMP</td>
</tr>

<tr>
<td class="org-left">smp_wmb</td>
<td class="org-left">支持SMP</td>
</tr>

<tr>
<td class="org-left">smp_mb</td>
<td class="org-left">支持SMP</td>
</tr>

<tr>
<td class="org-left">barrier</td>
<td class="org-left">阻止编译器优化前后顺序</td>
</tr>
</tbody>
</table>
<p>
处理器屏障自然有编译器屏障<br />
<b>其实intel x86芯片不会执行乱序存储，所以wmb相当于空</b><br />
</p>
</div>
</div>


<div id="outline-container-org189a8ce" class="outline-2">
<h2 id="org189a8ce"><span class="section-number-2">11</span> 第十一章 定时器和时间管理</h2>
<div class="outline-text-2" id="text-11">
<p>
<b>__KERNEL__</b> 在编译内核时被定义，有时候用户程序需要内核头文件，这时候__KERNEL__就不会被定义<br />
如下，内核中HZ为CONFIG_HZ,在.config文件中，可通过make menuconfig配置，这里为1000，也就是说每秒钟时钟中断1000次<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">#if</span><span style="color: #F92672; font-weight: bold;">n</span><span style="color: #F92672;">def</span> __ASM_GENERIC_PARAM_H
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">__ASM_GENERIC_PARAM_H</span>

<span style="color: #75715E;">// </span><span style="color: #E6DB74;">When you compile your kernel, __KERNEL__ is defined on the command line.</span>

<span style="color: #75715E;">// </span><span style="color: #E6DB74;">User-space programs need access to the kernel headers, but some of the info in kernel headers is intended only for the kernel. Wrapping some statements in an #ifdef __KERNEL__/#endif block ensures that user-space programs don't see those statements.</span>
<span style="color: #F92672;">#ifdef</span> __KERNEL__ <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#22914;&#26524;</span>
<span style="color: #F92672;"># define</span> <span style="color: #FD971F;">HZ</span>     CONFIG_HZ   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Internal kernel timer frequency </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;"># define</span> <span style="color: #FD971F;">USER_HZ</span>    100     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">some user interfaces are </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;"># define</span> <span style="color: #FD971F;">CLOCKS_PER_SEC</span> <span style="color: #AE81FF;">(</span>USER_HZ<span style="color: #AE81FF;">)</span>       <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">in "ticks" like times() </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#endif</span>

<span style="color: #F92672;">#if</span><span style="color: #F92672; font-weight: bold;">n</span><span style="color: #F92672;">def</span> HZ
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">HZ</span> 100 <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#29992;&#25143;&#31243;&#24207;&#27704;&#36828;&#26159;100&#65292;&#20869;&#26680;&#36820;&#22238;&#29992;&#25143;&#26102;&#20250;&#29992;USER_HZ&#36716;&#25442;jiffies_to_clock_t</span>
<span style="color: #F92672;">#endif</span>

<span style="color: #F92672;">#if</span><span style="color: #F92672; font-weight: bold;">n</span><span style="color: #F92672;">def</span> EXEC_PAGESIZE
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">EXEC_PAGESIZE</span>   4096
<span style="color: #F92672;">#endif</span>

<span style="color: #F92672;">#if</span><span style="color: #F92672; font-weight: bold;">n</span><span style="color: #F92672;">def</span> NOGROUP
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">NOGROUP</span>     <span style="color: #AE81FF;">(</span>-1<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">#endif</span>

<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">MAXHOSTNAMELEN</span>  64  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">max length of hostname </span><span style="color: #75715E;">*/</span>

<span style="color: #F92672;">#endif</span> <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">__ASM_GENERIC_PARAM_H </span><span style="color: #75715E;">*/</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-txt">//.config文件
# CONFIG_CC_STACKPROTECTOR is not set
# CONFIG_HZ_100 is not set
# CONFIG_HZ_250 is not set
# CONFIG_HZ_300 is not set
CONFIG_HZ_1000=y
CONFIG_HZ=1000
</pre>
</div>

<p>
jiffies是两次连续的时钟节拍之间的时间,jiffies_64是jiffies同一个地址的64位整数<br />
<b>jiffies和jiffies_64通过链接脚本配置为同一个地址</b><br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span>

<span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;"> *  These inlines deal with timer wrapping correctly. You are </span>
<span style="color: #E6DB74;"> *  strongly encouraged to use them</span>
<span style="color: #E6DB74;"> *  1. Because people otherwise forget</span>
<span style="color: #E6DB74;"> *  2. Because if the timer wrap changes in future you won't have to</span>
<span style="color: #E6DB74;"> *     alter your driver code.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * time_after(a,b) returns true if the time a is after time b.</span>
<span style="color: #E6DB74;"> *</span>
<span style="color: #E6DB74;"> * Do this with "&lt;0" and "&gt;=0" to only test the sign of the result. A</span>
<span style="color: #E6DB74;"> * good compiler would generate better code (and a really good compiler</span>
<span style="color: #E6DB74;"> * wouldn't care). Gcc is currently neither.</span>
<span style="color: #E6DB74;"> </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">time_after</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">a</span>,<span style="color: #FD971F;">b</span><span style="color: #AE81FF;">)</span>     \
    <span style="color: #AE81FF;">(</span><span style="color: #A6E22E; font-weight: bold;">typecheck</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>, a<span style="color: #66D9EF;">)</span> &amp;&amp; \
     <span style="color: #A6E22E; font-weight: bold;">typecheck</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>, b<span style="color: #66D9EF;">)</span> &amp;&amp; \
     <span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">long</span><span style="color: #A6E22E;">)(</span>b<span style="color: #A6E22E;">)</span> - <span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">long</span><span style="color: #A6E22E;">)(</span>a<span style="color: #A6E22E;">)</span> &lt; 0<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">time_before</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">a</span>,<span style="color: #FD971F;">b</span><span style="color: #AE81FF;">)</span>    <span style="color: #A6E22E; font-weight: bold;">time_after</span><span style="color: #AE81FF;">(</span>b,a<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">time_after_eq</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">a</span>,<span style="color: #FD971F;">b</span><span style="color: #AE81FF;">)</span>  \
    <span style="color: #AE81FF;">(</span><span style="color: #A6E22E; font-weight: bold;">typecheck</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>, a<span style="color: #66D9EF;">)</span> &amp;&amp; \
     <span style="color: #A6E22E; font-weight: bold;">typecheck</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>, b<span style="color: #66D9EF;">)</span> &amp;&amp; \
     <span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">long</span><span style="color: #A6E22E;">)(</span>a<span style="color: #A6E22E;">)</span> - <span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">long</span><span style="color: #A6E22E;">)(</span>b<span style="color: #A6E22E;">)</span> &gt;= 0<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">time_before_eq</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">a</span>,<span style="color: #FD971F;">b</span><span style="color: #AE81FF;">)</span> <span style="color: #A6E22E; font-weight: bold;">time_after_eq</span><span style="color: #AE81FF;">(</span>b,a<span style="color: #AE81FF;">)</span>
</pre>
</div>
<p>
用有符号减来避免wrap around(溢出后归0)的问题，但是有个隐含的点，时间间隔不能太长(1/2个unsigned long)，当然实际也不会发生<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">#include</span> <span style="color: #AE81FF;">&lt;</span><span style="color: #E6DB74;">stdio.h</span><span style="color: #AE81FF;">&gt;</span>

<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">time_after</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">a</span>,<span style="color: #FD971F;">b</span><span style="color: #AE81FF;">)</span> \
     <span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)(</span>b<span style="color: #66D9EF;">)</span> - <span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)(</span>a<span style="color: #66D9EF;">)</span> &lt; 0<span style="color: #AE81FF;">)</span>

<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">main</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">argc</span>, <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">argv</span><span style="color: #66D9EF;">[]</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">a</span> = 0x100;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">b</span> = 0x9;

    <span style="color: #A6E22E; font-weight: bold;">printf</span><span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"%d %d %d\n"</span>, a, b, <span style="color: #A6E22E; font-weight: bold;">time_after</span><span style="color: #A6E22E;">(</span>a, b<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;

    a = 0x0;
    b = 0xffffffff;
    <span style="color: #A6E22E; font-weight: bold;">printf</span><span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"%d %d %d\n"</span>, a, b, <span style="color: #A6E22E; font-weight: bold;">time_after</span><span style="color: #A6E22E;">(</span>a, b<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;

    a = 0x80000000;
    b = 0x7fffffff;
    <span style="color: #A6E22E; font-weight: bold;">printf</span><span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"%d %d %d\n"</span>, a, b, <span style="color: #A6E22E; font-weight: bold;">time_after</span><span style="color: #A6E22E;">(</span>a, b<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">return</span> 0;
<span style="color: #AE81FF;">}</span>
</pre>
</div>

<ul class="org-ul">
<li>系统定时器<br /></li>
</ul>
<p>
就是上面讨论的，一种周期性触发中断机制，X86体系中用可编程中断时钟PIT，基于晶振<br />
</p>

<ul class="org-ul">
<li>实时时钟<br /></li>
</ul>
<p>
RTC是另外一个时钟设备，其在系统关闭后，仍可以靠电池保持计时，用于初始化xtime<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">tick_periodic</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">cpu</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #66D9EF;">(</span>tick_do_timer_cpu == cpu<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #A6E22E; font-weight: bold;">write_seqlock</span><span style="color: #A6E22E;">(</span>&amp;xtime_lock<span style="color: #A6E22E;">)</span>;

        <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Keep track of the next tick event </span><span style="color: #75715E;">*/</span>
        tick_next_period = <span style="color: #A6E22E; font-weight: bold;">ktime_add</span><span style="color: #A6E22E;">(</span>tick_next_period, tick_period<span style="color: #A6E22E;">)</span>;

        <span style="color: #A6E22E; font-weight: bold;">do_timer</span><span style="color: #A6E22E;">(</span>1<span style="color: #A6E22E;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#33258;&#22686;jiffies</span>
        <span style="color: #A6E22E; font-weight: bold;">write_sequnlock</span><span style="color: #A6E22E;">(</span>&amp;xtime_lock<span style="color: #A6E22E;">)</span>;
    <span style="color: #66D9EF;">}</span>

    <span style="color: #A6E22E; font-weight: bold;">update_process_times</span><span style="color: #66D9EF;">(</span><span style="color: #A6E22E; font-weight: bold;">user_mode</span><span style="color: #A6E22E;">(</span><span style="color: #A6E22E; font-weight: bold;">get_irq_regs</span><span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#26356;&#26032;&#26102;&#38388;,&#26631;&#35760;TIMER&#36719;&#20013;&#26029;,&#20943;&#23569;&#24403;&#21069;&#36827;&#31243;&#26102;&#38388;&#29255;&#65292;&#35774;&#32622;need_resched</span>
    <span style="color: #A6E22E; font-weight: bold;">profile_tick</span><span style="color: #66D9EF;">(</span>CPU_PROFILING<span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>
</pre>
</div>

<ul class="org-ul">
<li>定时器<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">timer_list</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">entry</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">expires</span>;

    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*function<span style="color: #66D9EF;">)(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">data</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">tvec_base</span> *<span style="color: #FD971F;">base</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_TIMER_STATS
    <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">start_site</span>;
    <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">start_comm</span><span style="color: #66D9EF;">[</span>16<span style="color: #66D9EF;">]</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">start_pid</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_LOCKDEP
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">lockdep_map</span> <span style="color: #FD971F;">lockdep_map</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">timer_list</span> <span style="color: #FD971F;">my_timer</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#23450;&#20041;</span>

<span style="color: #A6E22E; font-weight: bold;">init_timer</span><span style="color: #AE81FF;">(</span>&amp;my_timer<span style="color: #AE81FF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21021;&#22987;&#21270;</span>
my_timer.expires = jiffies + delay; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#36229;&#26102;&#33410;&#25293;</span>
my_timer.data = 0;
my_timer.function = myfunction; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#36229;&#26102;&#22238;&#35843;</span>

<span style="color: #A6E22E; font-weight: bold;">add_timer</span><span style="color: #AE81FF;">(</span>&amp;my_timer<span style="color: #AE81FF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21152;&#23450;&#26102;&#22120;</span>
<span style="color: #A6E22E; font-weight: bold;">mod_timer</span><span style="color: #AE81FF;">(</span>&amp;my_timer, jiffies+new_delay<span style="color: #AE81FF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#20462;&#25913;&#26032;&#30340;&#23450;&#26102;</span>
<span style="color: #A6E22E; font-weight: bold;">del_timer</span><span style="color: #AE81FF;">(</span>&amp;my_timer<span style="color: #AE81FF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21024;&#38500;&#23450;&#26102;&#22120;,SMP&#21487;&#33021;&#20572;&#27490;&#21516;&#26102;&#22312;&#36816;&#34892;&#36229;&#26102;&#20989;&#25968;</span>
<span style="color: #A6E22E; font-weight: bold;">del_timer_sync</span><span style="color: #AE81FF;">(</span>&amp;timer<span style="color: #AE81FF;">)</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#31561;&#24453;&#21487;&#33021;&#22312;&#36816;&#34892;&#30340;&#36229;&#26102;&#22238;&#35843;&#21518;&#20877;&#21024;&#38500;&#23450;&#26102;&#65292;&#20250;&#30561;&#30496;</span>
</pre>
</div>

<p>
定时器在下半部中执行，为了提高效率，内核将定时器超时时间划分为五组并随组下移<br />
</p>

<ul class="org-ul">
<li>延时<br /></li>
</ul>
<p>
忙等，会浪费CPU<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">delay</span> = jiffies + 2 * HZ;
<span style="color: #A6E22E; font-weight: bold;">while</span><span style="color: #AE81FF;">(</span><span style="color: #A6E22E; font-weight: bold;">time_before</span><span style="color: #66D9EF;">(</span>jiffies, delay<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
调度等，不能在中断上下文中使用，实际上不该在中断中延时<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">delay</span> = jiffies + 2 * HZ;
<span style="color: #A6E22E; font-weight: bold;">while</span><span style="color: #AE81FF;">(</span><span style="color: #A6E22E; font-weight: bold;">time_before</span><span style="color: #66D9EF;">(</span>jiffies, delay<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
    <span style="color: #A6E22E; font-size: 130%;">cond_resched</span><span style="color: #AE81FF;">()</span>;
</pre>
</div>

<p>
短延时<br />
实现方式是控制忙循环次数，因为时钟节拍精度不够<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">/* </span><span style="color: #E6DB74;">0x10c7 is 2**32 / 1000000 (rounded up) </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">udelay</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">n</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">(</span><span style="color: #A6E22E; font-weight: bold;">__builtin_constant_p</span><span style="color: #66D9EF;">(</span>n<span style="color: #66D9EF;">)</span> ? \
    <span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>n<span style="color: #A6E22E;">)</span> &gt; 20000 ? <span style="color: #A6E22E; font-weight: bold;">__bad_udelay</span><span style="color: #A6E22E;">()</span> : <span style="color: #A6E22E; font-weight: bold;">__const_udelay</span><span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">(</span>n<span style="color: #E6DB74;">)</span> * 0x10c7ul<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span> : \
    <span style="color: #A6E22E; font-weight: bold;">__udelay</span><span style="color: #66D9EF;">(</span>n<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">0x5 is 2**32 / 1000000000 (rounded up) </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">ndelay</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">n</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">(</span><span style="color: #A6E22E; font-weight: bold;">__builtin_constant_p</span><span style="color: #66D9EF;">(</span>n<span style="color: #66D9EF;">)</span> ? \
    <span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>n<span style="color: #A6E22E;">)</span> &gt; 20000 ? <span style="color: #A6E22E; font-weight: bold;">__bad_ndelay</span><span style="color: #A6E22E;">()</span> : <span style="color: #A6E22E; font-weight: bold;">__const_udelay</span><span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">(</span>n<span style="color: #E6DB74;">)</span> * 5ul<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span> : \
    <span style="color: #A6E22E; font-weight: bold;">__ndelay</span><span style="color: #66D9EF;">(</span>n<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">mdelay</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">n</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">(</span>\
    <span style="color: #66D9EF;">(</span><span style="color: #A6E22E; font-weight: bold;">__builtin_constant_p</span><span style="color: #A6E22E;">(</span>n<span style="color: #A6E22E;">)</span> &amp;&amp; <span style="color: #A6E22E;">(</span>n<span style="color: #A6E22E;">)</span>&lt;=MAX_UDELAY_MS<span style="color: #66D9EF;">)</span> ? <span style="color: #A6E22E; font-weight: bold;">udelay</span><span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>n<span style="color: #A6E22E;">)</span>*1000<span style="color: #66D9EF;">)</span> : \
    <span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">{</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">__ms</span>=<span style="color: #E6DB74;">(</span>n<span style="color: #E6DB74;">)</span>; <span style="color: #A6E22E; font-weight: bold;">while</span> <span style="color: #E6DB74;">(</span>__ms--<span style="color: #E6DB74;">)</span> <span style="color: #A6E22E; font-weight: bold;">udelay</span><span style="color: #E6DB74;">(</span>1000<span style="color: #E6DB74;">)</span>;<span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">#endif</span>
</pre>
</div>

<p>
schedule_timeout 延迟timeout再运行，延时中会睡眠<br />
通过定时器和调度器实现，所以精通为1/HZ<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#35774;&#20026;&#21487;&#20013;&#26029;,&#19981;&#24819;&#25509;&#21463;&#20449;&#21495;&#20063;&#21487;&#20197;&#35774;&#20026;TASK_UNINTERRUPTIBLE</span>
<span style="color: #A6E22E; font-size: 130%;">set_current_state</span><span style="color: #AE81FF;">(</span>TASK_INTERRUPTIBLE<span style="color: #AE81FF;">)</span>;
<span style="color: #A6E22E; font-size: 130%;">schedule_timeout</span><span style="color: #AE81FF;">(</span>timeout<span style="color: #AE81FF;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org43234df" class="outline-2">
<h2 id="org43234df"><span class="section-number-2">12</span> 第十二章 内存管理</h2>
<div class="outline-text-2" id="text-12">
<p>
32位一般用4K的页，64位一般用8K的页<br />
</p>

<ul class="org-ul">
<li>物理页结构struct page<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span>;           <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#39029;&#29366;&#24577;</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">_count</span>;               <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#24341;&#29992;&#35745;&#25968;</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">_mapcount</span>;            <span style="color: #75715E;">//</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">private</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">address_space</span> *<span style="color: #FD971F;">mapping</span>;
    <span style="color: #66D9EF;">pgoff_t</span> <span style="color: #FD971F;">index</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">lru</span>;
    <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">virtual</span>;                 <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#34394;&#25311;&#22320;&#22336;</span>
<span style="color: #AE81FF;">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>区<br /></li>
</ul>
<p>
内核把页划分为不同的区，区的实际使用和体系结构相关<br />
<b>像ISA设备DMA内存有限制，比如只能用24位，所以0-16MB预留</b><br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">区</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">物理内存</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">ZONE_DMA</td>
<td class="org-left">DMA</td>
<td class="org-left">&lt; 16MB</td>
</tr>

<tr>
<td class="org-left">ZONE_NORMAL</td>
<td class="org-left">正常可寻址的页</td>
<td class="org-left">16 ~ 896MB</td>
</tr>

<tr>
<td class="org-left">ZONE_HIGHMEM</td>
<td class="org-left">动态映射的页</td>
<td class="org-left">&gt; 896MB</td>
</tr>
</tbody>
</table>
<p>
像x64架构，并没有ZONE_HIGHMEM区<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">zone</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Fields commonly accessed by the page allocator </span><span style="color: #75715E;">*/</span>

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">zone watermarks, access with *_wmark_pages(zone) macros </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">watermark</span><span style="color: #66D9EF;">[</span>NR_WMARK<span style="color: #66D9EF;">]</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * We don't know if the memory that we're going to allocate will be freeable</span>
<span style="color: #E6DB74;">     * or/and it will be released eventually, so to avoid totally wasting several</span>
<span style="color: #E6DB74;">     * GB of ram we must reserve some of the lower zone memory (otherwise we risk</span>
<span style="color: #E6DB74;">     * to run OOM on the lower zones despite there's tons of freeable ram</span>
<span style="color: #E6DB74;">     * on the higher zones). This array is recalculated at runtime if the</span>
<span style="color: #E6DB74;">     * sysctl_lowmem_reserve_ratio sysctl changes.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">lowmem_reserve</span><span style="color: #66D9EF;">[</span>MAX_NR_ZONES<span style="color: #66D9EF;">]</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_NUMA
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">node</span>;
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * zone reclaim becomes active if more unmapped pages exist.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">min_unmapped_pages</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">min_slab_pages</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">per_cpu_pageset</span> <span style="color: #66D9EF;">__percpu</span> *<span style="color: #FD971F;">pageset</span>;
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * free areas of different sizes</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">spinlock_t</span>      <span style="color: #FD971F;">lock</span>;
    <span style="color: #66D9EF;">int</span>                     <span style="color: #FD971F;">all_unreclaimable</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">All pages pinned </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_MEMORY_HOTPLUG
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">see spanned/present_pages for more description </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">seqlock_t</span>       <span style="color: #FD971F;">span_seqlock</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">free_area</span>    <span style="color: #FD971F;">free_area</span><span style="color: #66D9EF;">[</span>MAX_ORDER<span style="color: #66D9EF;">]</span>;

<span style="color: #F92672;">#if</span><span style="color: #F92672; font-weight: bold;">n</span><span style="color: #F92672;">def</span> CONFIG_SPARSEMEM
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span>
<span style="color: #E6DB74;">     * In SPARSEMEM, this map is stored in struct mem_section</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       *<span style="color: #FD971F;">pageblock_flags</span>;
<span style="color: #F92672;">#endif</span> <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">CONFIG_SPARSEMEM </span><span style="color: #75715E;">*/</span>


    <span style="color: #A6E22E; font-size: 130%;">ZONE_PADDING</span><span style="color: #66D9EF;">(</span>_pad1_<span style="color: #66D9EF;">)</span>

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Fields commonly accessed by the page reclaim scanner </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">spinlock_t</span>      <span style="color: #FD971F;">lru_lock</span>;   
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">zone_lru</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">list</span>;
    <span style="color: #66D9EF;">}</span> <span style="color: #FD971F;">lru</span><span style="color: #66D9EF;">[</span>NR_LRU_LISTS<span style="color: #66D9EF;">]</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">zone_reclaim_stat</span> <span style="color: #FD971F;">reclaim_stat</span>;

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">pages_scanned</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">since last reclaim </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">flags</span>;         <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">zone flags, see below </span><span style="color: #75715E;">*/</span>

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Zone statistics </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">atomic_long_t</span>       <span style="color: #FD971F;">vm_stat</span><span style="color: #66D9EF;">[</span>NR_VM_ZONE_STAT_ITEMS<span style="color: #66D9EF;">]</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * prev_priority holds the scanning priority for this zone.  It is</span>
<span style="color: #E6DB74;">     * defined as the scanning priority at which we achieved our reclaim</span>
<span style="color: #E6DB74;">     * target at the previous try_to_free_pages() or balance_pgdat()</span>
<span style="color: #E6DB74;">     * invocation.</span>
<span style="color: #E6DB74;">     *</span>
<span style="color: #E6DB74;">     * We use prev_priority as a measure of how much stress page reclaim is</span>
<span style="color: #E6DB74;">     * under - it drives the swappiness decision: whether to unmap mapped</span>
<span style="color: #E6DB74;">     * pages.</span>
<span style="color: #E6DB74;">     *</span>
<span style="color: #E6DB74;">     * Access to both this field is quite racy even on uniprocessor.  But</span>
<span style="color: #E6DB74;">     * it is expected to average out OK.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">prev_priority</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * The target ratio of ACTIVE_ANON to INACTIVE_ANON pages on</span>
<span style="color: #E6DB74;">     * this zone's LRU.  Maintained by the pageout code.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">inactive_ratio</span>;


    <span style="color: #A6E22E; font-size: 130%;">ZONE_PADDING</span><span style="color: #66D9EF;">(</span>_pad2_<span style="color: #66D9EF;">)</span>
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Rarely used or read-mostly fields </span><span style="color: #75715E;">*/</span>

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * wait_table       -- the array holding the hash table</span>
<span style="color: #E6DB74;">     * wait_table_hash_nr_entries   -- the size of the hash table array</span>
<span style="color: #E6DB74;">     * wait_table_bits  -- wait_table_size == (1 &lt;&lt; wait_table_bits)</span>
<span style="color: #E6DB74;">     *</span>
<span style="color: #E6DB74;">     * The purpose of all these is to keep track of the people</span>
<span style="color: #E6DB74;">     * waiting for a page to become available and make them</span>
<span style="color: #E6DB74;">     * runnable again when possible. The trouble is that this</span>
<span style="color: #E6DB74;">     * consumes a lot of space, especially when so few things</span>
<span style="color: #E6DB74;">     * wait on pages at a given time. So instead of using</span>
<span style="color: #E6DB74;">     * per-page waitqueues, we use a waitqueue hash table.</span>
<span style="color: #E6DB74;">     *</span>
<span style="color: #E6DB74;">     * The bucket discipline is to sleep on the same queue when</span>
<span style="color: #E6DB74;">     * colliding and wake all in that wait queue when removing.</span>
<span style="color: #E6DB74;">     * When something wakes, it must check to be sure its page is</span>
<span style="color: #E6DB74;">     * truly available, a la thundering herd. The cost of a</span>
<span style="color: #E6DB74;">     * collision is great, but given the expected load of the</span>
<span style="color: #E6DB74;">     * table, they should be so rare as to be outweighed by the</span>
<span style="color: #E6DB74;">     * benefits from the saved space.</span>
<span style="color: #E6DB74;">     *</span>
<span style="color: #E6DB74;">     * __wait_on_page_locked() and unlock_page() in mm/filemap.c, are the</span>
<span style="color: #E6DB74;">     * primary users of these fields, and in mm/page_alloc.c</span>
<span style="color: #E6DB74;">     * free_area_init_core() performs the initialization of them.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">wait_queue_head_t</span>   * <span style="color: #FD971F;">wait_table</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">wait_table_hash_nr_entries</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">wait_table_bits</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * Discontig memory support fields.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pglist_data</span>  *<span style="color: #FD971F;">zone_pgdat</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">zone_start_pfn</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * zone_start_pfn, spanned_pages and present_pages are all</span>
<span style="color: #E6DB74;">     * protected by span_seqlock.  It is a seqlock because it has</span>
<span style="color: #E6DB74;">     * to be read outside of zone-&gt;lock, and it is done in the main</span>
<span style="color: #E6DB74;">     * allocator path.  But, it is written quite infrequently.</span>
<span style="color: #E6DB74;">     *</span>
<span style="color: #E6DB74;">     * The lock is declared along with zone-&gt;lock because it is</span>
<span style="color: #E6DB74;">     * frequently read in proximity to zone-&gt;lock.  It's good to</span>
<span style="color: #E6DB74;">     * give them a chance of being in the same cacheline.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">spanned_pages</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">total size, including holes </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">present_pages</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">amount of memory (excluding holes) </span><span style="color: #75715E;">*/</span>

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * rarely used fields:</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span>      *<span style="color: #FD971F;">name</span>;
<span style="color: #AE81FF;">}</span> <span style="color: #FD971F;">____cacheline_internodealigned_in_smp</span>;
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">alloc_page</td>
<td class="org-left">只分配一页</td>
</tr>

<tr>
<td class="org-left">alloc_pages</td>
<td class="org-left">分配2^order个页</td>
</tr>

<tr>
<td class="org-left">__get_free_page</td>
<td class="org-left">只分配一页,返回指向逻辑地址的指针</td>
</tr>

<tr>
<td class="org-left">__get_free_pages</td>
<td class="org-left">分配2^order个页,返回指向逻辑地址的指针</td>
</tr>

<tr>
<td class="org-left">get_zeroed_page</td>
<td class="org-left">只分配一页,让其内容填充0,返回指向逻辑地址的指针</td>
</tr>

<tr>
<td class="org-left">__free_pages</td>
<td class="org-left">释放页</td>
</tr>

<tr>
<td class="org-left">free_pages</td>
<td class="org-left">释放页,入参是逻辑地址</td>
</tr>

<tr>
<td class="org-left">free_page</td>
<td class="org-left">释放一个页,入参是逻辑地址</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>kmalloc分配以字节为单位,kfree是对应的释放程序<br /></li>
</ul>

<p>
GFP标记位<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">进程上下文，可以睡眠</td>
<td class="org-left">GFP_KERNEL</td>
</tr>

<tr>
<td class="org-left">进程上下文，不可以睡眠</td>
<td class="org-left">GFP_ATOMIC</td>
</tr>

<tr>
<td class="org-left">中断处理程序</td>
<td class="org-left">GFP_ATOMIC</td>
</tr>

<tr>
<td class="org-left">软中断</td>
<td class="org-left">GFP_ATOMIC</td>
</tr>

<tr>
<td class="org-left">tasklet</td>
<td class="org-left">GFP_ATOMIC</td>
</tr>

<tr>
<td class="org-left">DMA，可以睡眠</td>
<td class="org-left">GFP_DMA和GFP_KERNEL</td>
</tr>

<tr>
<td class="org-left">DMA, 不可以睡眠</td>
<td class="org-left">GFP_DMA和GFP_ATOMIC</td>
</tr>
</tbody>
</table>

<p>
vmalloc和kmalloc类似，但不保证物理页上的连续，不过为保持性能，常用kmalloc<br />
同时vmalloc可以睡眠<br />
</p>

<ul class="org-ul">
<li>slab分配器,为了提高申请释放内存的性能,kmalloc基于slab实现,管理slab的是kmem_cache<br /></li>
</ul>
<p>
<b>kmalloc有kmem_cache，每个kmem_cache管理一个固定大小,每个kmem_cache有多个slab</b><br />
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21019;&#24314;&#39640;&#36895;&#32531;&#23384;&#65292;&#21487;&#20197;&#30561;&#30496;</span>
<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kmem_cache</span> *
<span style="color: #A6E22E; font-size: 130%;">kmem_cache_create</span> <span style="color: #AE81FF;">(</span><span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">name</span>, <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21517;&#23383;</span>
    <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">size</span>,      <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#27599;&#20010;&#20803;&#32032;&#30340;&#22823;&#23567;</span>
    <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">align</span>,     <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#23545;&#40784;</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span>,
    <span style="color: #66D9EF;">void</span> <span style="color: #66D9EF;">(</span>*<span style="color: #A6E22E; font-size: 130%;">ctor</span><span style="color: #66D9EF;">)(</span><span style="color: #66D9EF;">void</span> *<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21024;&#38500;&#39640;&#36895;&#32531;&#23384;</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">kmem_cache_destroy</span><span style="color: #AE81FF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kmem_cache</span> *<span style="color: #FD971F;">cachep</span><span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
默认32位的内核栈大小8K，64位的内核栈大小16K<br />
</p>

<p>
高端内存的页可被映射到3G~4G,分为永久映射kmap和临时映射kmap_atomic(系统保留了一些虚拟地址),对应free的操作是kunmap和kunmap_atomic<br />
</p>

<p>
Linux 高端内存是针对物理内存来说的，虚拟内存没有高端这个概念。Linux 系统将虚拟内存分为两个部分，即用户地址空间和内核地址空间，对于 32 位系统来说，虚拟地址空间为 4GB，其中用户空间范围为 0-3GB，内核空间范围为 3-4GB。Linux 将 3GB 开始的内核虚拟地址空间的 896M 地址直接映射到物理地址空间的 0-896M，这部分是永久性映射，剩下的 128M 则可根据需要进行动态映射，也称临时性映射。如果没有动态映射，那么 1GB 的内核虚拟地址空间最多只能访问 1GB 的物理内存，那么如果物理内存大于 1GB，就会有一部分物理内存无法被内核访问到，显然不是我们想要的。因此，对于 32 位系统来说，高端物理内存是内核虚拟地址空间后 128M 可动态映射使内核得以访问的物理内存，用户空间虚拟地址也是映射到这部分物理内存<br />
</p>

<ul class="org-ul">
<li>percpu变量<br /></li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#38745;&#24577;</span>
<span style="color: #A6E22E; font-size: 130%;">DEFINE_PER_CPU</span><span style="color: #AE81FF;">(</span>type, name<span style="color: #AE81FF;">)</span>;
<span style="color: #A6E22E; font-size: 130%;">DECLARE_PER_CPU</span><span style="color: #AE81FF;">(</span>type, name<span style="color: #AE81FF;">)</span>;

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#31105;&#27490;&#20869;&#26680;&#25250;&#21344;,&#21462;&#20540;</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">get_cpu_var</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">var</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">(</span>*<span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">{</span>               \
    <span style="color: #A6E22E; font-weight: bold;">preempt_disable</span><span style="color: #E6DB74;">()</span>;              \
    &amp;<span style="color: #A6E22E; font-weight: bold;">__get_cpu_var</span><span style="color: #E6DB74;">(</span>var<span style="color: #E6DB74;">)</span>; <span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#20351;&#33021;&#20869;&#26680;&#25250;&#21344;</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">put_cpu_var</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">var</span><span style="color: #AE81FF;">)</span> <span style="color: #F92672;">do</span> <span style="color: #AE81FF;">{</span>               \
    <span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">void</span><span style="color: #66D9EF;">)</span>&amp;<span style="color: #66D9EF;">(</span>var<span style="color: #66D9EF;">)</span>;                   \
    <span style="color: #A6E22E; font-weight: bold;">preempt_enable</span><span style="color: #66D9EF;">()</span>;               \
<span style="color: #AE81FF;">}</span> <span style="color: #A6E22E; font-weight: bold;">while</span> <span style="color: #AE81FF;">(</span>0<span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#26080;&#38145;</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">per_cpu_ptr</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">ptr</span>, <span style="color: #FD971F;">cpu</span><span style="color: #AE81FF;">)</span>   <span style="color: #A6E22E; font-weight: bold;">SHIFT_PERCPU_PTR</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">(</span>ptr<span style="color: #66D9EF;">)</span>, <span style="color: #A6E22E; font-weight: bold;">per_cpu_offset</span><span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>cpu<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>


<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#21160;&#24577;&#30003;&#35831;</span>
<span style="color: #F92672;">#define</span> <span style="color: #A6E22E; font-size: 130%;">alloc_percpu</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">type</span><span style="color: #AE81FF;">)</span>  \
    <span style="color: #AE81FF;">(</span><span style="color: #A6E22E; font-weight: bold;">typeof</span><span style="color: #66D9EF;">(</span>type<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">__percpu</span> *<span style="color: #AE81FF;">)</span><span style="color: #A6E22E; font-weight: bold;">__alloc_percpu</span><span style="color: #AE81FF;">(</span><span style="color: #A6E22E; font-weight: bold;">sizeof</span><span style="color: #66D9EF;">(</span>type<span style="color: #66D9EF;">)</span>, <span style="color: #A6E22E; font-weight: bold;">__alignof__</span><span style="color: #66D9EF;">(</span>type<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">extern</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">__percpu</span> *<span style="color: #A6E22E; font-weight: bold;">__alloc_percpu</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">size</span>, <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">align</span><span style="color: #AE81FF;">)</span>;
<span style="color: #F92672;">extern</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">free_percpu</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">void</span> <span style="color: #FD971F;">__percpu</span> *__pdata<span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
Sample<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">percpu_ptr</span>;
<span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> *<span style="color: #FD971F;">foo</span>;

percpu_ptr = <span style="color: #A6E22E; font-weight: bold;">alloc_percpu</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span><span style="color: #AE81FF;">)</span>;
...
foo = <span style="color: #A6E22E; font-weight: bold;">get_cpu_var</span><span style="color: #AE81FF;">(</span>percpu_ptr<span style="color: #AE81FF;">)</span>;
...
<span style="color: #A6E22E; font-weight: bold;">put_cpu_var</span><span style="color: #AE81FF;">(</span>percpu_ptr<span style="color: #AE81FF;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org3a0d70b" class="outline-2">
<h2 id="org3a0d70b"><span class="section-number-2">13</span> 第十三章 虚拟文件系统</h2>
<div class="outline-text-2" id="text-13">
<p>
VFS屏蔽了不同文件系统，抽象出文件,目录项,索引节点和安装点<br />
</p>

<p>
<b>文件的相关信息和文件本身和不同的概念，文件相关信息，被称作文件的元数据，被存储在一个单独的数据结构中，称为inode</b><br />
</p>

<ul class="org-ul">
<li>超级块对象结构struct super_block，包含最重要的struct super_operations，里面有各项回调函数<br /></li>
</ul>
<p>
超级块用于存储特定文件系统的信息，通常对应于存放在磁盘特定扇区中的文件系统超级块或文件系统控制块<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">s_list</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Keep this first </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">dev_t</span>           <span style="color: #FD971F;">s_dev</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">search index; _not_ kdev_t </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span>       <span style="color: #FD971F;">s_dirt</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span>       <span style="color: #FD971F;">s_blocksize_bits</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">s_blocksize</span>;
    <span style="color: #66D9EF;">loff_t</span>          <span style="color: #FD971F;">s_maxbytes</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Max file size </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_system_type</span> *<span style="color: #FD971F;">s_type</span>;
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_operations</span>   *<span style="color: #FD971F;">s_op</span>;
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dquot_operations</span>   *<span style="color: #FD971F;">dq_op</span>;
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">quotactl_ops</span>   *<span style="color: #FD971F;">s_qcop</span>;
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">export_operations</span> *<span style="color: #FD971F;">s_export_op</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">s_flags</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">s_magic</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span>       *<span style="color: #FD971F;">s_root</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rw_semaphore</span> <span style="color: #FD971F;">s_umount</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mutex</span>        <span style="color: #FD971F;">s_lock</span>;
    <span style="color: #66D9EF;">int</span>         <span style="color: #FD971F;">s_count</span>;
    <span style="color: #66D9EF;">int</span>         <span style="color: #FD971F;">s_need_sync</span>;
    <span style="color: #66D9EF;">atomic_t</span>        <span style="color: #FD971F;">s_active</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_SECURITY
    <span style="color: #66D9EF;">void</span>                    *<span style="color: #FD971F;">s_security</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">xattr_handler</span>    **<span style="color: #FD971F;">s_xattr</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">s_inodes</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">all inodes </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_head</span>   <span style="color: #FD971F;">s_anon</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">anonymous dentries for (nfs) exporting </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">s_files</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">s_dentry_lru and s_nr_dentry_unused are protected by dcache_lock </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">s_dentry_lru</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">unused dentry lru </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span>         <span style="color: #FD971F;">s_nr_dentry_unused</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;"># of dentry on lru </span><span style="color: #75715E;">*/</span>

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">block_device</span> *<span style="color: #FD971F;">s_bdev</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">backing_dev_info</span> *<span style="color: #FD971F;">s_bdi</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mtd_info</span>     *<span style="color: #FD971F;">s_mtd</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">s_instances</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">quota_info</span>   <span style="color: #FD971F;">s_dquot</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Diskquota specific options </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">int</span>         <span style="color: #FD971F;">s_frozen</span>;
    <span style="color: #66D9EF;">wait_queue_head_t</span>   <span style="color: #FD971F;">s_wait_unfrozen</span>;

    <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">s_id</span><span style="color: #66D9EF;">[</span>32<span style="color: #66D9EF;">]</span>;              <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Informational name </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">void</span>            *<span style="color: #FD971F;">s_fs_info</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Filesystem private info </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">fmode_t</span>         <span style="color: #FD971F;">s_mode</span>;

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Granularity of c/m/atime in ns.</span>
<span style="color: #E6DB74;">       Cannot be worse than a second </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">u32</span>        <span style="color: #FD971F;">s_time_gran</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * The next field is for VFS *only*. No filesystems have any business</span>
<span style="color: #E6DB74;">     * even looking at it. You had been warned.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mutex</span> <span style="color: #FD971F;">s_vfs_rename_mutex</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Kludge </span><span style="color: #75715E;">*/</span>

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * Filesystem subtype.  If non-empty the filesystem type field</span>
<span style="color: #E6DB74;">     * in /proc/mounts will be "type.subtype"</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">s_subtype</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * Saved mount options for lazy filesystems using</span>
<span style="color: #E6DB74;">     * generic_show_options()</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">s_options</span>;
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_operations</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> inode *<span style="color: #66D9EF;">(</span>*alloc_inode<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *<span style="color: #FD971F;">sb</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*destroy_inode<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *<span style="color: #66D9EF;">)</span>;

    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*dirty_inode<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*write_inode<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">writeback_control</span> *<span style="color: #FD971F;">wbc</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*drop_inode<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*delete_inode<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*put_super<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*write_super<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*sync_fs<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *<span style="color: #FD971F;">sb</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">wait</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*freeze_fs<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*unfreeze_fs<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*statfs<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kstatfs</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*remount_fs<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *, <span style="color: #66D9EF;">int</span> *, <span style="color: #66D9EF;">char</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*clear_inode<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*umount_begin<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *<span style="color: #66D9EF;">)</span>;

    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*show_options<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">seq_file</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vfsmount</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*show_stats<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">seq_file</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vfsmount</span> *<span style="color: #66D9EF;">)</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_QUOTA
    <span style="color: #A6E22E; font-weight: bold;">ssize_t</span> <span style="color: #66D9EF;">(</span>*quota_read<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *, <span style="color: #66D9EF;">int</span>, <span style="color: #66D9EF;">char</span> *, <span style="color: #66D9EF;">size_t</span>, <span style="color: #66D9EF;">loff_t</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">ssize_t</span> <span style="color: #66D9EF;">(</span>*quota_write<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *, <span style="color: #66D9EF;">int</span>, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *, <span style="color: #66D9EF;">size_t</span>, <span style="color: #66D9EF;">loff_t</span><span style="color: #66D9EF;">)</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*bdev_try_to_free_page<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span>*, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span>*, <span style="color: #66D9EF;">gfp_t</span><span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>索引节点对象inode,包含内核在操作文件或目录时需要的全部信息<br /></li>
</ul>
<p>
一个inode代表文件系统中的一个文件，也可代表特殊文件，如设备文件或者管道文件，包含struct inode_operations<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_node</span>   <span style="color: #FD971F;">i_hash</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">i_list</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">backing dev IO list </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">i_sb_list</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">i_dentry</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">i_ino</span>;
    <span style="color: #66D9EF;">atomic_t</span>        <span style="color: #FD971F;">i_count</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">i_nlink</span>;
    <span style="color: #66D9EF;">uid_t</span>           <span style="color: #FD971F;">i_uid</span>;
    <span style="color: #66D9EF;">gid_t</span>           <span style="color: #FD971F;">i_gid</span>;
    <span style="color: #66D9EF;">dev_t</span>           <span style="color: #FD971F;">i_rdev</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">i_blkbits</span>;
    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">i_version</span>;
    <span style="color: #66D9EF;">loff_t</span>          <span style="color: #FD971F;">i_size</span>;
<span style="color: #F92672;">#ifdef</span> __NEED_I_SIZE_ORDERED
    <span style="color: #66D9EF;">seqcount_t</span>      <span style="color: #FD971F;">i_size_seqcount</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">timespec</span>     <span style="color: #FD971F;">i_atime</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">timespec</span>     <span style="color: #FD971F;">i_mtime</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">timespec</span>     <span style="color: #FD971F;">i_ctime</span>;
    <span style="color: #66D9EF;">blkcnt_t</span>        <span style="color: #FD971F;">i_blocks</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span>          <span style="color: #FD971F;">i_bytes</span>;
    <span style="color: #66D9EF;">umode_t</span>         <span style="color: #FD971F;">i_mode</span>;
    <span style="color: #66D9EF;">spinlock_t</span>      <span style="color: #FD971F;">i_lock</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">i_blocks, i_bytes, maybe i_size </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mutex</span>        <span style="color: #FD971F;">i_mutex</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rw_semaphore</span> <span style="color: #FD971F;">i_alloc_sem</span>;
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode_operations</span>   *<span style="color: #FD971F;">i_op</span>;
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_operations</span>    *<span style="color: #FD971F;">i_fop</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">former -&gt;i_op-&gt;default_file_ops </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span>  *<span style="color: #FD971F;">i_sb</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_lock</span>    *<span style="color: #FD971F;">i_flock</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">address_space</span>    *<span style="color: #FD971F;">i_mapping</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">address_space</span>    <span style="color: #FD971F;">i_data</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_QUOTA
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dquot</span>        *<span style="color: #FD971F;">i_dquot</span><span style="color: #66D9EF;">[</span>MAXQUOTAS<span style="color: #66D9EF;">]</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">i_devices</span>;
    <span style="color: #F92672;">union</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pipe_inode_info</span>  *<span style="color: #FD971F;">i_pipe</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">block_device</span> *<span style="color: #FD971F;">i_bdev</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cdev</span>     *<span style="color: #FD971F;">i_cdev</span>;
    <span style="color: #66D9EF;">}</span>;

    <span style="color: #66D9EF;">__u32</span>           <span style="color: #FD971F;">i_generation</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_FSNOTIFY
    <span style="color: #66D9EF;">__u32</span>           <span style="color: #FD971F;">i_fsnotify_mask</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">all events this inode cares about </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_head</span>   <span style="color: #FD971F;">i_fsnotify_mark_entries</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">fsnotify mark entries </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#endif</span>

<span style="color: #F92672;">#ifdef</span> CONFIG_INOTIFY
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">inotify_watches</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">watches on this inode </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mutex</span>        <span style="color: #FD971F;">inotify_mutex</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">protects the watches list </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#endif</span>

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">i_state</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">dirtied_when</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">jiffies of first dirtying </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">i_flags</span>;

    <span style="color: #66D9EF;">atomic_t</span>        <span style="color: #FD971F;">i_writecount</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_SECURITY
    <span style="color: #66D9EF;">void</span>            *<span style="color: #FD971F;">i_security</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_FS_POSIX_ACL
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">posix_acl</span>    *<span style="color: #FD971F;">i_acl</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">posix_acl</span>    *<span style="color: #FD971F;">i_default_acl</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #66D9EF;">void</span>            *<span style="color: #FD971F;">i_private</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">fs or device private pointer </span><span style="color: #75715E;">*/</span>
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode_operations</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*create<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *,<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *,<span style="color: #66D9EF;">int</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">nameidata</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">struct</span> dentry * <span style="color: #66D9EF;">(</span>*lookup<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *,<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">nameidata</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*link<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *,<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *,<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*unlink<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *,<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*symlink<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *,<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *,<span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*mkdir<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *,<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *,<span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*rmdir<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *,<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*mknod<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *,<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *,<span style="color: #66D9EF;">int</span>,<span style="color: #66D9EF;">dev_t</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*rename<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *,
            <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*readlink<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">__user</span> *,<span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #66D9EF;">void</span> * <span style="color: #66D9EF;">(</span>*follow_link<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">nameidata</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*put_link<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">nameidata</span> *, <span style="color: #66D9EF;">void</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*truncate<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*permission<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *, <span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*check_acl<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *, <span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*setattr<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iattr</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*getattr<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vfsmount</span> *<span style="color: #FD971F;">mnt</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kstat</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*setxattr<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *,<span style="color: #F92672;">const</span> <span style="color: #66D9EF;">void</span> *,<span style="color: #66D9EF;">size_t</span>,<span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">ssize_t</span> <span style="color: #66D9EF;">(</span>*getxattr<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *, <span style="color: #66D9EF;">void</span> *, <span style="color: #66D9EF;">size_t</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">ssize_t</span> <span style="color: #66D9EF;">(</span>*listxattr<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #66D9EF;">char</span> *, <span style="color: #66D9EF;">size_t</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*removexattr<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*truncate_range<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *, <span style="color: #66D9EF;">loff_t</span>, <span style="color: #66D9EF;">loff_t</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">long</span> <span style="color: #66D9EF;">(</span>*fallocate<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *<span style="color: #FD971F;">inode</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mode</span>, <span style="color: #66D9EF;">loff_t</span> <span style="color: #FD971F;">offset</span>,
              <span style="color: #66D9EF;">loff_t</span> <span style="color: #FD971F;">len</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*fiemap<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">fiemap_extent_info</span> *, <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">start</span>,
              <span style="color: #66D9EF;">u64</span> <span style="color: #FD971F;">len</span><span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>目录项对象<br /></li>
</ul>
<p>
'/mnt/cdrom/foo'中 / mnt cdrom foo都属于目录项对象，VFS在执行目录操作时，会现场创建目录项对象<br />
与超级块和索引节点不同，目录项不会存到磁盘里面<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">d_count</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">d_flags</span>;       <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">protected by d_lock </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">spinlock_t</span> <span style="color: #FD971F;">d_lock</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">per dentry lock </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">d_mounted</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *<span style="color: #FD971F;">d_inode</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Where the name belongs to - NULL is</span>
<span style="color: #E6DB74;">                     * negative </span><span style="color: #75715E;">*/</span>
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * The next three fields are touched by __d_lookup.  Place them here</span>
<span style="color: #E6DB74;">     * so they all fit in a cache line.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_node</span> <span style="color: #FD971F;">d_hash</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">lookup hash list </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *<span style="color: #FD971F;">d_parent</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">parent directory </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">qstr</span> <span style="color: #FD971F;">d_name</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">d_lru</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">LRU list </span><span style="color: #75715E;">*/</span>
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * d_child and d_rcu can share memory</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">union</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">d_child</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">child of parent list </span><span style="color: #75715E;">*/</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rcu_head</span> <span style="color: #FD971F;">d_rcu</span>;
    <span style="color: #66D9EF;">}</span> <span style="color: #FD971F;">d_u</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">d_subdirs</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">our children </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">d_alias</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">inode alias list </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">d_time</span>;       <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">used by d_revalidate </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry_operations</span> *<span style="color: #FD971F;">d_op</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *<span style="color: #FD971F;">d_sb</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">The root of the dentry tree </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">d_fsdata</span>;         <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">fs-specific data </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">d_iname</span><span style="color: #66D9EF;">[</span>DNAME_INLINE_LEN_MIN<span style="color: #66D9EF;">]</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">small names </span><span style="color: #75715E;">*/</span>
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry_operations</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*d_revalidate<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">nameidata</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*d_hash<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">qstr</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*d_compare<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">qstr</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">qstr</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*d_delete<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*d_release<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*d_iput<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #66D9EF;">char</span> *<span style="color: #66D9EF;">(</span>*d_dname<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #66D9EF;">char</span> *, <span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>文件对象<br /></li>
</ul>
<p>
文件对象是已打开的文件在内存中的表示，和目录项一样没有对应的磁盘数据<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * fu_list becomes invalid after file_free is called and queued via</span>
<span style="color: #E6DB74;">     * fu_rcuhead for RCU freeing</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">union</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">fu_list</span>;
        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rcu_head</span>     <span style="color: #FD971F;">fu_rcuhead</span>;
    <span style="color: #66D9EF;">}</span> <span style="color: #FD971F;">f_u</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">path</span>     <span style="color: #FD971F;">f_path</span>;
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">f_dentry</span>    f_path.dentry
<span style="color: #F92672;">#define</span> <span style="color: #FD971F;">f_vfsmnt</span>    f_path.mnt
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_operations</span>    *<span style="color: #FD971F;">f_op</span>;
    <span style="color: #66D9EF;">spinlock_t</span>      <span style="color: #FD971F;">f_lock</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">f_ep_links, f_flags, no IRQ </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">atomic_long_t</span>       <span style="color: #FD971F;">f_count</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">f_flags</span>;
    <span style="color: #66D9EF;">fmode_t</span>         <span style="color: #FD971F;">f_mode</span>;
    <span style="color: #66D9EF;">loff_t</span>          <span style="color: #FD971F;">f_pos</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">fown_struct</span>  <span style="color: #FD971F;">f_owner</span>;
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">cred</span>   *<span style="color: #FD971F;">f_cred</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_ra_state</span>    <span style="color: #FD971F;">f_ra</span>;

    <span style="color: #66D9EF;">u64</span>         <span style="color: #FD971F;">f_version</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_SECURITY
    <span style="color: #66D9EF;">void</span>            *<span style="color: #FD971F;">f_security</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">needed for tty driver, and maybe others </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">void</span>            *<span style="color: #FD971F;">private_data</span>;

<span style="color: #F92672;">#ifdef</span> CONFIG_EPOLL
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Used by fs/eventpoll.c to link all the hooks to this file </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">f_ep_links</span>;
<span style="color: #F92672;">#endif</span> <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">#ifdef CONFIG_EPOLL </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">address_space</span>    *<span style="color: #FD971F;">f_mapping</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_DEBUG_WRITECOUNT
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">f_mnt_write_state</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_operations</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">module</span> *<span style="color: #FD971F;">owner</span>;
    <span style="color: #A6E22E; font-weight: bold;">loff_t</span> <span style="color: #66D9EF;">(</span>*llseek<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">loff_t</span>, <span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">ssize_t</span> <span style="color: #66D9EF;">(</span>*read<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">__user</span> *, <span style="color: #66D9EF;">size_t</span>, <span style="color: #66D9EF;">loff_t</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">ssize_t</span> <span style="color: #66D9EF;">(</span>*write<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> <span style="color: #FD971F;">__user</span> *, <span style="color: #66D9EF;">size_t</span>, <span style="color: #66D9EF;">loff_t</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">ssize_t</span> <span style="color: #66D9EF;">(</span>*aio_read<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kiocb</span> *, <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iovec</span> *, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>, <span style="color: #66D9EF;">loff_t</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">ssize_t</span> <span style="color: #66D9EF;">(</span>*aio_write<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kiocb</span> *, <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">iovec</span> *, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>, <span style="color: #66D9EF;">loff_t</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*readdir<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">void</span> *, <span style="color: #66D9EF;">filldir_t</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*poll<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">poll_table_struct</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*ioctl<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">long</span> <span style="color: #66D9EF;">(</span>*unlocked_ioctl<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">long</span> <span style="color: #66D9EF;">(</span>*compat_ioctl<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*mmap<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*open<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*flush<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">fl_owner_t</span> <span style="color: #FD971F;">id</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*release<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*fsync<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">datasync</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*aio_fsync<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kiocb</span> *, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">datasync</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*fasync<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">int</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*lock<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">int</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_lock</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">ssize_t</span> <span style="color: #66D9EF;">(</span>*sendpage<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> *, <span style="color: #66D9EF;">int</span>, <span style="color: #66D9EF;">size_t</span>, <span style="color: #66D9EF;">loff_t</span> *, <span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #A6E22E; font-weight: bold;">long</span> <span style="color: #66D9EF;">(</span>*get_unmapped_area<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*check_flags<span style="color: #66D9EF;">)(</span><span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*flock<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">int</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_lock</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">ssize_t</span> <span style="color: #66D9EF;">(</span>*splice_write<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pipe_inode_info</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">loff_t</span> *, <span style="color: #66D9EF;">size_t</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">ssize_t</span> <span style="color: #66D9EF;">(</span>*splice_read<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">loff_t</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">pipe_inode_info</span> *, <span style="color: #66D9EF;">size_t</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*setlease<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *, <span style="color: #66D9EF;">long</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_lock</span> **<span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>根结构<br /></li>
</ul>

<p>
file_system_type - 描述各种特定文件系统类型<br />
vfsmount         - 安装节点<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_system_type</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">name</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">fs_flags</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*get_sb<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_system_type</span> *, <span style="color: #66D9EF;">int</span>,
               <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *, <span style="color: #66D9EF;">void</span> *, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vfsmount</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*kill_sb<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *<span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">module</span> *<span style="color: #FD971F;">owner</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file_system_type</span> * <span style="color: #FD971F;">next</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">fs_supers</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">lock_class_key</span> <span style="color: #FD971F;">s_lock_key</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">lock_class_key</span> <span style="color: #FD971F;">s_umount_key</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">lock_class_key</span> <span style="color: #FD971F;">i_lock_key</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">lock_class_key</span> <span style="color: #FD971F;">i_mutex_key</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">lock_class_key</span> <span style="color: #FD971F;">i_mutex_dir_key</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">lock_class_key</span> <span style="color: #FD971F;">i_alloc_sem_key</span>;
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vfsmount</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">mnt_hash</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vfsmount</span> *<span style="color: #FD971F;">mnt_parent</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">fs we are mounted on </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *<span style="color: #FD971F;">mnt_mountpoint</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">dentry of mountpoint </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">dentry</span> *<span style="color: #FD971F;">mnt_root</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">root of the mounted tree </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">super_block</span> *<span style="color: #FD971F;">mnt_sb</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">pointer to superblock </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">mnt_mounts</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">list of children, anchored here </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">mnt_child</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">and going through their mnt_child </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mnt_flags</span>;
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">4 bytes hole on 64bits arches </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">mnt_devname</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Name of device e.g. /dev/dsk/hda1 </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">mnt_list</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">mnt_expire</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">link in fs-specific expiry list </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">mnt_share</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">circular list of shared mounts </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">mnt_slave_list</span>;<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">list of slave mounts </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">mnt_slave</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">slave list entry </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vfsmount</span> *<span style="color: #FD971F;">mnt_master</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">slave is on master-&gt;mnt_slave_list </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mnt_namespace</span> *<span style="color: #FD971F;">mnt_ns</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">containing namespace </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mnt_id</span>;         <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">mount identifier </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mnt_group_id</span>;       <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">peer group identifier </span><span style="color: #75715E;">*/</span>
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * We put mnt_count &amp; mnt_expiry_mark at the end of struct vfsmount</span>
<span style="color: #E6DB74;">     * to let these frequently modified fields in a separate cache line</span>
<span style="color: #E6DB74;">     * (so that reads of mnt_flags wont ping-pong on SMP machines)</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">mnt_count</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mnt_expiry_mark</span>;        <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">true if marked for expiry </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mnt_pinned</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mnt_ghosts</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_SMP
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">__percpu</span> *mnt_writers;
<span style="color: #F92672;">#else</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">mnt_writers</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #AE81FF;">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>进程相关<br /></li>
</ul>
<p>
task_struct中的files_struct, 描述打开的文件描述符，通常各进程独立<br />
task_struct中的fs_struct, 描述进程的工作目录和根目录, 通常各进程独立<br />
task_struct中的mnt_namespace, 描述一个命令空间，通常多进程共享<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">files_struct</span> <span style="color: #AE81FF;">{</span>
  <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">   * read mostly part</span>
<span style="color: #E6DB74;">   </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">count</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">fdtable</span> *<span style="color: #FD971F;">fdt</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">fdtable</span> <span style="color: #FD971F;">fdtab</span>;
  <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">   * written part on a separate cache line in SMP</span>
<span style="color: #E6DB74;">   </span><span style="color: #75715E;">*/</span>
    spinlock_t <span style="color: #66D9EF;">file_lock</span> <span style="color: #FD971F;">____cacheline_aligned_in_smp</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">next_fd</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">embedded_fd_set</span> <span style="color: #FD971F;">close_on_exec_init</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">embedded_fd_set</span> <span style="color: #FD971F;">open_fds_init</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> * <span style="color: #FD971F;">fd_array</span><span style="color: #66D9EF;">[</span>NR_OPEN_DEFAULT<span style="color: #66D9EF;">]</span>;
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">fs_struct</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">users</span>;
    <span style="color: #66D9EF;">rwlock_t</span> <span style="color: #FD971F;">lock</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">umask</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">in_exec</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">path</span> <span style="color: #FD971F;">root</span>, <span style="color: #FD971F;">pwd</span>;
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mnt_namespace</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">atomic_t</span>        <span style="color: #FD971F;">count</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vfsmount</span> *   <span style="color: #FD971F;">root</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">list</span>;
    <span style="color: #66D9EF;">wait_queue_head_t</span> <span style="color: #FD971F;">poll</span>;
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">event</span>;
<span style="color: #AE81FF;">}</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcbef99c" class="outline-2">
<h2 id="orgcbef99c"><span class="section-number-2">14</span> 第十四章 块I/O层</h2>
<div class="outline-text-2" id="text-14">
<p>
块设备   - 随机访问固定大小数据片<br />
字符设备 - 以字符流的方式被访问<br />
</p>

<p>
缓冲区头定义了缓冲区与一个块的对应关系，buffer_head太重，bio更为轻量<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">buffer_head</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">b_state</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">buffer state bitmap (see above) </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">buffer_head</span> *<span style="color: #FD971F;">b_this_page</span>;<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">circular list of page's buffers </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">page</span> *<span style="color: #FD971F;">b_page</span>;        <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">the page this bh is mapped to </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">sector_t</span> <span style="color: #FD971F;">b_blocknr</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">start block number </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">size_t</span> <span style="color: #FD971F;">b_size</span>;          <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">size of mapping </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">char</span> *<span style="color: #FD971F;">b_data</span>;           <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">pointer to data within the page </span><span style="color: #75715E;">*/</span>

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">block_device</span> *<span style="color: #FD971F;">b_bdev</span>;
    <span style="color: #66D9EF;">bh_end_io_t</span> *<span style="color: #FD971F;">b_end_io</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">I/O completion </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">b_private</span>;        <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">reserved for b_end_io </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">b_assoc_buffers</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">associated with another mapping </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">address_space</span> *<span style="color: #FD971F;">b_assoc_map</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">mapping this buffer is</span>
<span style="color: #E6DB74;">                           associated with </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">b_count</span>;       <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">users using this buffer_head </span><span style="color: #75715E;">*/</span>
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">bio</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">sector_t</span>        <span style="color: #FD971F;">bi_sector</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">device address in 512 byte</span>
<span style="color: #E6DB74;">                           sectors </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">bio</span>      *<span style="color: #FD971F;">bi_next</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">request queue link </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">block_device</span> *<span style="color: #FD971F;">bi_bdev</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">bi_flags</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">status, command, etc </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">bi_rw</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">bottom bits READ/WRITE,</span>
<span style="color: #E6DB74;">                         * top bits priority</span>
<span style="color: #E6DB74;">                         </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span>      <span style="color: #FD971F;">bi_vcnt</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">how many bio_vec's </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span>      <span style="color: #FD971F;">bi_idx</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">current index into bvl_vec </span><span style="color: #75715E;">*/</span>

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Number of segments in this BIO after</span>
<span style="color: #E6DB74;">     * physical address coalescing is performed.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">bi_phys_segments</span>;

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">bi_size</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">residual I/O count </span><span style="color: #75715E;">*/</span>

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * To keep track of the max segment size, we account for the</span>
<span style="color: #E6DB74;">     * sizes of the first and last mergeable segments in this bio.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">bi_seg_front_size</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">bi_seg_back_size</span>;

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">bi_max_vecs</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">max bvl_vecs we can hold </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">bi_comp_cpu</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">completion CPU </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">atomic_t</span>        <span style="color: #FD971F;">bi_cnt</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">pin count </span><span style="color: #75715E;">*/</span>

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">bio_vec</span>      *<span style="color: #FD971F;">bi_io_vec</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">the actual vec list </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">bio_end_io_t</span>        *<span style="color: #FD971F;">bi_end_io</span>;

    <span style="color: #66D9EF;">void</span>            *<span style="color: #FD971F;">bi_private</span>;
<span style="color: #F92672;">#if</span> <span style="color: #F92672;">defined</span><span style="color: #66D9EF;">(</span>CONFIG_BLK_DEV_INTEGRITY<span style="color: #66D9EF;">)</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">bio_integrity_payload</span> *<span style="color: #FD971F;">bi_integrity</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">data integrity </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#endif</span>

    <span style="color: #66D9EF;">bio_destructor_t</span>    *<span style="color: #FD971F;">bi_destructor</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">destructor </span><span style="color: #75715E;">*/</span>

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * We can inline a number of vecs at the end of the bio, to avoid</span>
<span style="color: #E6DB74;">     * double allocations for a small number of bio_vecs. This member</span>
<span style="color: #E6DB74;">     * MUST obviously be kept at the very end of the bio.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">bio_vec</span>      <span style="color: #FD971F;">bi_inline_vecs</span><span style="color: #66D9EF;">[</span>0<span style="color: #66D9EF;">]</span>;
<span style="color: #AE81FF;">}</span>;
</pre>
</div>
<p>
I/O调度程序调度虚拟块设备的多个磁盘请求，以便降低磁盘寻址时间，确保磁盘性能的最优化<br />
I/O调度程序的工作是管理块设备的请求队列，主要工作是对请求队列合并与排序<br />
</p>

<p>
可以通过elevator=xxx选择不同的调度程序<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">参数</th>
<th scope="col" class="org-left">I/O调度程序</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">as</td>
<td class="org-left">预测</td>
</tr>

<tr>
<td class="org-left">cfq</td>
<td class="org-left">完全公正的排队</td>
</tr>

<tr>
<td class="org-left">deadline</td>
<td class="org-left">最终期限</td>
</tr>

<tr>
<td class="org-left">noop</td>
<td class="org-left">空操作</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgdd0454b" class="outline-2">
<h2 id="orgdd0454b"><span class="section-number-2">15</span> 第十五章 进程地址空间</h2>
<div class="outline-text-2" id="text-15">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mm_struct</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> * <span style="color: #FD971F;">mmap</span>;       <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">list of VMAs </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_root</span> <span style="color: #FD971F;">mm_rb</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> * <span style="color: #FD971F;">mmap_cache</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">last find_vma result </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_MMU
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #A6E22E; font-weight: bold;">long</span> <span style="color: #66D9EF;">(</span>*get_unmapped_area<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #FD971F;">filp</span>,
                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">addr</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">len</span>,
                <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">pgoff</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*unmap_area<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mm_struct</span> *<span style="color: #FD971F;">mm</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">addr</span><span style="color: #66D9EF;">)</span>;
<span style="color: #F92672;">#endif</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">mmap_base</span>;        <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">base of mmap area </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">task_size</span>;        <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">size of task vm space </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">cached_hole_size</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">if non-zero, the largest hole below free_area_cache </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">free_area_cache</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">first hole of size cached_hole_size or larger </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">pgd_t</span> * <span style="color: #FD971F;">pgd</span>;
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">mm_users</span>;          <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">How many users with user space? </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">atomic_t</span> <span style="color: #FD971F;">mm_count</span>;          <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">How many references to "struct mm_struct" (users count as 1) </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">map_count</span>;              <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">number of VMAs </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rw_semaphore</span> <span style="color: #FD971F;">mmap_sem</span>;
    <span style="color: #66D9EF;">spinlock_t</span> <span style="color: #FD971F;">page_table_lock</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Protects page tables and some counters </span><span style="color: #75715E;">*/</span>

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">mmlist</span>;        <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">List of maybe swapped mm's.  These are globally strung</span>
<span style="color: #E6DB74;">                         * together off init_mm.mmlist, and are protected</span>
<span style="color: #E6DB74;">                         * by mmlist_lock</span>
<span style="color: #E6DB74;">                         </span><span style="color: #75715E;">*/</span>


    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">hiwater_rss</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">High-watermark of RSS usage </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">hiwater_vm</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">High-water virtual memory usage </span><span style="color: #75715E;">*/</span>

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">total_vm</span>, <span style="color: #FD971F;">locked_vm</span>, <span style="color: #FD971F;">shared_vm</span>, <span style="color: #FD971F;">exec_vm</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">stack_vm</span>, <span style="color: #FD971F;">reserved_vm</span>, <span style="color: #FD971F;">def_flags</span>, <span style="color: #FD971F;">nr_ptes</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">start_code</span>, <span style="color: #FD971F;">end_code</span>, <span style="color: #FD971F;">start_data</span>, <span style="color: #FD971F;">end_data</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">start_brk</span>, <span style="color: #FD971F;">brk</span>, <span style="color: #FD971F;">start_stack</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">arg_start</span>, <span style="color: #FD971F;">arg_end</span>, <span style="color: #FD971F;">env_start</span>, <span style="color: #FD971F;">env_end</span>;

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">saved_auxv</span><span style="color: #66D9EF;">[</span>AT_VECTOR_SIZE<span style="color: #66D9EF;">]</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">for /proc/PID/auxv </span><span style="color: #75715E;">*/</span>

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * Special counters, in some configurations protected by the</span>
<span style="color: #E6DB74;">     * page_table_lock, in other configurations by being atomic.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mm_rss_stat</span> <span style="color: #FD971F;">rss_stat</span>;

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">linux_binfmt</span> *<span style="color: #FD971F;">binfmt</span>;

    <span style="color: #66D9EF;">cpumask_t</span> <span style="color: #FD971F;">cpu_vm_mask</span>;

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Architecture-specific MM context </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">mm_context_t</span> <span style="color: #FD971F;">context</span>;

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Swap token stuff </span><span style="color: #75715E;">*/</span>
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * Last value of global fault stamp as seen by this process.</span>
<span style="color: #E6DB74;">     * In other words, this value gives an indication of how long</span>
<span style="color: #E6DB74;">     * it has been since this task got the token.</span>
<span style="color: #E6DB74;">     * Look at mm/thrash.c</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">faultstamp</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">token_priority</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">last_interval</span>;

    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Must use atomic bitops to access the bits </span><span style="color: #75715E;">*/</span>

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">core_state</span> *<span style="color: #FD971F;">core_state</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">coredumping support </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_AIO
    <span style="color: #66D9EF;">spinlock_t</span>      <span style="color: #FD971F;">ioctx_lock</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">hlist_head</span>   <span style="color: #FD971F;">ioctx_list</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_MM_OWNER
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * "owner" points to a task that is regarded as the canonical</span>
<span style="color: #E6DB74;">     * user/owner of this mm. All of the following must be true in</span>
<span style="color: #E6DB74;">     * order for it to be changed:</span>
<span style="color: #E6DB74;">     *</span>
<span style="color: #E6DB74;">     * current == mm-&gt;owner</span>
<span style="color: #E6DB74;">     * current-&gt;mm != mm</span>
<span style="color: #E6DB74;">     * new_owner-&gt;mm == mm</span>
<span style="color: #E6DB74;">     * new_owner-&gt;alloc_lock is held</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">task_struct</span> *<span style="color: #FD971F;">owner</span>;
<span style="color: #F92672;">#endif</span>

<span style="color: #F92672;">#ifdef</span> CONFIG_PROC_FS
    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">store ref to file /proc/&lt;pid&gt;/exe symlink points to </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> *<span style="color: #FD971F;">exe_file</span>;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">num_exe_file_vmas</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_MMU_NOTIFIER
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mmu_notifier_mm</span> *<span style="color: #FD971F;">mmu_notifier_mm</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #AE81FF;">}</span>;
</pre>
</div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">mm_users</td>
<td class="org-left">使用该地址的进程数目</td>
</tr>

<tr>
<td class="org-left">mm_count</td>
<td class="org-left">结构体本身引用计数</td>
</tr>

<tr>
<td class="org-left">mmap</td>
<td class="org-left">内存区域,链表</td>
</tr>

<tr>
<td class="org-left">mm_rb</td>
<td class="org-left">和mmap一样描述内存区域，红黑树</td>
</tr>
</tbody>
</table>

<p>
所有mm_struct由mm_list域挂在双向链表中，头是init_mm<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mm_struct</span> * <span style="color: #FD971F;">vm_mm</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">The address space we belong to. </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">vm_start</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Our start address within vm_mm. </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">vm_end</span>;       <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">The first byte after our end address</span>
<span style="color: #E6DB74;">                       within vm_mm. </span><span style="color: #75715E;">*/</span>

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">linked list of VM areas per task, sorted by address </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> *<span style="color: #FD971F;">vm_next</span>;

    <span style="color: #66D9EF;">pgprot_t</span> <span style="color: #FD971F;">vm_page_prot</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Access permissions of this VMA. </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">vm_flags</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Flags, see mm.h. </span><span style="color: #75715E;">*/</span>

    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">rb_node</span> <span style="color: #FD971F;">vm_rb</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * For areas with an address space and backing store,</span>
<span style="color: #E6DB74;">     * linkage into the address_space-&gt;i_mmap prio tree, or</span>
<span style="color: #E6DB74;">     * linkage to the list of like vmas hanging off its node, or</span>
<span style="color: #E6DB74;">     * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">union</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #F92672;">struct</span> <span style="color: #A6E22E;">{</span>
            <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">list</span>;
            <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">parent</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">aligns with prio_tree_node parent </span><span style="color: #75715E;">*/</span>
            <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> *<span style="color: #FD971F;">head</span>;
        <span style="color: #A6E22E;">}</span> <span style="color: #FD971F;">vm_set</span>;

        <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">raw_prio_tree_node</span> <span style="color: #FD971F;">prio_tree_node</span>;
    <span style="color: #66D9EF;">}</span> <span style="color: #FD971F;">shared</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span>
<span style="color: #E6DB74;">     * list, after a COW of one of the file pages.  A MAP_SHARED vma</span>
<span style="color: #E6DB74;">     * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span>
<span style="color: #E6DB74;">     * or brk vma (with NULL file) can only be in an anon_vma list.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #FD971F;">anon_vma_chain</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Serialized by mmap_sem &amp;</span>
<span style="color: #E6DB74;">                      * page_table_lock </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">anon_vma</span> *<span style="color: #FD971F;">anon_vma</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Serialized by page_table_lock </span><span style="color: #75715E;">*/</span>

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Function pointers to deal with this struct. </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_operations_struct</span> *<span style="color: #FD971F;">vm_ops</span>;

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Information about our backing store: </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">vm_pgoff</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Offset (within vm_file) in PAGE_SIZE</span>
<span style="color: #E6DB74;">                       units, *not* PAGE_CACHE_SIZE </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">file</span> * <span style="color: #FD971F;">vm_file</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">File we map to (can be NULL). </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">void</span> * <span style="color: #FD971F;">vm_private_data</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">was vm_pte (shared mem) </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">vm_truncate_count</span>;<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">truncate_count or restart_addr </span><span style="color: #75715E;">*/</span>

<span style="color: #F92672;">#if</span><span style="color: #F92672; font-weight: bold;">n</span><span style="color: #F92672;">def</span> CONFIG_MMU
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_region</span> *<span style="color: #FD971F;">vm_region</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">NOMMU mapping region </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#endif</span>
<span style="color: #F92672;">#ifdef</span> CONFIG_NUMA
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mempolicy</span> *<span style="color: #FD971F;">vm_policy</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">NUMA policy for the VMA </span><span style="color: #75715E;">*/</span>
<span style="color: #F92672;">#endif</span>
<span style="color: #AE81FF;">}</span>;


<span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_operations_struct</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*open<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> * <span style="color: #FD971F;">area</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">void</span> <span style="color: #66D9EF;">(</span>*close<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> * <span style="color: #FD971F;">area</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*fault<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> *<span style="color: #FD971F;">vma</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_fault</span> *<span style="color: #FD971F;">vmf</span><span style="color: #66D9EF;">)</span>;

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">notification that a previously read-only page is about to become</span>
<span style="color: #E6DB74;">     * writable, if an error is returned it will cause a SIGBUS </span><span style="color: #75715E;">*/</span>
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*page_mkwrite<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> *<span style="color: #FD971F;">vma</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_fault</span> *<span style="color: #FD971F;">vmf</span><span style="color: #66D9EF;">)</span>;

    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">called by access_process_vm when get_user_pages() fails, typically</span>
<span style="color: #E6DB74;">     * for use by special VMAs that can switch between memory and hardware</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*access<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> *<span style="color: #FD971F;">vma</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">addr</span>,
              <span style="color: #66D9EF;">void</span> *<span style="color: #FD971F;">buf</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">len</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">write</span><span style="color: #66D9EF;">)</span>;
<span style="color: #F92672;">#ifdef</span> CONFIG_NUMA
    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * set_policy() op must add a reference to any non-NULL @new mempolicy</span>
<span style="color: #E6DB74;">     * to hold the policy upon return.  Caller should pass NULL @new to</span>
<span style="color: #E6DB74;">     * remove a policy and fall back to surrounding context--i.e. do not</span>
<span style="color: #E6DB74;">     * install a MPOL_DEFAULT policy, nor the task or system default</span>
<span style="color: #E6DB74;">     * mempolicy.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*set_policy<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> *<span style="color: #FD971F;">vma</span>, <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">mempolicy</span> *<span style="color: #FD971F;">new</span><span style="color: #66D9EF;">)</span>;

    <span style="color: #75715E;">/*</span>
<span style="color: #E6DB74;">     * get_policy() op must add reference [mpol_get()] to any policy at</span>
<span style="color: #E6DB74;">     * (vma,addr) marked as MPOL_SHARED.  The shared policy infrastructure</span>
<span style="color: #E6DB74;">     * in mm/mempolicy.c will do this automatically.</span>
<span style="color: #E6DB74;">     * get_policy() must NOT add a ref if the policy at (vma,addr) is not</span>
<span style="color: #E6DB74;">     * marked as MPOL_SHARED. vma policies are protected by the mmap_sem.</span>
<span style="color: #E6DB74;">     * If no [shared/vma] mempolicy exists at the addr, get_policy() op</span>
<span style="color: #E6DB74;">     * must return NULL--i.e., do not "fallback" to task or system default</span>
<span style="color: #E6DB74;">     * policy.</span>
<span style="color: #E6DB74;">     </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> mempolicy *<span style="color: #66D9EF;">(</span>*get_policy<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> *<span style="color: #FD971F;">vma</span>,
                    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">addr</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #A6E22E; font-weight: bold;">int</span> <span style="color: #66D9EF;">(</span>*migrate<span style="color: #66D9EF;">)(</span><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">vm_area_struct</span> *<span style="color: #FD971F;">vma</span>, <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">nodemask_t</span> *<span style="color: #FD971F;">from</span>,
        <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">nodemask_t</span> *<span style="color: #FD971F;">to</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #FD971F;">flags</span><span style="color: #66D9EF;">)</span>;
<span style="color: #F92672;">#endif</span>
<span style="color: #AE81FF;">}</span>;
</pre>
</div>

<p>
和物理页不同，VMA标志规定了读写执行等权限<br />
</p>

<ul class="org-ul">
<li>页表<br /></li>
</ul>
<p>
默认三级页表，struct mm_struct -&gt; pgd_t -&gt; pmd_t -&gt; pte_t，缓存页面的硬件结构为TLB<br />
</p>

<p>
Q: 页表是用于虚拟内存访问的，那它本身存在哪里？怎么访问？<br />
A: 在mm_struct里的pgd,会存在cr3中，但存前会成物理地址给cr3，不然就套娃了<br />
Q: 多级页表每一步中间查找用的是物理地址还是虚拟地址？<br />
A: 物理地址<br />
</p>
</div>
</div>

<div id="outline-container-orgd784b54" class="outline-2">
<h2 id="orgd784b54"><span class="section-number-2">16</span> 第十六章 页高速缓存和页回写</h2>
<div class="outline-text-2" id="text-16">
<p>
物理页到虚拟页是个一对多的映射,比如有多个进程的vm_area_struct映射到同一个页,但是只会有一个页缓存结构address_space<br />
页高速缓存主要给I/O使用,但是它设计为一个通用结构<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">address_space</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">inode</span>        *<span style="color: #FD971F;">host</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">owner: inode, block_device </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">radix_tree_root</span>  <span style="color: #FD971F;">page_tree</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">radix tree of all pages </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">spinlock_t</span>      <span style="color: #FD971F;">tree_lock</span>;  <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">and lock protecting it </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">i_mmap_writable</span>;<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">count VM_SHARED mappings </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">prio_tree_root</span>   <span style="color: #FD971F;">i_mmap</span>;     <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">tree of private and shared mappings </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">i_mmap_nonlinear</span>;<span style="color: #75715E;">/*</span><span style="color: #E6DB74;">list VM_NONLINEAR mappings </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">spinlock_t</span>      <span style="color: #FD971F;">i_mmap_lock</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">protect tree, count, list </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>        <span style="color: #FD971F;">truncate_count</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">Cover race condition with truncate </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">nrpages</span>;    <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">number of total pages </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">pgoff_t</span>         <span style="color: #FD971F;">writeback_index</span>;<span style="color: #75715E;">/* </span><span style="color: #E6DB74;">writeback starts here </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">const</span> <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">address_space_operations</span> *<span style="color: #FD971F;">a_ops</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">methods </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>       <span style="color: #FD971F;">flags</span>;      <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">error bits/gfp mask </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">backing_dev_info</span> *<span style="color: #FD971F;">backing_dev_info</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">device readahead, etc </span><span style="color: #75715E;">*/</span>
    <span style="color: #66D9EF;">spinlock_t</span>      <span style="color: #FD971F;">private_lock</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">for use by the address_space </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">private_list</span>;   <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">ditto </span><span style="color: #75715E;">*/</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">address_space</span>    *<span style="color: #FD971F;">assoc_mapping</span>; <span style="color: #75715E;">/* </span><span style="color: #E6DB74;">ditto </span><span style="color: #75715E;">*/</span>
<span style="color: #AE81FF;">}</span> <span style="color: #A6E22E; font-weight: bold;">__attribute__</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">(</span><span style="color: #A6E22E; font-weight: bold;">aligned</span><span style="color: #A6E22E;">(</span><span style="color: #A6E22E; font-weight: bold;">sizeof</span><span style="color: #E6DB74;">(</span><span style="color: #66D9EF;">long</span><span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
用户可以通过调用sync和fsync去写回脏页，同时flusher线程也被会周期性的唤醒去处理脏页<br />
</p>
</div>
</div>

<div id="outline-container-org7545ecf" class="outline-2">
<h2 id="org7545ecf"><span class="section-number-2">17</span> 第十七章 设备与模块</h2>
<div class="outline-text-2" id="text-17">
<p>
/proc的结构比较混乱，/sys旨在解决这种混乱的结构，新的驱动程序都应在/sys下<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">块设备</td>
<td class="org-left">blkdev 可寻址，以块为单位，块大小随设备不同而不同，随机访问，通常被挂载为文件系统</td>
</tr>

<tr>
<td class="org-left">字符设备</td>
<td class="org-left">cdev 不可寻址，数据流式访问，直接访问设备节点与字符设备交互</td>
</tr>

<tr>
<td class="org-left">网络设备</td>
<td class="org-left">通过套接字访问</td>
</tr>
</tbody>
</table>

<p>
伪设备pseudo device - 非物理设备，用于访问内核<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">随机数发生器</td>
<td class="org-left">/dev/random、/dev/urandom</td>
</tr>

<tr>
<td class="org-left">空设备</td>
<td class="org-left">/dev/null</td>
</tr>

<tr>
<td class="org-left">零设备</td>
<td class="org-left">/dev/zero</td>
</tr>

<tr>
<td class="org-left">满设备</td>
<td class="org-left">/dev/full</td>
</tr>

<tr>
<td class="org-left">内存设备</td>
<td class="org-left">/dev/mem</td>
</tr>
</tbody>
</table>

<p>
一个简单的kernel module的例了<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">#include</span> <span style="color: #AE81FF;">&lt;</span><span style="color: #E6DB74;">linux/init.h</span><span style="color: #AE81FF;">&gt;</span>
<span style="color: #F92672;">#include</span> <span style="color: #AE81FF;">&lt;</span><span style="color: #E6DB74;">linux/module.h</span><span style="color: #AE81FF;">&gt;</span>
<span style="color: #F92672;">#include</span> <span style="color: #AE81FF;">&lt;</span><span style="color: #E6DB74;">linux/kernel.h</span><span style="color: #AE81FF;">&gt;</span>

<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #A6E22E; font-size: 130%;">hello_init</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">void</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #A6E22E; font-weight: bold;">printk</span><span style="color: #66D9EF;">(</span>KERN_ALERT <span style="color: #E6DB74;">"I bear a charmed life.\n"</span><span style="color: #66D9EF;">)</span>;
    <span style="color: #F92672;">return</span> 0;
<span style="color: #AE81FF;">}</span>

<span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E; font-size: 130%;">hello_exit</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">void</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #A6E22E; font-weight: bold;">printk</span><span style="color: #66D9EF;">(</span>KERN_ALERT <span style="color: #E6DB74;">"Out, out, brief candle.\n"</span><span style="color: #66D9EF;">)</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #A6E22E; font-size: 130%;">module_init</span><span style="color: #AE81FF;">(</span>hello_init<span style="color: #AE81FF;">)</span>;
<span style="color: #A6E22E; font-size: 130%;">module_exit</span><span style="color: #AE81FF;">(</span>hello_exit<span style="color: #AE81FF;">)</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #FD971F;">obj-m</span> := hello.o
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">make -C /mnt/hgfs/linux-2.6-git/linux-2.6/ <span style="color: #FD971F;">SUBDIRS</span>=$<span style="color: #FD971F;">PWD</span> modules
</pre>
</div>

<p>
depmod生成模块依赖关系，depmod -A只生成新模块的依赖，生成的文件在/lib/modules/version/modules.dep中<br />
insmod rmmod用于装载和卸载模块<br />
modprobe modprobe -r也用于装载和卸载模块，同时会自动加载所依赖的模块<br />
</p>

<p>
kernel编译用了kconfig系统<br />
</p>
<div class="org-src-container">
<pre class="src src-kconfig">config FISHING_POLE
    tristate "Fish Master 3000 support"
    default n
    help
        test kbuild system
</pre>
</div>

<p>
EXPORT_SYMBOL用于导出符号<br />
</p>

<ul class="org-ul">
<li>设备模型<br /></li>
</ul>

<p>
kobject会嵌入到设备结构体中，包含kobject的结构可以使用kobject的功能<br />
kt<br />
kobject指向ktype，ktype定义了一些kobject的普遍特性，比如析构，sysfs<br />
kobject同时归入kset集合，kset包含的kobject在sysfs中以独立的目录出现<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kobject</span> <span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">char</span>      *<span style="color: #FD971F;">name</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">list_head</span>    <span style="color: #FD971F;">entry</span>;
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kobject</span>      *<span style="color: #FD971F;">parent</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#29238;&#23545;&#35937;</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kset</span>     *<span style="color: #FD971F;">kset</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">kobject&#38598;&#21512;</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kobj_type</span>    *<span style="color: #FD971F;">ktype</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#26222;&#36941;&#29305;&#24615;</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">sysfs_dirent</span> *<span style="color: #FD971F;">sd</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">sysfs_dirent&#65292;&#22312;sys&#20013;&#34920;&#31034;</span>
    <span style="color: #F92672;">struct</span> <span style="color: #66D9EF;">kref</span>     <span style="color: #FD971F;">kref</span>; <span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#24341;&#29992;&#35745;&#25968;</span>
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">state_initialized</span>:1;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">state_in_sysfs</span>:1;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">state_add_uevent_sent</span>:1;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">state_remove_uevent_sent</span>:1;
    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">uevent_suppress</span>:1;
<span style="color: #AE81FF;">}</span>;
</pre>
</div>

<p>
sys形成了driver的对象树,kobject是目录,文件是attribute<br />
</p>
</div>
</div>

<div id="outline-container-org8dfcf0c" class="outline-2">
<h2 id="org8dfcf0c"><span class="section-number-2">18</span> 第十八章 调试</h2>
<div class="outline-text-2" id="text-18">
<p>
printk在任何上下文都可以调用<br />
printk使用LOG_BUF_LEN的环形队列，默认是16KB，如果有大量消息，新消息会覆盖老消息<br />
dmesg和/proc/kmsg获得内核消息<br />
oops是内核错误时打印的日志，包括寄存器值和栈回溯<br />
为了方便调试，会把符号表编入内核，CONFIG_KALLSYMS配置选项启用，这样栈回溯可以直接打出函数名，而不是地址<br />
以下选项建议开启以便调试内核<br />
</p>
<div class="org-src-container">
<pre class="src src-bash">CONFIG_PREEMPT = y
CONFIG_DEBUG_KERNEL = y
CONFIG_KALLSYMS = y
CONFIG_DEBUG_SPINLOCK_SLEEP = y
</pre>
</div>
<p>
kgdb也可以远程调试内核<br />
</p>

<ul class="org-ul">
<li>技巧<br /></li>
</ul>
<p>
a. 用uid来分离代码<br />
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #A6E22E; font-weight: bold;">if</span> <span style="color: #AE81FF;">(</span>current-&gt;uid != 7777<span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span style="color: #AE81FF;">}</span>
<span style="color: #F92672;">else</span> <span style="color: #AE81FF;">{</span>
<span style="color: #75715E;">//</span><span style="color: #E6DB74;">&#35201;&#35843;&#35797;&#30340;&#20195;&#30721;</span>
<span style="color: #AE81FF;">}</span>
</pre>
</div>
<p>
b. 可以用全局变量控制代码流程<br />
c. 加统计计数<br />
d. 限制打印频率以防冲爆buffer<br />
e. 知道代码从哪个提交开始可以用二分法<br />
</p>
</div>
</div>

<div id="outline-container-org9bc92ef" class="outline-2">
<h2 id="org9bc92ef"><span class="section-number-2">19</span> 第十九章 可移植性</h2>
<div class="outline-text-2" id="text-19">
<ul class="org-ul">
<li>体系结构相关代码在arch/architecture/中<br /></li>
<li>对于长度明确的数据类型(s8, u32),一般来说，如果头文件用户进程也会使用的话，不能直接用,要加两个_,如__u32<br /></li>
<li>尽量显式保证自然对齐，而不让编译器来做, -Wpadded可以让gcc警告<br /></li>
<li>最大公因子，假定任何事情都可能发生，任何潜在的约束也都存在<br /></li>
<li>最小公约数，不要假定给定的内核特性是可用的，仅仅需要最小的体系结构功能<br /></li>
</ul>
</div>
</div>

<div id="outline-container-orgf81b955" class="outline-2">
<h2 id="orgf81b955"><span class="section-number-2">20</span> 第二十章 补丁、开发和社区</h2>
<div class="outline-text-2" id="text-20">
<p>
代码风格 Documentation/CodingStyle<br />
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: xuali2</p>
<p class="date">Created: 2020-10-24 六 21:48</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
