#+SETUPFILE: ~/.emacs.d/themes/org-html-themes/setup/theme-readtheorg.setup
#+OPTIONS: \n:t
#+OPTIONS: tex:t
#+STARTUP: latexpreview
#+OPTIONS: tex:dvipng
#+HTML_MATHJAX: align: left indent: 5em tagside: left font: Neo-Euler
#+attr_html: :width 300px
#+attr_latex: :width 300px
#+ATTR_ORG: :width 300

* 理解系统
  你必须掌握系统的工作原理以及它是如何设计的.在某些情况下，还要知道为什么这样设计.
** 阅读手册
   应用说明和实现指南提供了丰富的信息，它们不仅描述了系统是如何工作的，而且专门给出了先前已发生过的问题.常见错误的警告具有难以置信的价值.
** 知道什么是正常的
   你必须掌握一些你所工作的技术领域的基础知识.
** 工作流程
   了解所有的模块和接口都是做什么的.
   *当系统有一些部分是“黑盒子”时，这意味着你不知道它内部有什么，但应该知道它们如何与其他部分交互，这至少可以帮助判断问题是在内部还是外部.如果问题发生在黑盒子内部，你必须更换盒子，但如果问题出在外部，就可以修复它了.*
** 工具
   你越是精通工具，就越容易查明系统中发生了什么事情.要花时间学习与工具有关的一切，
   模拟示波器（analogscope）可以看到噪声，但无法存储太多数据；数字逻辑分析器可以捕获大量的数据，但看不到噪声.
* 制造失败
  仔细观察你做了什么，然后再做一次，并且记下你做的每个步骤.然后，按照你自己所写的步骤去做，确定这样做确实导致了错误.实际上，在有些情况下，令设备发生错误具有一定的破坏性，或者代价很大，这时每次都使设备发生同样的错误就不是一种好办法.为了控制损失，必须改变一些地方，但我们应该尽量少改动原来的系统和顺序.
** 从已知的一个状态开始
** 使用自动化工具引发失败
** 不要模拟失败
   引发失败（正确）和模拟失败（错误）这二者之间存在着非常大的差别.不要试图模拟失败机理本身.
   模拟失败有时结果更糟，发生新的错误，分散了你对正在查找的问题的注意力.
   所做的改变应该是一些高层次的改变，只影响错误发生的频率，而不影响错误的发生方式.
** 间歇性bug
   查找并控制各种条件，而后
*** 仔细观察失败
    忽略掉不发生的时候，而在失败每次发生时观察它.关键是在每次运行的时候捕捉相关信息，以便在发生失败之后查看这些数据.
*** 足够多的信息
    当你捕获到足够多的信息时（像前一节所描述的那样），就可以确定哪些因素总是与bug有关，或者哪些因素从来都与bug无关.在查找问题根源的时候，这些因素是需要重点关注的.
*** 找到总是与失败有关的事件序列.
** “那不可能发生”
   这里的关键是“那”这个词.“那”是指什么？它是测试人员或工程师所认为的问题背后的失败机理.或者说“那”是指一个事件序列，这个序列看起来是再现问题的关键.而且，事实上，“那”可能确实不会发生.但是，失败的的确确发生了.我们并不清楚是什么测试序列触发了它，也不知道它是由什么bug引起的.那么，下一步就是 *忘掉所有假设* ，让它在工程师面前再次发生.
** 永远不要丢掉调试工具
   一种测试工具可以在其他的调试场合重复使用.当你设计它的时候，应该考虑到这一点，并且使它易于维护和升级.这意味着要采用好的工程技术，并实现文档化，等等.
* 不要想，而要看
  亲眼看到底层的失败是非常重要的.如果你猜测失败是如何发生的，那常常会修复一些根本不是bug的问题.这样的修复不仅不会解决问题，而且还会浪费时间和金钱，甚至会破坏其他地方.
** 观察失败
   一定要亲眼看到实际错误是如何发生的.观察往往比猜测能够更快地找到问题.因为猜测虽然看起来是捷径，但这条捷径并不会带你找到问题的根源.
** 查看细节
   在停下来思考问题之前，对细节的观察应该到什么程度才合适呢？简单的答案是：“一直观察，直到把问题的原因锁定在几种可能性之内.”
* 调试系统
** 设计内嵌调试工具
   状态消息的开启和关闭有3种不同级别选择：编译时、启动时和运行时.
   消息类型的通用代码，如“info（信息）”、“error（错误）”或“reallynastyerror（严重错误）”；输出消息最初是由哪位工程师写的（为了跟踪谁做了什么工作，以及他为什么要输出这些消息）；运行时数据，例如命令、状态码和预计值与实际值的比较，这些能够为你提供后面的调试工作所需的详细信息.输出内容应该能够证实你的判断，或者显示出你未意料到的行为.
   植入插装工具后，要使失败再次发生，以便证实环境确实相同，而且插装工具没有对问题造成影响.
** 外部调试工具
   *低频示波器无法找到高频问题，数字逻辑分析器无法发现噪声和短时脉冲波形干扰.*
   即使微小的改变也可能对系统造成足够大的影响，导致bug被完全隐藏起来.插装就是这些改变之一，因此在为有故障的系统添加插装工具之后，要使系统再次失败.
** 猜测只是为了确定搜索的重点目标
   不要过分相信你的猜测，它们往往偏离了方向，并且把你引入歧途.
   如果事实表明，经过仔细的插装仍然无法确定你的猜测是否正确，那么就到了退回并再次猜测的时候了.
* 分而治之
  通过反复地把问题分成好的一半和坏的一半，来缩小搜索范围，然后进一步研究有问题的那一半.
** 缩小搜索范围
   先确定范围,然后使用二分法，确定问题发生在上游或下游，而后不断递归
*** 插入易于识别的模式
    使问题更容易被识别
*** 从有问题的支路开始查找问题
    不要从好的一端开始去确认一些正确的事情，正确的事情太多了（这也是你所希望的）.从错误的一端开始（也就是从发出臭味的粉红色排放物开始），然后向上游追查.
** 修复已知bug
   如果同时出现了多个问题，当你确实查明了其中的一个问题时，应该立即修复它，然后再查找其他问题.
** 消除噪声干扰
   有些特定类型的bug可能会引起其他bug，因此应该首先查找并修复它们.比如在硬件中，噪声信号可能会引起各种难以查找的间歇性问题.
* 一次只改一个地方
  *为了修复问题而更改了一个地方，但这个修改并没有解决问题，如果认为这不会产生什么影响.这是一个非常错误的假设.*
** 使用步枪，而不要用散弹枪
   如果你认为你需要一支散弹枪来击中靶子，而问题却在于你无法看清靶子.
   在很多情况下，你可能想改变系统的不同部分，以便看看它们是否对问题有影响.这往往是一个危险的信号，说明你正在猜测，而不是使用调试工具观察正在发生什么.
** 一次只改变一个测试
   改变测试序列或一些操作参数可以使问题更加有规律地出现，这有助于观察错误，而且可能会帮助我们找到问题的线索.但我们仍然应该一次只改变一个地方，以便判断哪个参数有影响.
** 与正常系统进行比较
   同时运行系统的一个正常的例子和有问题的例子，然后并排观察两个调试记录，注意它们之间的区别.如果你在两个测试之间更改了很多代码，或者为两个测试设置了不同的环境，那么这两个测试将很难对比.试着从相同机器的连续测试中获取调试记录，不要使用不同的机器、软件、参数、用户输入，也不要在不同的时间和不同的环境下进行测试.但如果你没有线索，就准备好查看整个日志吧，因为你并不知道区别在哪里.
** 自从上一次能够正常工作以来你更改了什么
   正常的系统和错误的系统之间的区别是由于一项更改造成的.做了更改之后，正常的系统开始出现故障.一种非常有效的办法是找出第一个导致系统出错的版本.通常，新的设计会出问题，这也是我们为什么总是在发布新产品之前对新设计进行测试的原因.有时一个部分的新设计与另一个正常工作的部分不兼容.
* 保持审计跟踪
  必须记录下每一件事情，不起眼的事情可能会很重要.
** 记下你的每步操作、顺序和结果
   在检查某问题时，要记下你 *所做的事* 、 *做事的顺序* ，以及 *发生的结果* .
** 注意细节
   审计跟踪的价值已经被普遍认可，但所需的详细程度却没有被接受，因为很多信息都被忽略了.
** 关联
   某些症状与其他症状或调试信息关联起来是非常有用的.“线路刚刚接通时它会发出很大的噪声”比“它发出很大的噪声”要好.但最好的描述是“它发出很大的噪声，从14:05:23开始，持续4秒”.
** 好记性不如烂笔头
   在细节方面，永远都不要相信你的记忆，而要把它写下来.如果你相信你的记忆，将会制造很多麻烦.
* 检查插头 - 保证正确的运行环境
** 怀疑自己的假设
   永远不要相信自己的假设，特别是当这些假设在一些无法解释的问题中是核心因素的时候.你可能奇怪为什么一个复杂的数字芯片无法正确工作，而你却没有查看一下是否为它提供了电源.人们经常会说：“这段新代码运行起来与原来的代码一模一样.”随后却发现实际上根本就没有载入新代码.你只是载入了旧代码，或者是载入了新代码，但系统仍然执行了旧代码，
   当我们看到一个问题时，通常在某个特定位置看到了问题，但导致这个问题的原因却在上游或者是一个基础性的问题.
** 从头开始检查
   保证正确的启动环境
** 对工具进行测试
   不仅仅是工具的默认环境配置可能有错误，而且工具本身也可能有bug.
* 获得全新观点
** 寻求帮助
   - 获得全新观点
     有时向别人解释问题也会使你有全新的认识，之后你自己就解决了问题.对事实进行组织的过程迫使你跳出你原来的思维模式.
   - 询问专家
   - 借鉴别人的经验
     你周围可能有人以前见过你遇到的情况，当你向他们快速描述事情的经过后，他们会准确地告诉你出了什么问题.
** 到哪里寻求帮助
   - 公司的知识管理系统.
   - 第三方的支持.
** 放下面子
   你可能害怕寻求帮助，你认为这是无能的表现.但事实恰恰相反，这只是表明你急于修复bug.
** 报告症状，而不是理论
   无论你想要获得什么样的帮助，在向别人描述问题的时候，一定要记住一件事：报告症状，而不要讲你的理论.当寻求帮助时，描述发生的事情，描述你看到的一切.如果有可能，还要把条件描述清楚.告诉别人什么事情是间歇发生的，什么事情不是.
** 即使不是十分肯定，也可以提出来
   有时你可能注意到一些数据看起来很别扭，像是错误的，或者与问题有某种关系，但你不确定为什么会这样.这些地方是值得提出来的，事实是你发现了一些出乎意料或不理解的事情.
* 如果你不修复bug，它将依然存在
** 检查问题确实已被修复
   不要假设问题已被修复
** 检查确实是修复措施解决了问题
   当你认为你已经修复了一个设计问题时，取消这个修复，确定系统再次失败.然后再应用这个修复，再次验证问题已修复.直到你经过从修复到失败，再从失败到修复这个过程之后.如果只把修复撤销，系统将仍像过去那样发生失败，那么你就可以非常肯定测试序列并没有被改变，你的修复确实解决了问题.当然，在有些情况下，如果你只是修理一个设备（而不是工程设计问题），那么重新制造失败可能是不必要的，也是不便的.
** bug从来不会自己消失
   这样做还有一个额外的好处，那就是即使你无法利用这些信息来修复问题，至少客户会知道你认真地跟踪了问题.
** 从根本上解决问题
   必须找到真正的失败之处,而不是猜测的换几个零件.
** 对过程进行修复
   修复系统和修复过程（正是这个过程导致了bug）之间的界限很难分清楚,如果设计质量不行，那就更正它.
* 远程调试
** 限制
   - 故障无法亲眼所见
   - 联系人不一定专业
   - 尽力找到应急之策，而不是调试
** 规则
   - 理解系统
     连接到本产品的其他产品、运行在本产品中或基于本产品运行的部件、占用本产品所有内存的部件，或者其他不利于本产品使用的方面.
     询问用户时获得的观点不能全信，需要准确的配置工具, 当你选择的区域被证明与问题无关时，应该准备改变重点，转而钻研另一区域.
     *当对方出问题的地方是硬件时，必须尽早获得系统图.*
   - 制造失败
     必须清楚地了解导致故障症状出现的事件序列.从头开始，如果有必要，重新启动系统.
   - 不要想，而要看
     a. 屏幕共享
     b. 日志文件
   - 分而治之
     尽量抵制只更换硬件或软件模块的诱惑
   - 一次只改一个地方
     是阻止用户胡乱更换零部件
   - 保持审计跟踪
     要让他们告诉你他们做了什么，而不是仅仅询问他们是否按照你的要求去做了，这样才能验证他们的操作是否无误,日志与系统生成的其他审计跟踪比用户要可靠得多,最后，要一直发掘与客户现场环境有关的信息.
   - 检查插头
     最基本的一个注意事项是不要假设用户如何使用你的产品.对所有事情都要进行确认.不要让他们听到你的笑声.
   - 获得全新观点
     bug历史数据库很重要.
   - 如果你不修复bug，它将依然存在
     解决问题很容易就让用户满意了.但优秀的调试人员应该想得更多，请他们关注问题的残留影响或修复的副作用.
